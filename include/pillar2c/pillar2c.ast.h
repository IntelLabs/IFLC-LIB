/*
 * Redistribution and use in source and binary forms, with or without modification, are permitted 
 * provided that the following conditions are met:
 * 1.   Redistributions of source code must retain the above copyright notice, this list of 
 * conditions and the following disclaimer.
 * 2.   Redistributions in binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Forward Declarations
#ifndef __cplusplus
#include "pillar2c/pillar2c.ast_c.h"
#else // __cplusplus
class AST_node;
class translation_unit;
class primary_expression;
class postfix_expression;
class call_expression;
class unary_expression;
class multiplicative_expression;
class additive_expression;
class shift_expression;
class relational_expression;
class and_expression;
class exclusive_or_expression;
class inclusive_or_expression;
class logical_and_expression;
class logical_or_expression;
class conditional_expression;
class declaration;
class statement;
class statement_list;
class function_definition;
class equality_expression;
class constant_expression;
class external_declaration;
class declaration_list;
class declaration_specifiers;
class init_declarator_list;
class init_declarator;
class declarator;
class initializer;
class pointer;
class direct_declarator;
class storage_class_specifier;
class type_specifier;
class type_qualifier;
class function_specifier;
class call_conv_specifier;
class struct_or_union_specifier;
class enum_specifier;
class type_qualifier_list;
class direct_declarator_direct_declarator_type_qualifier_list;
class parameter_type_list;
class identifier_list;
class designator_list;
class block_item;
class expression;
class type_name;
class initializer_list;
class assignment_expression;
class unary_operator;
class cast_expression;
class assignment_operator;
class argument_expression_list;
class struct_or_union;
class struct_declaration_list;
class struct_declaration;
class struct_declarator_list;
class qualifier_list;
class specifier_qualifier_list;
class struct_declarator;
class enumerator_list;
class enumerator;
class parameter_list;
class parameter_declaration;
class abstract_declarator;
class enumerator_list_enumerator;
class direct_abstract_declarator;
class designation;
class designator;
class compound_statement;
class expression_statement;
class selection_statement;
class iteration_statement;
class jump_statement;
class block_item_list;
class labeled_statement;
class labeled_statement_identifier;
class anonymous_struct_declaration;
class declspec_specifier;
class type_specifier_PRT_REF;
class continuation_var_type;
class multiple_ret_value;
class multiple_ret_value_ts;
class multiple_ret_expr;

//#ifndef __x86_64__
//#define PREV_OPT
//#endif // __x86_64__

//#define MAINLINE_CACHE
//#define P2C_MEMORY_DEBUG

extern int g_short_mainline;

#define DEBUG_FUNC ""
//#define DEBUG_FUNC "v714651_L10539"
//#define DEBUG_FUNC "HRESULT_FROM_WIN32"

#ifdef P2C_MEMORY_DEBUG
#ifdef _MSC_VER
#ifdef _DEBUG
#include <iostream>
//#include <stdlib.h>
#include <crtdbg.h>

#define _CRTDBG_MAP_ALLOC
#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
#define new DEBUG_NEW

#endif
#endif
#endif

#include <stdio.h>
#include <assert.h>
#include <set>
#include <map>
#include <string>
#include <vector>
#include <list>
#include <queue>
#include <stack>
#include <sstream>
#include <algorithm>
#include <stdarg.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <fstream>

#if defined MULTITHREAD || defined PAR_COMPRESS
#include <pthread.h>
#endif

#include "pillar2c/VarBitmask.h"

//#define COUNT_ALLOCATIONS

#define PSEUDO_NAME "_pillar2c_cpf"
#define PSEUDO_NAME_PTR "_pillar2c_cpf_ptr"

#ifdef COUNT_ALLOCATIONS
std::map<unsigned,unsigned> g_alloc_sites;

#if 0
void * TODD_NEW(unsigned size, const char *f, unsigned l) {
    std::pair<std::map<unsigned,unsigned>::iterator,bool> res = g_alloc_sites.insert(std::pair<unsigned,unsigned>(l,size));
    if(res.second==false) {
        res.first->second += size;
    }
    return rator new(size);
}
#define new(x) TODD_NEW(x, __FILE__, __LINE__)

#else

void* operator new(size_t size, const char* file, int l) {
    std::pair<std::map<unsigned,unsigned>::iterator,bool> res = g_alloc_sites.insert(std::pair<unsigned,unsigned>(l,size));
    if(res.second==false) {
        res.first->second += size;
    }
    return ::operator new(size);
}

#define new new(__FILE__, __LINE__)
#endif

#endif

#define NODE_INFO_LINK
#define CUT_LIKELIHOOD 0.01

#ifndef LEX_CPP
extern "C" int g_pillar2c_debug_level;
extern "C" int column;
#else
extern int g_pillar2c_debug_level;
extern int column;
#endif

enum PHASE {
    FULLFILE = 0,
    CALLGRAPH = 1,
    ONEEDATATIME = 2
};

extern PHASE phase_selector;

extern bool two_phase;
bool g_output_mode = false;
std::string g_output_file_base;
FILE * g_output_file = NULL;
unsigned g_output_file_postfix = 0;
unsigned g_output_cur_line_number = 0;
bool g_prettify_code = true;
bool g_prt_args_in_pseudo = true;
bool g_retain_assign_ref = false;
unsigned g_pseudo_pad=0;
bool g_spill_rare = false;
bool g_output_builtin_expect = false;
bool g_loop_hoists = false;
//bool g_use_new_continuations = false;
bool have_declared_continuation_target = false;
bool g_compile_as_cpp = false;
bool g_use_try_except = true;
bool g_old_continuations = true;
bool g_collect_read_stats = false;
bool g_gcc_compatible = false;
bool g_mic_compatible = false;
bool g_expression_type = false;
unsigned g_num_id_info_created = 0;
unsigned g_num_ast_node_created = 0;
std::set<std::string> g_force_pcdecl;
unsigned g_tailcall_implementation = 1;
bool g_instrument = false;
bool g_instrument_externs_declared = false;
bool g_ref_param_in_pseudo = false;
bool g_gc_at_call;
bool g_verbose = false;
double g_compute_conflict_time = 0.0;
double g_compute_liveness = 0.0;
double g_function_translate = 0.0;
bool g_eliminate_dead_code = false;
bool g_intel64 = false;
bool g_vse_added = false;
bool g_translation_started = false;
bool g_log_m2u = false;
unsigned g_restrict_limit = 4000000000;
bool g_use_restrict_pointer = false;
bool g_check_consistency = false;
int  g_mode = 0;
bool g_check_ref_write_barrier = false;
#ifdef __x86_64__
bool g_use_topo_tailcall = false;
#else
bool g_use_topo_tailcall = true;
#endif
unsigned g_topo_limit = 4000000000;
unsigned g_bypass_limit = 4000000000;
bool g_convert_prtGetTaskHandle = true;
#ifdef NO_P2C_TH
bool g_use_th_param = false;
#else
bool g_use_th_param = true;
#endif
std::string g_first_added_param_name;

class RefCount {
protected:
    unsigned count;
public:
    RefCount(void) : count(0) {}
    void acquire(void) {
        ++count;
    }
    unsigned release(void) {
        return --count;
    }
    unsigned get(void) const {
        return count;
    }
    void * addr(void) const { return (void*)&count; }
};

class id_info;

#define II_PTR

#define RC_IN_ID_INFO

class ii_ptr {
protected:
    id_info *ii;
#ifndef RC_IN_ID_INFO
    RefCount *rc;
#endif
    void release_check(void);
public:
#ifndef RC_IN_ID_INFO
    ii_ptr(void) : ii(NULL) {
        rc = new RefCount();
        rc->acquire();
    }

    ii_ptr(id_info *i) : ii(i) {
        rc = new RefCount();
        rc->acquire();
    }

    ii_ptr(const ii_ptr &o) : ii(o.ii), rc(o.rc) {
        rc->acquire();
    }

    virtual ~ii_ptr(void) {
        if(rc->release() == 0) {
            delete ii;
            delete rc;
        }
    }

    ii_ptr& operator=(const ii_ptr &o) {
        if(this != &o) {
            if(rc->release() == 0) {
                delete ii;
                delete rc;
            }

            ii = o.ii;
            rc = o.rc;
            rc->acquire();
        }
        return *this;
    }
    unsigned get_count(void) {
        assert(0);
    }
#else
    ii_ptr(void);
    ii_ptr(id_info *i);
    ii_ptr(const ii_ptr &o);
    virtual ~ii_ptr(void);
    ii_ptr& operator=(const ii_ptr &o);
//  id_info * get(void);
    static ii_ptr put(id_info *i);
    unsigned get_count(void);
#endif

    id_info& operator*(void) { return *ii; }
    id_info* operator->(void) { return ii; }
    const id_info* operator->(void) const { return ii; }

    operator bool() { return ii != NULL; }

    bool operator==(const ii_ptr &o) const {
        return ii == o.ii;
    }
    bool operator!=(id_info *o) const {
        return ii != o;
    }
    bool operator<(const ii_ptr &o) const {
        return ii < o.ii;
    }

    friend class ii_ptr_release;
};

class ii_ptr_release : public ii_ptr {
public:
#ifndef RC_IN_ID_INFO
    virtual ~ii_ptr_release(void) {
        assert(0);
    }
    ii_ptr_release& operator=(const ii_ptr &o) {
        assert(0);
    }
    id_info * get(void) {
        assert(0);
    }
#else
    virtual ~ii_ptr_release(void);
    ii_ptr_release& operator=(const ii_ptr &o);
#endif
    id_info * get(void);

};

external_declaration *g_pseudo_stack_decl = NULL;
function_definition *unknown_funcs = NULL;
class id_info;
ii_ptr fake_ii = NULL;
std::vector<AST_node*> g_m2u_structs;

unsigned get_num_p2c_added_params(void) {
    if(g_use_th_param) {
        return 2;
    } else {
        return 1;
    }
}

#ifdef __x86_64__
const char *register_size_const = "8";
const unsigned REGISTER_PARAM_SIZE = 8;
#else  // __x86_64__
const char *register_size_const = "4";
const unsigned REGISTER_PARAM_SIZE = 4;
#endif // __x86_64__

typedef struct {
    short active;
    short tag;
    void * id;
} gen_ref_info;

#ifdef MULTITHREAD
pthread_mutex_t g_generic_mutex;
#endif
std::set<unsigned> g_gen_ref_lengths;
std::set<unsigned> g_prt_stub_arg_numbers;
std::map<std::string, ii_ptr > g_ret_type_structs;
std::map<void*,unsigned> g_uniques;
unsigned g_unique_id = 1;

class expression_type;

int g_output_offset = 0;
bool g_oprintf_splitting = false;

void oprintf(const char *format, ...) {
    static bool g_start_of_new_line = true;

    va_list args;
    va_start(args, format);

    if(g_output_mode) {
        std::stringstream new_format;

        size_t format_len = strlen(format);

        unsigned starting_offset = g_output_offset;
        bool time_for_new_line = false;

        bool intra_format_new_line = false;
        unsigned num_open = 0, num_close = 0;

        size_t i;
        for(i = 0; i < format_len; ++i) {
            if(format[i] == '}') {
                g_output_offset -= 4;
                assert(g_output_offset >= 0);
                num_close++;
            }

            if(intra_format_new_line) {
                intra_format_new_line = false;
                int j;
                for(j=0; j < g_output_offset; ++j) {
                    new_format << ' ';
                }
            }

            new_format << format[i];

            if(format[i] == '{') {
                g_output_offset += 4;
                num_open++;
            }

            if(format[i] == '\n') {
                // increment line number
                g_output_cur_line_number++;
                intra_format_new_line = true;

                if(i == format_len-1) {
                    time_for_new_line = true;
                }
            }
        }

        if(num_close > num_open) {
            assert(num_close - 1 == num_open);
            starting_offset -= 4;
        }

        if(g_start_of_new_line) {
            g_start_of_new_line = false;
            unsigned j;
            switch(starting_offset) {
            case 0:
                // intentionally do nothing
                break;
            case 4:
                fprintf(g_output_file,"    ");
                break;
            case 8:
                fprintf(g_output_file,"        ");
                break;
            case 12:
                fprintf(g_output_file,"            ");
                break;
            case 16:
                fprintf(g_output_file,"                ");
                break;
            case 20:
                fprintf(g_output_file,"                    ");
                break;
            case 24:
                fprintf(g_output_file,"                        ");
                break;
            case 28:
                fprintf(g_output_file,"                            ");
                break;
            case 32:
                fprintf(g_output_file,"                                ");
                break;
            case 36:
                fprintf(g_output_file,"                                    ");
                break;
            case 40:
                fprintf(g_output_file,"                                        ");
                break;
            default:
                for(j=0; j < starting_offset; ++j) {
                    fprintf(g_output_file," ");
                }
            }
        }

        vfprintf(g_output_file,new_format.str().c_str(),args);

        if(time_for_new_line) {
            g_start_of_new_line = true;

            if(g_output_cur_line_number > 65500 && !g_oprintf_splitting) {
                if(g_output_file_base != "") {
                    std::stringstream complete_name;
                    complete_name << g_output_file_base << ++g_output_file_postfix << ".c";

                    g_oprintf_splitting = true;
                    oprintf("#include \"%s\"\n",complete_name.str().c_str());
                    fclose(g_output_file);
                    g_output_file = fopen(complete_name.str().c_str(),"w");
                    assert(g_output_file);
                    g_oprintf_splitting = false;
                }
                g_output_cur_line_number = 0;
            }
        }
    } else {
        vprintf(format,args);
    }

    va_end(args);
}

#define aeprintf(...) { \
    printf(__VA_ARGS__); \
    assert(0); \
    exit(-1); }

// -----------------------------------------------------------------------


#if 1
#define check_vector std::vector
#else
std::set<void*> g_cv;
template <class T>
class check_vector : public std::vector<T> {
public:
    check_vector(void) {
        g_cv.insert(this);
    }
    check_vector(const check_vector<T> &other) : std::vector<T>(other) {
        g_cv.insert(this);
    }
    ~check_vector(void) {
        g_cv.erase(this);
    }
    size_type size() const {
        if(g_cv.find((void*)this) == g_cv.end()) {
            aeprintf("Accessing a non-existent check_vector.\n");
        }
        return std::vector<T>::size();
    }
};
#endif

enum no_dfs_state { NO_DFS_WHITE, NO_DFS_GRAY, NO_DFS_BLACK };

class topo_cycle {
public:
    unsigned index_to_save;

    topo_cycle(unsigned u) : index_to_save(u) {}
};

class name_offset {
public:
    std::string name;
    unsigned offset, size, this_index;
    no_dfs_state state;
    std::set<unsigned> interference_edges; // set to prevent duplicates

    name_offset(const std::string &n, unsigned o, unsigned s, unsigned index) : name(n), offset(o), size(s), this_index(index), state(NO_DFS_WHITE) {
        if(offset % REGISTER_PARAM_SIZE != 0) {
            aeprintf("offset to name_offset is not a multiple of 4.\n");
        }
        if(size % REGISTER_PARAM_SIZE != 0) {
            aeprintf("size to name_offset is not a multiple of 4.\n");
        }
    }

    bool dfs_visit(std::vector<name_offset> &graph, std::vector<unsigned> &order) {
        state = NO_DFS_GRAY;

        std::set<unsigned>::iterator edge_iter;
        for(edge_iter  = interference_edges.begin();
            edge_iter != interference_edges.end();
            ++edge_iter) {
            if(graph[*edge_iter].state == NO_DFS_WHITE) {
                if(graph[*edge_iter].dfs_visit(graph,order) == false) {
                    return false; // cycle detected by recursive visit
                }
            } else if(graph[*edge_iter].state == NO_DFS_GRAY) {
                throw topo_cycle(this_index);
            }
        }

        state = NO_DFS_BLACK;
        order.push_back(this_index);
        return true;
    }
};

// Performs a topological sort on the input graph.
// Returns true if a topological sort was possible.
// Returns false if the graph was cyclic and no topological sort was possible.
// On success, returns the topological ordering in "order".
bool name_offset_topological_sort(std::vector<name_offset> &graph, std::vector<unsigned> &order) {
    unsigned i;
    // for each vertex in the graph
    for(i = 0; i < graph.size(); ++i) {
        graph[i].state = NO_DFS_WHITE;
    }

    for(i = 0; i < graph.size(); ++i) {
        // if we haven't visited it yet
        if(graph[i].state == NO_DFS_WHITE) {
            // then visit it....if this visit returns false (i.e., there is a cycle) then return failure.
            if(graph[i].dfs_visit(graph,order) == false) {
                return false;
            }
        }
    }
    return true;
}

unsigned get_name_index(const std::vector<name_offset> &no, const std::string &name) {
    unsigned i;
    for(i = 0; i < no.size(); ++i) {
        if(no[i].name == name) return i;
    }
    aeprintf("Could not find a parameter of name %s.\n",name.c_str());
}

class function_metadata {
public:
    check_vector<parameter_declaration *> m_params;
    bool m_ellipsis;
    bool m_noreturn;

    function_metadata(void) : m_ellipsis(false), m_noreturn(false) {}

    bool has_nonregister_param(void) const;
    bool has_param_of_unknown_size(void) const;
#if 0
    bool has_same_size(const function_metadata &other) const {
        if(has_nonregister_param() || other.has_nonregister_param()) {
            return false;
        }
        return m_params.size() == other.m_params.size();
    }
#endif
    bool get_param_size_and_offsets(unsigned &size, std::vector<name_offset> &offsets);
    void claim_params(void);
};

class call_expression_metadata {
public:
    postfix_expression *m_pe_function;
    check_vector<assignment_expression *> m_args;
    expression_type * m_ret;
    function_metadata m_func_metadata;

    call_expression_metadata(void) :
        m_pe_function(NULL),
        m_ret(NULL) {}

    virtual ~call_expression_metadata(void);

    void print(void);

    postfix_expression * claim_function(void) {
        postfix_expression *ret = m_pe_function;
        m_pe_function = NULL;
        return ret;
    }

    std::vector<std::vector<std::string> > get_arg_identifiers(void);
};


// -----------------------------------------------------------------------

enum symbol_type {
    IIT_FUNCTION,
    IIT_FUNCTION_VAR,
    IIT_TYPEDEF_FUNCTION,
    IIT_STRUCT_ENUM,
    IIT_VAR,
    IIT_TYPEDEF_VAR,
    IIT_PARAM,
    IIT_LABEL,
    IIT_CONTINUATION,
    IIT_ENUM_LABEL,
    IIT_NONE
};

const char * symbol_type_to_str(symbol_type st) {
    switch(st) {
    case IIT_FUNCTION:
        return "IIT_FUNCTION";
    case IIT_FUNCTION_VAR:
        return "IIT_FUNCTION_VAR";
    case IIT_TYPEDEF_FUNCTION:
        return "IIT_TYPEDEF_FUNCTION";
    case IIT_STRUCT_ENUM:
        return "IIT_STRUCT_ENUM";
    case IIT_VAR:
        return "IIT_VAR";
    case IIT_TYPEDEF_VAR:
        return "IIT_TYPEDEF_VAR";
    case IIT_PARAM:
        return "IIT_PARAM";
    case IIT_LABEL:
        return "IIT_LABEL";
    case IIT_CONTINUATION:
        return "IIT_CONTINUATION";
    case IIT_ENUM_LABEL:
        return "IIT_ENUM_LABEL";
    case IIT_NONE:
        return "IIT_NONE";
    default:
        aeprintf("Unknown symbol type %d.\n",st);
        return NULL;
    }
}

enum PILLAR2C_CALLCONV {
   ST_NOT_DEFINED,
   ST_CDECL,
   ST_STDCALL,
   ST_PDECL,
   ST_PCDECL
};

extern std::stack<PILLAR2C_CALLCONV> g_cc_stack;

enum MAN_UNMAN {
   MU_MANAGED,
   MU_UNMANAGED
};

MAN_UNMAN cc_to_man_unman(PILLAR2C_CALLCONV cc) {
    switch(cc) {
    case ST_NOT_DEFINED:
        aeprintf("cc_to_man_unman\n");
        break;
    case ST_CDECL:
        return MU_UNMANAGED;
    case ST_STDCALL:
        return MU_UNMANAGED;
    case ST_PDECL:
        return MU_MANAGED;
    case ST_PCDECL:
        return MU_MANAGED;
    default:
        aeprintf("Unknown calling convention type %d.\n",cc);
        return MU_MANAGED;
    }
}

const char * cc_to_str(PILLAR2C_CALLCONV cc) {
    switch(cc) {
    case ST_NOT_DEFINED:
        return "ST_NOT_DEFINED";
    case ST_CDECL:
        return "CDECL";
    case ST_STDCALL:
        return "STDCALL";
    case ST_PDECL:
        return "PDECL";
    case ST_PCDECL:
        return "PCDECL";
    default:
        aeprintf("Unknown calling convention type %d.\n",cc);
        return NULL;
    }
}

class Scope;
class basic_block;

#define DISALLOW_TYPE_REDEFINITION

unsigned num_ii = 0;
unsigned size_ii = 0;
std::set<id_info *> g_iis;

class id_info {
protected:
#if 1
    bool m_function : 1,
         m_var : 1,
         m_typedef : 1,
         m_struct_enum_tag : 1,
         m_struct_defined : 1,
         m_param : 1,
         m_label : 1,
         m_function_var : 1,
         m_address_taken : 1,
         m_continuation : 1,
         m_type_owned : 1,
         m_make_volatile : 1,
         m_enum_label : 1,
         m_ref_param_in_place : 1,
         m_volatile_added : 1;

#else
    bool m_function;
    bool m_var;
    bool m_typedef;
    bool m_struct_enum_tag;
    bool m_struct_defined;
    bool m_param;
    bool m_label;
    bool m_function_var;
    bool m_address_taken;
    bool m_continuation;
    bool m_type_owned;
    bool m_make_volatile;
    bool m_enum_label;
    bool m_ref_param_in_place;
#endif
    std::string m_id;
    PILLAR2C_CALLCONV m_cc;
    Scope *m_scope;
    union {
        type_specifier *m_type; // only used for m_var and m_param
        labeled_statement_identifier *m_lsi;
    } type_or_lsi;

#ifdef SINGLE_DECLARATOR
    declarator *m_d;
#else
    std::list<declarator *> m_d;
#endif
    parameter_declaration *m_param_decl;
    std::string m_ref_field_name;
    std::string m_qualified_ref_field_name;
    function_definition *m_fd;
    direct_declarator *m_func_decl;
    Scope *m_struct_scope;
    basic_block *m_block_for_label;
    unsigned m_ref_index;
    unsigned m_var_index;

    void move_label_to_function_scope(void);

    friend class ii_ptr;
    friend class ii_ptr_release;
#ifdef RC_IN_ID_INFO
    RefCount *rc;
#endif
public:
    id_info(char *id, symbol_type iit, Scope *scope) {
        ::id_info(std::string(id),iit,scope);
    }

    id_info(std::string id, symbol_type iit, Scope *scope) :
        m_function(false),
        m_var(false),
        m_typedef(false),
        m_struct_enum_tag(false),
        m_struct_defined(false),
        m_param(false),
        m_label(false),
        m_function_var(false),
        m_address_taken(false),
        m_continuation(false),
        m_type_owned(false),
        m_make_volatile(false),
        m_enum_label(false),
        m_ref_param_in_place(false),
        m_volatile_added(false),
        m_id(id),
        m_cc(ST_NOT_DEFINED),
        m_scope(scope),
  //      m_d(NULL),
        m_param_decl(NULL),
        m_fd(NULL),
        m_func_decl(NULL),
        m_struct_scope(NULL),
        m_block_for_label(NULL),
        m_ref_index((unsigned)-1),
        m_var_index((unsigned)-1)
#ifdef RC_IN_ID_INFO
        , rc(NULL)
#endif
        {

        if(two_phase) {
            ++num_ii;
            size_ii += sizeof(*this);
            g_iis.insert(this);
        }

        if(id == DEBUG_FUNC) {
            printf("Creating symbol %s\n",DEBUG_FUNC);
        }

        type_or_lsi.m_type = NULL;

        if(g_pillar2c_debug_level > 1) {
            printf("//id_info::id_info (%s, %s)\n",id.c_str(), symbol_type_to_str(iit));
        }

        switch(iit) {
        case IIT_FUNCTION:
            m_function = true;
            break;
        case IIT_FUNCTION_VAR:
            m_function_var = true;
            break;
        case IIT_TYPEDEF_FUNCTION:
            m_function = true;
            m_typedef = true;
            break;
        case IIT_STRUCT_ENUM:
            m_struct_enum_tag = true;
            break;
        case IIT_VAR:
            m_var = true;
            break;
        case IIT_TYPEDEF_VAR:
            m_typedef = true;
            m_var = true;
            break;
        case IIT_NONE:
            break;
        case IIT_PARAM:
            m_param = true;
            break;
        case IIT_LABEL:
            m_label = true;
            move_label_to_function_scope();
            break;
        case IIT_CONTINUATION:
            m_continuation = true;
            break;
        case IIT_ENUM_LABEL:
            m_enum_label = true;
            break;
        default:
            aeprintf("Unrecognized symbol type.\n");
        }

        ++g_num_id_info_created;
    }

    ~id_info(void);

    function_definition * get_func_definition(void) {
        return m_fd;
    }

    direct_declarator * get_func_decl(void) {
        return m_func_decl;
    }

    void add_volatile(void) {
        m_volatile_added = true;
    }

    bool volatile_added(void) const {
        return m_volatile_added;
    }

    expression_type * get_return_type(void);

    void set_func_definition(function_definition *fd);
    void set_func_decl(direct_declarator *decl);

    void get_func_metadata(call_expression_metadata &cem);

    Scope * get_scope(void) const {
        return m_scope;
    }

    void set_scope(Scope *scope) {
        m_scope = scope;
    }

    PILLAR2C_CALLCONV get_function_cc(void);

    void print(void);

    void set_function_cc(PILLAR2C_CALLCONV cc) {
        //assert(m_function || m_function_var);
        if(g_force_pcdecl.find(m_id) != g_force_pcdecl.end()) {
            m_cc = ST_PCDECL;
            return;
        }
        if(m_cc == ST_NOT_DEFINED) {
            m_cc = cc;
        } else {
            if(m_cc != cc) {
                printf("Attempt to redefine calling convention of function %s from %s to %s.\n",m_id.c_str(),cc_to_str(m_cc),cc_to_str(cc));
                assert(0);
            }
        }
        if(g_pillar2c_debug_level > 1) {
            printf("//%p Function %s calling convention is %s.\n",this,m_id.c_str(),cc_to_str(cc));
        }
    }

    bool add(symbol_type iit) {
        if(g_pillar2c_debug_level > 1) {
            printf("//%p id_info.add (%s, %s)\n",this,m_id.c_str(),symbol_type_to_str(iit));
        }

        switch(iit) {
        case IIT_FUNCTION:
#ifdef DISALLOW_TYPE_REDEFINITION
            if(m_var) {
                if(g_pillar2c_debug_level > 1) {
                    print();
                }
                return true;
            }
#endif
            m_function = true;
#ifdef DISALLOW_TYPE_REDEFINITION
            m_typedef = false;
            m_var = false;
#endif
            break;
        case IIT_FUNCTION_VAR:
            m_function_var = true;
            break;
        case IIT_TYPEDEF_FUNCTION:
#ifdef DISALLOW_TYPE_REDEFINITION
            if(m_var) {
                if(g_pillar2c_debug_level > 1) {
                    print();
                }
                return true;
            }
#endif
            m_function = true;
            m_typedef = true;
#ifdef DISALLOW_TYPE_REDEFINITION
            m_var = false;
            m_struct_enum_tag = false;
#endif
            break;
        case IIT_STRUCT_ENUM:
//            if(m_struct_enum_tag) return true;
            m_struct_enum_tag = true;
            break;
        case IIT_VAR:
#ifdef DISALLOW_TYPE_REDEFINITION
            if(m_function) {
                if(g_pillar2c_debug_level > 1) {
                    print();
                }
                return true;
            }
            m_function = false;
            m_typedef = false;
#endif
            m_var = true;
            break;
        case IIT_TYPEDEF_VAR:
#ifdef DISALLOW_TYPE_REDEFINITION
            if(m_function) {
                if(g_pillar2c_debug_level > 1) {
                    print();
                }
                return true;
            }
            m_function = false;
#endif
            m_typedef = true;
            m_var = true;
            break;
        case IIT_PARAM:
#ifdef DISALLOW_TYPE_REDEFINITION
            if(m_var) {
                if(g_pillar2c_debug_level > 1) {
                    print();
                }
                return true;
            }
#endif
            m_param = true;
            break;
        case IIT_LABEL:
            m_label = true;
            move_label_to_function_scope();
            break;
        case IIT_CONTINUATION:
            m_continuation = true;
            break;
        case IIT_ENUM_LABEL:
            m_enum_label = true;
            break;
        case IIT_NONE:
            assert(0);
        }
        return false;
    }

    bool is_function(void) const { return m_function; }
    bool is_function_var(void) const { return m_function_var; }
    bool is_typedef(void) const { return m_typedef; }
    bool is_struct_enum(void) const { return m_struct_enum_tag; }
    bool is_var(void) const { return m_var; }
    bool is_param(void) const { return m_param; }
    bool is_label(void) const { return m_label; }
    bool is_continuation(void) const { return m_continuation; }
    bool is_enum_label(void) const { return m_enum_label; }
    const char * get_name(void) const { return m_id.c_str(); }
    std::string get_string(void) const { return m_id; }
    std::string get_continuation_var_string(void) const;
    std::string get_continuation_label_string(void) const {
        return "_pillar2c_continuation_" + m_id;
    }
    std::string get_continuation_type_string(void) const;

    void make_volatile(void) {
        m_make_volatile = true;
    }
    bool is_volatile(void) const { return m_make_volatile; }

    bool is_struct_defined(void) const { return m_struct_defined; }
    bool define_struct(void) {
//        printf("define_struct (%s) %d\n",m_id.c_str());
        if(m_struct_defined) return false;
        m_struct_defined = true;
        return true;
    }

    void set_type(type_specifier *ts, bool type_owned=false);

    type_specifier * get_type(void) const;

    void set_labeled_statement(labeled_statement_identifier *lsi);

    labeled_statement_identifier * get_labeled_statement(void) const {
        assert(m_label);
        return type_or_lsi.m_lsi;
    }

    void set_declarator(declarator *d);

#ifdef SINGLE_DECLARATOR
    declarator * get_declarator(void) {
        return m_d;
    }
#else
    std::list<declarator *> get_declarator(void) {
        return m_d;
    }
    declarator * get_first_declarator(void) {
        if(m_d.size() == 0) return NULL;
        return m_d.front();
    }
    declarator * get_last_declarator(void) {
        if(m_d.size() == 0) return NULL;
        return m_d.back();
    }
#endif

    void set_parameter_declaration(parameter_declaration *pd);

    parameter_declaration * get_parameter_declaration(void) {
        assert(m_param);
        return m_param_decl;
    }

    const char * get_ref_field_name(void) const {
        if(m_ref_field_name == "") return NULL;
        else                       return m_ref_field_name.c_str();
    }

    void set_ref_field_name(const std::string &s) {
        m_ref_field_name = s;
    }

    const char * get_qualified_ref_field_name(void) const {
        if(m_qualified_ref_field_name == "") {
            return get_ref_field_name();
        } else {
            return m_qualified_ref_field_name.c_str();
        }
    }

    void set_qualified_ref_field_name(const std::string &s) {
        m_qualified_ref_field_name = s;
    }


    void set_struct_scope(Scope *struct_scope) {
        m_struct_scope = struct_scope;
    }

    Scope * get_struct_scope(void) {
        return m_struct_scope;
    }

    type_specifier * get_base_type(void);
    bool is_ultimate_prt_ref(void);
    type_specifier_PRT_REF * get_ultimate_prt_ref(void);

    void set_block_for_label(basic_block *bb) {
        assert(m_label);
        m_block_for_label = bb;
    }

    basic_block * get_block_for_label(void) {
        assert(m_label);
        return m_block_for_label;
    }

    void set_block_for_continuation(basic_block *bb) {
        assert(m_continuation);
        m_block_for_label = bb;
    }

    basic_block * get_block_for_continuation(void) {
        assert(m_continuation);
        return m_block_for_label;
    }

    bool has_ref_index(void) const {
        return m_ref_index != (unsigned)-1;
    }

    void set_ref_index(unsigned index) {
        m_ref_index = index;
    }

    void set_ref_param_in_place(void) {
        m_ref_param_in_place = true;
    }

    bool get_ref_param_in_place(void) const {
        return m_ref_param_in_place;
    }

    unsigned get_ref_index(void) const {
        return m_ref_index;
    }

    void set_address_taken(void) {
//        assert(has_ref_index());
        m_address_taken = true;
    }

    bool get_address_taken(void) const {
        return m_address_taken;
    }

    bool has_var_index(void) const {
        return m_var_index != (unsigned)-1;
    }

    void set_var_index(unsigned index) {
        m_var_index = index;
    }

    unsigned get_var_index(void) const {
        return m_var_index;
    }

    virtual unsigned get_minimum_size(void);
    virtual unsigned get_param_size(void);
    virtual void delete_it(void);

public:
    check_vector<type_name *> m_mrv_vec;

    void replace(AST_node *old_node,AST_node *new_node);
}; // class id_info

#ifdef RC_IN_ID_INFO
ii_ptr::ii_ptr(void) : ii(NULL) {
}

ii_ptr::ii_ptr(id_info *i) : ii(i) {
    if(ii) {
        if(!ii->rc) {
            ii->rc = new RefCount();
//          printf("RC %p, %p-%p for %s\n",ii->rc->addr(),ii,((char*)ii)+sizeof(id_info),i->get_name());
            if(i->get_string() == DEBUG_FUNC) {
                printf("Creating refcount for %s\n",DEBUG_FUNC);
            }
        }
        ii->rc->acquire();
    }
}

ii_ptr::ii_ptr(const ii_ptr &o) : ii(o.ii) {
    if(ii) {
        assert(ii->rc);
        ii->rc->acquire();
    }
}

void ii_ptr::release_check(void) {
    static unsigned count = 0;
    if(ii && ii->rc->release() == 0) {
        if(count >= 0) {
            delete ii->rc;
            delete ii;
            ++count;
        }
    }
}

ii_ptr::~ii_ptr(void) {
    release_check();
}

ii_ptr_release::~ii_ptr_release(void) {
    assert(!ii);
}

ii_ptr& ii_ptr::operator=(const ii_ptr &o) {
    if(this != &o) {
        release_check();

        ii = o.ii;
        if(ii) {
            assert(ii->rc);
            ii->rc->acquire();
        }
    }
    return *this;
}

ii_ptr_release& ii_ptr_release::operator=(const ii_ptr &o) {
    assert(!ii);

    ii = o.ii;
    assert(ii);
    ii->rc->acquire();
    return *this;
}

id_info * ii_ptr_release::get(void) {
    assert(ii);
    id_info *ret = ii;
    assert(ii->rc);
    ii->rc->release();
    ii = NULL;
    return ret;
}

#if 0
id_info * ii_ptr::get (void) {
    return ii;
}
#endif

ii_ptr ii_ptr::put(id_info *i) {
    ii_ptr ret;
    ret.ii = i;
    return ret;
}

unsigned ii_ptr::get_count(void) {
    if(ii) {
        assert(ii->rc);
        return ii->rc->get();
    } else {
        return 0;
    }
}
#endif

// -----------------------------------------------------------------------

std::list<Scope *> g_all_scopes;

unsigned scope_data = 0;

typedef std::map<std::string,ii_ptr> map_str_ii;

class Scope : protected map_str_ii {
protected:
    Scope *m_parent_scope;
#ifdef VECTOR_CHILD_SCOPE
    check_vector<Scope *> m_child_scopes;
    typedef std::vector<Scope *>::iterator scope_iterator;
#else
    std::set<Scope *> m_child_scopes;
    typedef std::set<Scope *>::iterator scope_iterator;
#endif
    bool m_function_scope;

    void add_child_scope(Scope *scope) {
#ifdef VECTOR_CHILD_SCOPE
        m_child_scopes.push_back(scope);
#else
        m_child_scopes.insert(scope);
#endif
    }

    void indent_it(unsigned indent) {
        unsigned i;
        for(i=0;i<indent;++i) printf(" ");
    }
    unsigned m_unique;
public:
    //size_type map_str_ii::_Mybase::size() const;
    //map_str_ii::end();
    //std::_Tree<_Tmap_traits>::begin();

    map_str_ii::size_type size(void) const {
        return map_str_ii::size();
    }
    map_str_ii::iterator begin(void) {
        return map_str_ii::begin();
    }
    map_str_ii::iterator end(void) {
        return map_str_ii::end();
    }
    void erase(const std::string &s) {
        if(s == DEBUG_FUNC) {
            printf("Removing %s from scope\n",DEBUG_FUNC);
        }
        map_str_ii::erase(s);
    }

    bool remove_child_scope(Scope *s) {
#ifdef VECTOR_CHILD_SCOPE
        aeprintf("remove_child_scope not supported in vector mode yet.\n");
#else
        return m_child_scopes.erase(s) == 1;
#endif
    }

    void add_children_to_queue(std::queue<Scope *> &flatten) {
        scope_iterator si;
        for(si  = m_child_scopes.begin();
            si != m_child_scopes.end();
          ++si) {
            flatten.push(*si);
        }
    }

    Scope(Scope *parent_scope) : m_parent_scope(parent_scope), m_function_scope(false) {
        if(m_parent_scope) {
            m_parent_scope->add_child_scope(this);
        }
        g_all_scopes.push_back(this);

        m_unique = g_unique_id++;
        scope_data += sizeof(Scope);
    }

    virtual ~Scope(void) {
        while(m_child_scopes.size()) {
            delete *(m_child_scopes.begin());
        }
        m_child_scopes.clear();

        map_str_ii::iterator del_iter;
        while(size()) {
            del_iter = begin();
            assert(del_iter->second->get_scope() == this);
            del_iter->second->set_scope(NULL);
//          printf("Deleting symbol %s\n",del_iter->first.c_str());
            map_str_ii::erase(begin());
        }
#ifndef II_PTR
        for(del_iter  = begin();
            del_iter != end();
          ++del_iter) {
            delete del_iter->second;
        }
#endif
        scope_data -= sizeof(Scope);
        if(m_parent_scope) {
            bool res = m_parent_scope->remove_child_scope(this);
            assert(res);
        }
    }

    void clear(void) {
        scope_iterator si;
        while(m_child_scopes.size()) {
            delete *(m_child_scopes.begin());
        }
        m_child_scopes.clear();
//      map_str_ii::clear();
        map_str_ii::iterator del_iter;
        while(size()) {
            del_iter = begin();
            del_iter->second->set_scope(NULL);
//          printf("Deleting symbol %s\n",del_iter->first.c_str());
            map_str_ii::erase(begin());
        }
    }

    void stats(unsigned &num_scopes, unsigned &num_items, unsigned &num_kept_alive) {
        scope_iterator si;
        for(si  = m_child_scopes.begin();
            si != m_child_scopes.end();
          ++si) {
            ++num_scopes;
            (*si)->stats(num_scopes, num_items, num_kept_alive);
        }
        num_items += size();

        map_str_ii::iterator iter;
        for(iter  = begin();
            iter != end();
          ++iter) {
            if((*iter).second.get_count() == 1) {
                ++num_kept_alive;
            }
        }
    }

    ii_ptr  find_symbol(const std::string &s) {
        map_str_ii::iterator iter;
        iter = find(s);
        if(iter == end()) {
            return NULL;
        } else {
            return iter->second;
        }
    }

    ii_ptr  add_symbol(const std::string &s, symbol_type st) {
        if(st == IIT_LABEL) {
            assert(m_function_scope);
        }
        ii_ptr res = new id_info(s, st, this);
        std::pair<map_str_ii::iterator,bool> ires = insert(std::pair<std::string,ii_ptr>(s,res));
        if(s == DEBUG_FUNC) {
            printf("Adding %s to scope\n",DEBUG_FUNC);
        }
        if(!ires.second) {
            aeprintf("Duplicate symbol %s inserted into scope.\n",s.c_str());
        }
        return res;
    }

    void add_symbol(ii_ptr ii) {
        ii->set_scope(this);
        std::pair<map_str_ii::iterator,bool> ires = insert(std::pair<std::string,ii_ptr>(ii->get_string(),ii));
        if(!ires.second) {
            aeprintf("Duplicate symbol %s inserted into scope.\n",ii->get_name());
        }
    }

    void remove_symbol(ii_ptr ii) {
        erase(ii->get_string());
    }

    void merge(Scope &scope_to_empty) {
        do {
            map_str_ii::iterator iter;
            iter = scope_to_empty.begin();
            insert(*iter);
            scope_to_empty.map_str_ii::erase(iter);
        } while (!scope_to_empty.empty());
    }

    void print(int indent=0) {
        indent_it(indent);

        printf("Scope %p , Parent %p, Num Children %d\n",this,m_parent_scope,m_child_scopes.size());
        map_str_ii::iterator miter;
        for(miter  = begin();
            miter != end();
            miter++) {
            indent_it(indent+4);
            miter->second->print();
        }
        scope_iterator si;
        for(si = m_child_scopes.begin();
            si != m_child_scopes.end();
          ++si) {
            (*si)->print(indent+4);
        }
    }

#if 0
#ifdef VECTOR_CHILD_SCOPE
    check_vector<Scope *> get_child_scopes(void) {
        return m_child_scopes;
    }
#else
    std::set<Scope *> get_child_scopes(void) {
        return m_child_scopes;
    }
#endif
#endif

    void set_function(void) {
        m_function_scope = true;
    }

    bool is_function(void) {
        return m_function_scope;
    }

    Scope * get_parent_scope(void) const {
        return m_parent_scope;
    }

    virtual std::string get_unique(void) {
        std::stringstream ss;
        ss << m_unique;
        return ss.str();
    }
};

class ScopeStack {
protected:
    check_vector<Scope *> m_scope_stack;
    unsigned m_stack_depth;
public:
    ScopeStack(void) {
        Scope *global_scope = new Scope(NULL);
        m_scope_stack.push_back(global_scope);
        m_stack_depth = 1;
    }

    void stats(void) {
        printf("%d scopes in scope stack.\n", m_scope_stack.size());
        unsigned num_scopes = 0, num_items = 0, num_kept_alive = 0;
        unsigned i;
        for(i = 0; i < m_scope_stack.size(); ++i) {
            ++num_scopes;
            m_scope_stack[i]->stats(num_scopes, num_items, num_kept_alive);
        }
        printf("NumScopes: %d, TotalItems: %d, KeptAlive: %d\n", num_scopes, num_items, num_kept_alive);
    }

    void clear(void) {
        if(m_scope_stack.size() != 1) {
            printf("Error clearing ScopeStack\n");
            exit(-1);
        }
        m_scope_stack[0]->clear();
    }

    void target_helper(Scope *one_scope) {
        if(one_scope->get_parent_scope() != NULL) {
            target_helper(one_scope->get_parent_scope());
        }
        m_scope_stack.push_back(one_scope);
        ++m_stack_depth;
    }

    // Create a scope stack as it was when target was created.
    ScopeStack(ii_ptr target) {
        m_stack_depth = 0;
        target_helper(target->get_scope());
    }

    virtual ~ScopeStack(void) {
    }

    ii_ptr  find_symbol(const std::string &s) {
        unsigned i;
        for(i = m_stack_depth; i > 0; --i) {
            ii_ptr ii = m_scope_stack[i-1]->find_symbol(s);
            if(ii) return ii;
        }
        return NULL;
    }

    ii_ptr  find_symbol_top(const std::string &s) {
        ii_ptr ii = m_scope_stack[m_stack_depth-1]->find_symbol(s);
        if(ii) return ii;
        return NULL;
    }

    ii_ptr  find_symbol_bottom(const std::string &s) {
        ii_ptr ii = m_scope_stack[0]->find_symbol(s);
        if(ii) return ii;
        return NULL;
    }

    ii_ptr  add_symbol(const std::string &s, symbol_type st) {
        ii_ptr ii = NULL;
        if(st == IIT_LABEL) {
            unsigned i;
            for(i = m_stack_depth; i > 0; --i) {
                if(m_scope_stack[i-1]->is_function()) {
                    ii = m_scope_stack[i-1]->add_symbol(s, st);
                    if(ii) return ii;
                }
            }
            assert(0);
        } else {
            ii = m_scope_stack[m_stack_depth-1]->add_symbol(s, st);
        }
        assert(ii);
        return ii;
    }

    ii_ptr  add_symbol_bottom(const std::string &s, symbol_type st) {
        ii_ptr ii = NULL;
        if(st == IIT_LABEL) {
            aeprintf("Should not happen.\n");
        } else {
            ii = m_scope_stack[0]->add_symbol(s, st);
        }
        assert(ii);
        return ii;
    }

    void add_symbol_bottom(ii_ptr ii) {
        m_scope_stack[0]->add_symbol(ii);
    }

    Scope * enter_scope(void) {
        Scope *new_scope = new Scope(m_scope_stack[m_stack_depth-1]);
        m_scope_stack.push_back(new_scope);
        m_stack_depth++;

        if(g_pillar2c_debug_level > 1) {
            printf("Entering scope %p, depth = %d\n",new_scope,m_stack_depth-1);
        }
        return new_scope;
    }

    Scope * reenter_scope(Scope *old_scope, bool is_function_scope=false) {
        if(!old_scope) {
            Scope *new_scope = enter_scope();
            if(is_function_scope) {
                new_scope->set_function();
            }
            return new_scope;
        }

        m_scope_stack.push_back(old_scope);
        m_stack_depth++;
        if(is_function_scope) {
            old_scope->set_function();
        }

        if(g_pillar2c_debug_level > 1) {
            printf("Reentering scope %p, depth = %d\n",old_scope,m_stack_depth-1);
        }
        return old_scope;
    }

    Scope * leave_scope(void) {
        Scope * ret = m_scope_stack[m_stack_depth-1];
        m_stack_depth--;
        m_scope_stack.pop_back();

        if(g_pillar2c_debug_level > 1) {
            printf("Leaving scope %p, depth = %d\n",ret,m_stack_depth);
        }

        return ret;
    }

    Scope * get_current_scope(void) {
        assert(m_stack_depth);
        return m_scope_stack[m_stack_depth-1];
    }

    bool in_current_scope(ii_ptr ii) {
        if(ii->get_scope() == get_current_scope()) return true;
        else                                       return false;
    }

    bool in_top_scope(ii_ptr ii) {
        if(ii->get_scope() == m_scope_stack[0]) return true;
        else                                    return false;
    }

    ii_ptr  find_or_add(const std::string &s, symbol_type st = IIT_NONE) {
        ii_ptr ii = find_symbol(s);
        if(!ii) {
            ii = add_symbol(s, st);
        }
        return ii;
    }

    ii_ptr  find_or_add(const char *id, symbol_type st = IIT_NONE) {
        return find_or_add(std::string(id), st);
    }


    ii_ptr  find_or_add_top_level(const std::string &s, symbol_type st = IIT_NONE) {
        ii_ptr ii = find_symbol_bottom(s);
        if(!ii) {
            ii = add_symbol_bottom(s, st);
        }
        return ii;
    }

    ii_ptr  find_or_add_top_level(const char *id, symbol_type st = IIT_NONE) {
        return find_or_add_top_level(std::string(id), st);
    }
};

ScopeStack g_scope_stack;

class ScopeStackTarget {
protected:
    ScopeStack m_cache;
public:
    ScopeStackTarget(ii_ptr target) {
        m_cache = g_scope_stack;

        ScopeStack temp_stack(target);
        g_scope_stack = temp_stack;
    }

    ~ScopeStackTarget(void) {
        g_scope_stack = m_cache;
    }
};

// -----------------------------------------------------------------------

bool g_gen_prolog_yields = true;
bool g_gen_backward_yields = true;

//std::map<std::string,id_info*> g_type_table;

PILLAR2C_CALLCONV cc_without_managed(PILLAR2C_CALLCONV cc) {
    switch(cc) {
    case ST_NOT_DEFINED:
        return ST_NOT_DEFINED;
    case ST_CDECL:
        return ST_CDECL;
    case ST_STDCALL:
        return ST_STDCALL;
    case ST_PDECL:
        return ST_STDCALL;
    case ST_PCDECL:
        return ST_CDECL;
    default:
        aeprintf("Unknown calling convention type %d.\n",cc);
        return ST_NOT_DEFINED;
    }
}

PILLAR2C_CALLCONV fix_cc_default(PILLAR2C_CALLCONV cc) {
    if(cc == ST_NOT_DEFINED) {
        return g_cc_stack.top();
    } else {
        return cc;
    }
}

parameter_list * gen_extra_params(void);

//==========================================================================

typedef enum {
    PILLAR_RUNTIME_FUNC_NORMAL = 0,
    PILLAR_RUNTIME_FUNC_NO_DIRECT_CALL = 1
} PILLAR_RUNTIME_FUNC_TYPE;

std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE> g_pillar_runtime_funcs;

// -----------------------------------------------------------------------

class decl_init_wrapper {
protected:
    declarator *m_d;
    unsigned    m_index;
    designation *m_designation;
public:
    decl_init_wrapper(declarator *d) : m_d(d), m_index(0), m_designation(NULL) {}

    virtual void next_index(void) {
        ++m_index;
    }

    virtual postfix_expression * gen_postfix_expression(void);
    virtual unary_expression * gen_unary_expression(void);

    virtual void set_designation(designation *d) {
        if(m_designation) {
            assert(d == NULL);
        }
        m_designation = d;
    }
};

// -----------------------------------------------------------------------

#include <typeinfo>
#include <memory>

using std::auto_ptr;

class expression_type {
public:
    specifier_qualifier_list *m_sql;
    abstract_declarator      *m_ad;

    expression_type(void) : m_sql(NULL), m_ad(NULL) {}
    virtual ~expression_type();

//    expression_type(expression_type &other) : m_sql(other.m_sql), m_ad(other.m_ad) {}
//    expression_type(expression_type other) : m_sql(other.m_sql), m_ad(other.m_ad) {}

    expression_type(const expression_type &other);

    virtual bool is_struct(Scope *&struct_scope);
    virtual bool operator==(const expression_type &other);
    virtual bool is_void(void);
    virtual bool is_void_pointer(void);
    virtual bool is_pointer(void);
    void print(void);
    // is this exactly of type "float"
    virtual bool is_float(void);
    // is this something floating point type...could be float or double
    virtual bool is_float_type(void);
    virtual bool is_int_type(void);
    virtual expression_type * get_base_type(void);
    virtual unsigned get_minimum_size(void);
    virtual unsigned get_param_size(void);
    virtual expression_type * clone(void);
    virtual bool is_ultimate_prt_ref(void);
    virtual type_name * gen_type_name(type_qualifier *tq);
    virtual declaration * gen_declaration_init(const std::string &name,assignment_expression *owned_ae);
    virtual void add_pointer_star(void);
    virtual void remove_volatile(void);
};

expression_type * determine_type_numeric_binary_operation(auto_ptr<expression_type> a,auto_ptr<expression_type> b);

class TranslateResult {
public:
    mutable std::auto_ptr<expression_type> m_et;
    bool m_once_ref;

    TranslateResult(void) : m_et(NULL), m_once_ref(false) {}
    explicit TranslateResult(auto_ptr<expression_type> et);

    TranslateResult(const TranslateResult &other) {
        m_et = other.m_et;
        m_once_ref = other.m_once_ref;
    }

    TranslateResult & operator=(const TranslateResult &other) {
        m_et = other.m_et;
        m_once_ref = other.m_once_ref;
        return *this;
    }
};

#ifdef MAINLINE_CACHE
#define MAINLINE_CACHE_CODE \
    static void * operator new(size_t s) { \
        if(saved) { \
            void *ret = saved; \
            saved = NULL; \
            memset(ret,0,s); \
            return ret; \
        } else { \
            void *ret = malloc(s); \
            return ret; \
        } \
    } \
    \
    static void operator delete(void *d) { \
        if(saved) { \
            free(d); \
        } else { \
            saved = d; \
        } \
    }
#else
#define MAINLINE_CACHE_CODE
#endif // MAINLINE_CACHE

bool ref_debug = false;

#define LR_NOT_FOUND 0
#define LVALUE 1
#define RVALUE 2
#define RARE_RVALUE 3

typedef enum {
    LRB_LVALUE  = 0,
    LRB_RVALUE  = 1,
    LRB_LRVALUE = 2   // yeah..it's weird but we treat &ref in a parameter list like a LR value and for things like x += 7;
} LRB_VALUE;

class AST_node {
protected:
    AST_node *m_parent;
    Scope    *m_scope;
    ii_ptr    m_ii; // if an id_info references this node
public:
    AST_node(void) : m_parent(NULL), m_scope(NULL), m_ii(NULL) {
        ++g_num_ast_node_created;
    }
    virtual ~AST_node(void) {
        --g_num_ast_node_created;
#ifndef II_PTR
        if(m_ii) {
            delete m_ii;
        }
#endif
    }

    void set_parent(AST_node *parent) {
#ifdef AUTO_REPLACE_IN_PARENT
        if(m_parent) {
            m_parent->replace(this,NULL);
        }
#endif
        m_parent = parent;
    }

    AST_node * get_parent(void) const {
        return m_parent;
    }

    ii_ptr  get_ii(void) {
        return m_ii;
    }

    void set_ii(ii_ptr ii) {
        m_ii = ii;
    }

    virtual PILLAR2C_CALLCONV fix_cc_default(PILLAR2C_CALLCONV cc) const;

    virtual void clone_copy(const AST_node *other) {
        m_scope          = other->m_scope;
    }

    virtual void print(void) const = 0;
    virtual const char * get_node_type(void) const { return ""; }
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;

    virtual void set_scope(Scope *s) {
        m_scope = s;
    }
    virtual Scope * get_scope(void) {
        return m_scope;
    }

    virtual function_definition * find_enclosing_function(void) const;
    virtual unsigned get_line_number(void) const;

    // Get the nearest encompassing symbol
    virtual std::list<ii_ptr > get_enclosing_symbols(void);

    virtual AST_node **begin_child_iter(void) const {
        return NULL;
    }
    virtual AST_node **next_child_iter(AST_node **cur) const {
        return NULL;
    }
    virtual unsigned get_num_children(void) const {
        return 0;
    }

    virtual void replace(AST_node *old_node,AST_node *new_node) {
        AST_node **child = begin_child_iter();
        while(child) {
            if(*child == old_node) {
                *child = new_node;
                if(new_node) {
                    new_node->set_parent(this);
                }
                ii_ptr ii;
                if((ii = old_node->get_ii())) {
                    new_node->set_ii(ii);
                    old_node->set_ii(NULL);
                    ii->replace(old_node,new_node);
                }
                return;
            }
            child = next_child_iter(child);
        }

        aeprintf("AST_node::replace couldn't find matching old_node for this type %s and old_node = %s, new_node = %s.\n",typeid(this).name(),typeid(old_node).name(),typeid(new_node).name());
    }

    virtual void insert_before_top_level(external_declaration *ed) {
        if(m_parent) {
            m_parent->insert_before_top_level(ed);
        } else {
            aeprintf("insert_before_top_level.\n");
        }
    }

    virtual void insert_before_top_level(std::list<external_declaration *> &ed) {
        if(m_parent) {
            m_parent->insert_before_top_level(ed);
        } else {
            aeprintf("insert_before_top_level.\n");
        }
    }

    virtual void insert_before_statement(block_item_list *bil) {
        if(m_parent) {
            m_parent->insert_before_statement(bil);
        } else {
            aeprintf("Insert_before_statement.\n");
        }
    }

    virtual void replace_block_item(block_item *bi) {
        if(m_parent) {
            m_parent->replace_block_item(bi);
        } else {
            aeprintf("replace_block_item.\n");
        }
    }

    virtual void sub_destroyed(AST_node *node) {
        aeprintf("%s failed to overload sub_destroyed.\n",typeid(this).name());
    }

    virtual bool in_no_yield_block(void) {
        if(m_parent) {
            return m_parent->in_no_yield_block();
        } else {
            aeprintf("No yield query reached top of tree.\n");
        }
    }

    virtual void suppress_declarator_explicit_call_conv(void) {
        if(m_parent) {
            m_parent->suppress_declarator_explicit_call_conv();
        } else {
            aeprintf("suppress_declarator_explicit_call_conv.\n");
        }
    }

    virtual external_declaration * remove_decl_by_name(const char *name) {
        aeprintf("remove_decl_by_name not overloaded by %s.\n",typeid(this).name());
    }

    virtual expression_type * get_type(void) {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->get_type();
        } else {
            aeprintf("get_type not overloaded by %s.\n",typeid(this).name());
        }
    }

    virtual expression_type * get_return_type(void) {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->get_return_type();
        } else {
            print();
            printf("\n");
            aeprintf("get_return_type not overloaded by %s.\n",typeid(this).name());
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->get_call_conv_down();
        } else {
            aeprintf("get_call_conv_down not overloaded by %s.\n",typeid(this).name());
        }
    }

    virtual void replace_refs_with_pseudo_expression(void);
    virtual void cast_off_volatile(void);

    virtual void get_used_refs(std::set<unsigned> &used_ref_indices) {
        AST_node **child = begin_child_iter();
        while(child) {
            (*child)->get_used_refs(used_ref_indices);
            child = next_child_iter(child);
        }
    }

    virtual void param_usage(std::vector<std::string> &param_vec) {
        AST_node **child = begin_child_iter();
        while(child) {
            (*child)->param_usage(param_vec);
            child = next_child_iter(child);
        }
    }

    virtual compound_statement * get_enclosing_compound_statement(void);

    virtual bool value_used(AST_node *node) {
        if(m_parent) {
            return m_parent->value_used(this);
        } else {
            aeprintf("Shouldn't get here.\n");
            return false;
        }
    }

    virtual basic_block * get_break_target(void) {
        if(m_parent) {
            return m_parent->get_break_target();
        } else {
            aeprintf("get_break_target.\n");
        }
    }

    virtual basic_block * get_continue_target(void) {
        if(m_parent) {
            return m_parent->get_continue_target();
        } else {
            aeprintf("get_continue_target.\n");
        }
    }

    virtual basic_block * get_return_target(void) {
        if(m_parent) {
            return m_parent->get_return_target();
        } else {
            aeprintf("get_return_target.\n");
        }
    }

    virtual basic_block * get_switch_block(void) {
        if(m_parent) {
            return m_parent->get_switch_block();
        } else {
            aeprintf("get_switch_block.\n");
        }
    }

    virtual void found_default(void) {
        if(m_parent) {
            m_parent->found_default();
        } else {
            aeprintf("found_default.\n");
        }
    }

    bool check_consistency(void) {
        AST_node **child = begin_child_iter();
        while(child) {
            if((*child)->m_parent != this) {
                return false;
            }
            if((*child)->check_consistency() == false) {
                return false;
            }
            child = next_child_iter(child);
        }
        return true;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        size_t size = get_num_children();
        if(size > 1) {
            print();
            oprintf("\n");
            aeprintf("get_lrb_value needs to be overloaded somewhere.\n");
        }
        if(m_parent) {
            return m_parent->get_lrb_value(this,ii);
        } else {
            aeprintf("get_lrb_lvalue.\n");
        }
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        size_t size = get_num_children();
        if(size > 1) {
            print();
            oprintf("\n");
            aeprintf("is_lvalue needs to be overloaded somewhere.\n");
        }
        if(m_parent) {
            return m_parent->is_lvalue(this,ii);
        } else {
            aeprintf("is_lvalue.\n");
        }
    }
#endif

    virtual bool contains_loop_specific(void) {
        AST_node **child = begin_child_iter();
        while(child) {
            if((*child)->contains_loop_specific() == true) {
                return true;
            }
            child = next_child_iter(child);
        }
        return false;
    }

    virtual block_item * get_block_item(void) {
        if(m_parent) {
            return m_parent->get_block_item();
        } else {
            aeprintf("get_block_item.\n");
        }
    }

    virtual call_expression * is_call_context(void) {
        if(m_parent) {
            return m_parent->is_call_context();
        } else {
            return NULL;
        }
    }

    virtual bool is_constant_zero(void) const {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->is_constant_zero();
        } else {
            return false;
        }
    }

    virtual bool is_constant_nonzero(void) const {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->is_constant_nonzero();
        } else {
            return false;
        }
    }

    virtual void create_call_graph(function_definition *fd);
    virtual void denest(function_definition *fd);

    virtual primary_expression * is_simple_pe(void) {
        if(get_num_children() == 1) {
            return (*begin_child_iter())->is_simple_pe();
        } else {
            return NULL;
        }
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        //printf("%s %s\n",one.name(),typeid(*this).name());
        if(one == typeid(*this)) {
            return this;
        } else {
            return NULL;
        }
    }

    // Go as far down the mainline expression path as you can.  The object returned
    // is the first non-mainline object.
    virtual AST_node * get_mainline(void) {
        return this;
    }

    virtual AST_node * prepend_bil(block_item_list *bil);

    virtual void modify_ref(unsigned ref_id, ii_ptr hoist_ii) {
        AST_node **child = begin_child_iter();
        while(child) {
            (*child)->modify_ref(ref_id,hoist_ii);
            child = next_child_iter(child);
        }
    }

    virtual AST_node * remove_volatile(void) {
        AST_node **child = begin_child_iter();
        while(child) {
            (*child) = (*child)->remove_volatile();
            child = next_child_iter(child);
        }
        return this;
    }

    virtual void add_to_statement_cut(const check_vector<ii_ptr > &cuts) {
        if(m_parent) {
            return m_parent->add_to_statement_cut(cuts);
        } else {
            aeprintf("add_to_statement_cut failed to find a statement in the tree above here.\n");
        }
    }

    virtual AST_node * ref_used(void) {
        if(m_parent) {
            return m_parent->ref_used();
        } else {
            return NULL;
        }
    }

    virtual std::string get_unique(const std::string &prepend="");

    virtual AST_node *clone(void) {
        aeprintf("AST_node::clone called.\n");
        return NULL;
    }

    void claim(void) {
        m_parent->replace(this,NULL);
    }
};

template<class T>
T * search_up_for_type(const AST_node *node) {
    AST_node *parent = (AST_node*)node;
    while(1) {
        parent = parent->get_parent();
        if(!parent) {
            return NULL;
        }
        T *ret = dynamic_cast<T *>(parent);
        if(ret) {
            return ret;
        }
    }
}

bool search_up_for_node(const AST_node *node, AST_node *search_node) {
    AST_node *parent = (AST_node*)node;
    while(1) {
        parent = parent->get_parent();
        if(!parent) {
            return false;
        }
        if (parent == search_node) {
            return true;
        }
    }
}

#define TRANSLATE(x,tr) \
    do {                                                       \
        try {                                                  \
            tr = x->translate_pillar(fd);                      \
            break;                                             \
        } catch (redo &r) {                                    \
            if(r.m_node != this) {                             \
                throw;                                         \
            }                                                  \
        } catch (done &d) {                                    \
            if(d.m_node != this) {                             \
                throw;                                         \
            } else {                                           \
                break;                                         \
            }                                                  \
        } catch (...) {                                        \
            printf("Got unknown exception.\n");                \
            assert(0);                                         \
            exit(-1);                                          \
        }                                                      \
    } while(1)

#define CREATE_CALL_GRAPH(x,y) \
    do {                                                       \
        try {                                                  \
            (x)->create_call_graph((y));                       \
            break;                                             \
        } catch (redo &r) {                                    \
            if(r.rethrow(this)) {                              \
                throw;                                         \
            }                                                  \
        } catch (done &d) {                                    \
            if(d.rethrow(this)) {                              \
                throw;                                         \
            } else {                                           \
                break;                                         \
            }                                                  \
        } catch (...) {                                        \
            printf("Got unknown exception.\n");                \
            assert(0);                                         \
            exit(-1);                                          \
        }                                                      \
    } while(1)

#define DENEST(x,y) \
    do {                                                       \
        try {                                                  \
            (x)->denest((y));                                  \
            break;                                             \
        } catch (redo &r) {                                    \
            if(r.rethrow(this)) {                              \
                throw;                                         \
            }                                                  \
        } catch (done &d) {                                    \
            if(d.rethrow(this)) {                              \
                throw;                                         \
            } else {                                           \
                break;                                         \
            }                                                  \
        } catch (...) {                                        \
            printf("Got unknown exception.\n");                \
            assert(0);                                         \
            exit(-1);                                          \
        }                                                      \
    } while(1)

extern std::list<external_declaration *> g_ed_list;
#ifdef MULTITHREAD
pthread_mutex_t g_ed_mutex;
#endif
//WINDOWS::CRITICAL_SECTION g_ed_cs;
/*
class ED_ITER : protected std::list<external_declaration *>::iterator {
public:
};
*/
typedef std::list<external_declaration *>::iterator ED_ITER;

external_declaration * remove_decl_by_name(const char *name);
external_declaration * find_decl_by_name(const char *name);

std::map<std::string,function_definition*> g_func_map;
std::list<function_definition *> g_funcs_to_process;

unsigned g_static_num_refs = 0;
unsigned g_condensed_num_refs = 0;
unsigned g_num_inactive_refs = 0;
unsigned g_safe_pdecl = 0;
unsigned g_unsafe_pdecl = 0;
unsigned g_safe_calls = 0;
unsigned g_unsafe_calls = 0;

#ifdef WIN32
extern "C" void StartTimer();
extern "C" float StopTimer();
extern "C" void StartTimer2();
extern "C" double StopTimer2();
extern "C" void StartTimer3();
extern "C" double StopTimer3();
#endif

//==========================================================================

block_item * gen_yield_check(void);
statement  * gen_yield_check_statement(void);

template <class T>
AST_node * auto_expr_gen(const std::type_info &start, const std::type_info &end, T * node);

#define expr_gen(start_type,end_type,end_node) ((start_type*)auto_expr_gen(typeid(start_type),typeid(end_type),end_node))

//==========================================================================

class redo {
public:
    AST_node *m_node;
    redo(AST_node *node) : m_node(node) {}

    bool rethrow(AST_node *compare) {
        if(compare == m_node) {
            return false;
        } else {
            return true;
        }
    }
};

class done {
public:
    AST_node *m_node;
    done(AST_node *node) : m_node(node) {}

    bool rethrow(AST_node *compare) {
        if(compare == m_node) {
            return false;
        } else {
            return true;
        }
    }
};

class unknown_size {
};
//==========================================================================

#define AST_DEF_CHILDREN_0 \
    virtual unsigned get_num_children(void) const { return 0; }

#define AST_DEF_CHILDREN_1(c1) \
    virtual unsigned get_num_children(void) const { return 1; }     \
    virtual AST_node **begin_child_iter(void) const { return (AST_node**)&c1; } \
    virtual AST_node **next_child_iter(AST_node **cur) const { return NULL; }

#define AST_DEF_CHILDREN_2(c1,c2) \
    virtual unsigned get_num_children(void) const { return 2; }     \
    virtual AST_node **begin_child_iter(void) const { return (AST_node**)&c1; } \
    virtual AST_node **next_child_iter(AST_node **cur) const { if(cur == (AST_node**)&c1) return (AST_node**)&c2; else if(cur == (AST_node**)&c2) return NULL; else aeprintf("next_child_iter problem"); }

#define AST_DEF_CHILDREN_3(c1,c2,c3) \
    virtual unsigned get_num_children(void) const { return 3; }     \
    virtual AST_node **begin_child_iter(void) const { return (AST_node**)&c1; } \
    virtual AST_node **next_child_iter(AST_node **cur) const { if(cur == (AST_node**)&c1) return (AST_node**)&c2; else if(cur == (AST_node**)&c2) return (AST_node**)&c3; else if(cur == (AST_node**)&c3) return NULL; else aeprintf("next_child_iter problem"); }

#define AST_DEF_CHILDREN_4(c1,c2,c3,c4) \
    virtual unsigned get_num_children(void) const { return 4; }     \
    virtual AST_node **begin_child_iter(void) const { return (AST_node**)&c1; } \
    virtual AST_node **next_child_iter(AST_node **cur) const { if(cur == (AST_node**)&c1) return (AST_node**)&c2; else if(cur == (AST_node**)&c2) return (AST_node**)&c3; else if(cur == (AST_node**)&c3) return (AST_node**)&c4; else if(cur == (AST_node**)&c4) return NULL; else aeprintf("next_child_iter problem"); }

//==========================================================================

class primary_expression : public AST_node {
public:
    virtual ~primary_expression(void) {}
    virtual void print(void) const = 0;
    virtual const char * get_node_type(void) const { return "primary_expression"; }
    virtual PILLAR2C_CALLCONV get_call_cc(void) = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        return tr;
    }
    virtual std::string get_func_name(void) {
        aeprintf("postfix_expression::get_func_name() not overloaded by %s\n",typeid(this).name());
    }
    virtual void change_func_name(const std::string &new_name) {
        aeprintf("postfix_expression::change_func_name() not overloaded by %s\n",typeid(this).name());
    }
    virtual void get_func_metadata(call_expression_metadata &cem) {
        print();
        aeprintf("postfix_expression::get_func_metadata() not overloaded by %s\n",typeid(this).name());
    }
    virtual primary_expression * clone(void) = 0;

    AST_DEF_CHILDREN_0
};

class primary_expression_identifier : public primary_expression {
protected:
    ii_ptr m_ii;
public:
    primary_expression_identifier(ii_ptr ii) : m_ii(ii) {}
    virtual ~primary_expression_identifier(void) {}

    virtual void print(void) const {
        if(m_ii->is_continuation()) {
            std::string temp = m_ii->get_continuation_var_string();
            oprintf("&");
            oprintf(temp.c_str());
        }
        else {
            oprintf("%s",m_ii->get_name());
        }
    }

    virtual void print_continuation_label(void) const {
        assert(m_ii->is_continuation());

        std::string temp = m_ii->get_continuation_label_string();
        oprintf(temp.c_str());
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) {
        return m_ii->get_function_cc();
    }

    virtual std::string get_func_name(void) {
        if(m_ii->is_function()) {
            return m_ii->get_string();
        } else if(m_ii->is_function_var()) {
            return std::string();
        } else {
            return std::string();
        }
    }

    virtual void change_func_name(const std::string &new_name) {
        assert(m_ii->is_function());
        m_ii = g_scope_stack.find_or_add(new_name);
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        m_ii->get_func_metadata(cem);
    }

    virtual expression_type * get_type(void);
    virtual expression_type * get_return_type(void);
    virtual void replace_refs_with_pseudo_expression(void);
    virtual void cast_off_volatile(void);
    virtual void get_used_refs(std::set<unsigned> &used_ref_indices);
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);
    virtual primary_expression * is_simple_pe(void) {
        return this;
    }

    ii_ptr  get_symbol(void) {
        return m_ii;
    }

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_identifier(m_ii);
        copy->clone_copy(this);
        return copy;
    }

    virtual void modify_ref(unsigned ref_id, ii_ptr hoist_ii);

    virtual void param_usage(std::vector<std::string> &param_vec) {
        if(m_ii->is_param()) {
            param_vec.push_back(m_ii->get_string());
        }
    }
};

class primary_expression_constant : public primary_expression {
protected:
    std::string m_id;
public:
//    primary_expression_constant(const char *id) : m_id(id) {}
    primary_expression_constant(const std::string &id) : m_id(id) {}

    virtual void print(void) const {
        oprintf("%s",m_id.c_str());
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) {
        aeprintf("constant cannot be source for call cc.\n");
    }

    virtual bool is_constant_zero(void) const {
        return m_id == "0";
    }

    virtual bool is_constant_nonzero(void) const {
        return m_id != "0";
    }

    virtual primary_expression * is_simple_pe(void) {
        return this;
    }

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
};

class primary_expression_constant_int : public primary_expression_constant {
public:
    primary_expression_constant_int(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);
    int get_value(void) const {
        return atoi(m_id.c_str());
    }

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_int(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_constant_unsigned : public primary_expression_constant {
public:
    primary_expression_constant_unsigned(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_unsigned(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_constant_long : public primary_expression_constant {
public:
    primary_expression_constant_long(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_long(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_constant_ulong : public primary_expression_constant {
public:
    primary_expression_constant_ulong(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_ulong(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
         } else {
            return TranslateResult();
        }
   }
};

class primary_expression_constant_ulonglong : public primary_expression_constant {
public:
    primary_expression_constant_ulonglong(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_ulonglong(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
         } else {
            return TranslateResult();
        }
   }
};

class primary_expression_constant_float : public primary_expression_constant {
public:
    primary_expression_constant_float(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_float(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_constant_double : public primary_expression_constant {
public:
    primary_expression_constant_double(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_double(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_constant_long_double : public primary_expression_constant {
public:
    primary_expression_constant_long_double(const std::string &id) : primary_expression_constant(id) {}
    virtual expression_type * get_type(void);

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_constant_long_double(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_string : public primary_expression {
protected:
    char *m_id;
public:
    primary_expression_string(char *id) : m_id(id) {}
    virtual ~primary_expression_string(void) {}

    virtual void print(void) const {
        oprintf("%s ",m_id);
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) {
        aeprintf("string cannot be source for call cc.\n");
    }

    virtual expression_type * get_type(void);

    virtual primary_expression * is_simple_pe(void) {
        return this;
    }

    virtual primary_expression * clone(void) {
        primary_expression *copy = new primary_expression_string(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        if(g_expression_type) {
            auto_ptr<expression_type> apet(get_type());
            TranslateResult gttr(apet);
            return gttr;
        } else {
            return TranslateResult();
        }
    }
};

class primary_expression_expression : public primary_expression {
protected:
    expression *m_e;
public:
    primary_expression_expression(expression *e);
    virtual ~primary_expression_expression(void);

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_cc(void) {
        return get_call_conv_down();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);

    virtual std::string get_func_name(void) {
        return std::string();
    }

    virtual expression * claim_expression(void) {
        expression * ret = m_e;
        m_e = NULL;
        return ret;
    }

    virtual void get_func_metadata(call_expression_metadata &cem);

    virtual primary_expression * clone(void);

    AST_DEF_CHILDREN_1(m_e)
};

// ===============================================================
unsigned g_unneeded_nodes = 0;

class postfix_expression : public AST_node {
public:
    virtual ~postfix_expression(void) {}
    virtual void print(void) const = 0;
    virtual const char * get_node_type(void) const { return "postfix_expression"; }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;

    virtual std::string get_func_name(void) {
        aeprintf("postfix_expression::get_func_name() not overloaded by %s\n",typeid(this).name());
    }
    virtual void change_func_name(const std::string &new_name) {
        aeprintf("postfix_expression::change_func_name() not overloaded by %s\n",typeid(this).name());
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        print();
        printf("\n");
        aeprintf("postfix_expression::get_func_metadata() not overloaded by %s\n",typeid(this).name());
    }

    virtual primary_expression * is_simple_pe(void) {
        return NULL;
    }

    virtual postfix_expression * clone(void) = 0;

    virtual AST_node * get_mainline(void) {
        return this;
    }
    virtual bool value_used(AST_node *node) {
        return true;
    }
};

class postfix_expression_primary_expression : public postfix_expression {
protected:
    primary_expression *m_pe;
public:
    postfix_expression_primary_expression(primary_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_primary_expression(void) {
        delete m_pe;
    }

    virtual primary_expression * get_primary_expression(void) {
        return m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        return m_pe->get_call_cc();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual std::string get_func_name(void) {
        return m_pe->get_func_name();
    }

    virtual void change_func_name(const std::string &new_name) {
        m_pe->change_func_name(new_name);
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        m_pe->get_func_metadata(cem);
    }

    virtual primary_expression * is_simple_pe(void) {
        return m_pe->is_simple_pe();
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_primary_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual bool value_used(AST_node *node) {
        return m_parent->value_used(this);
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_postfix_expression_brace_expression : public postfix_expression {
protected:
    postfix_expression *m_pe;
    expression         *m_e;
public:
    postfix_expression_postfix_expression_brace_expression(postfix_expression *pe, expression *e);
    virtual ~postfix_expression_postfix_expression_brace_expression(void);

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);
    virtual postfix_expression * clone(void);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE; // the ref here is used as an rvalue
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false; // the ref here is used as an rvalue
    }
#endif
    virtual bool value_used(AST_node *node) {
        aeprintf("What to do here?\n");
        return true;
    }

    AST_DEF_CHILDREN_2(m_pe,m_e)
};

class postfix_expression_call_expression : public postfix_expression {
protected:
    call_expression *m_ce;
public:
    postfix_expression_call_expression(call_expression *ce);
    virtual ~postfix_expression_call_expression(void);

    virtual void print(void) const;

    virtual void translate_call(function_definition *fd);
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }
    virtual postfix_expression * clone(void);
    virtual bool value_used(AST_node *node) {
        return m_parent->value_used(this);
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class postfix_expression_read_stats : public postfix_expression_call_expression {
public:
    postfix_expression_read_stats(call_expression *ce) : postfix_expression_call_expression(ce) {}

    virtual expression_type * get_type(void);
};

class postfix_expression_postfix_expression_empty_paren : public postfix_expression {
protected:
    postfix_expression *m_pe;
public:
    postfix_expression_postfix_expression_empty_paren(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_postfix_expression_empty_paren(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf("()");
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_postfix_expression_empty_paren(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_postfix_expression_paren_argument_expression_list : public postfix_expression {
protected:
    postfix_expression *m_pe;
    argument_expression_list *m_ael;
public:
    postfix_expression_postfix_expression_paren_argument_expression_list(postfix_expression *pe,argument_expression_list *ael);
    virtual ~postfix_expression_postfix_expression_paren_argument_expression_list(void);

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual postfix_expression * clone(void);

    AST_DEF_CHILDREN_2(m_pe,m_ael)
};

class postfix_expression_postfix_expression_dot_identifier : public postfix_expression {
protected:
    postfix_expression *m_pe;
    std::string m_id;
public:
    postfix_expression_postfix_expression_dot_identifier(postfix_expression *pe,const std::string &id) : m_pe(pe), m_id(id) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_postfix_expression_dot_identifier(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf(".");
        oprintf("%s",m_id.c_str());
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual expression_type * get_type(void);

    virtual std::string get_func_name(void) {
        return std::string();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_parent);
        return m_parent->get_lrb_value(this,ii);
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_parent);
        return m_parent->is_lvalue(this,ii);
    }
#endif

    virtual primary_expression * is_simple_pe(void) {
        return NULL;
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_postfix_expression_dot_identifier(m_pe->clone(),m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual void get_func_metadata(call_expression_metadata &cem);

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_postfix_expression_ptr_op_identifier : public postfix_expression {
protected:
    postfix_expression *m_pe;
    std::string m_id;
public:
    postfix_expression_postfix_expression_ptr_op_identifier(postfix_expression *pe,const std::string &id) : m_pe(pe), m_id(id) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_postfix_expression_ptr_op_identifier(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf("->");
        oprintf("%s",m_id.c_str());
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual expression_type * get_type(void);
    virtual expression_type * get_return_type(void);

    virtual std::string get_func_name(void) {
        return std::string();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false; // the ref here is used as an rvalue
    }
#endif

    virtual primary_expression * is_simple_pe(void) {
        return NULL;
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_postfix_expression_ptr_op_identifier(m_pe->clone(),m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual void get_func_metadata(call_expression_metadata &cem);

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_postfix_expression_inc_op : public postfix_expression {
protected:
    postfix_expression *m_pe;
public:
    postfix_expression_postfix_expression_inc_op(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_postfix_expression_inc_op(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf("++");
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_postfix_expression_inc_op(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_postfix_expression_dec_op : public postfix_expression {
protected:
    postfix_expression *m_pe;
public:
    postfix_expression_postfix_expression_dec_op(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~postfix_expression_postfix_expression_dec_op(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf("--");
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual postfix_expression * clone(void) {
        postfix_expression *copy = new postfix_expression_postfix_expression_dec_op(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class postfix_expression_type_name_initializer_list : public postfix_expression {
protected:
    type_name *m_tn;
    initializer_list *m_il;
public:
    postfix_expression_type_name_initializer_list(type_name *tn,initializer_list *il);
    virtual ~postfix_expression_type_name_initializer_list(void);

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual postfix_expression * clone(void);

    AST_DEF_CHILDREN_2(m_tn,m_il)
};

class postfix_expression_type_name_initializer_list_comma : public postfix_expression {
protected:
    type_name *m_tn;
    initializer_list *m_il;
public:
    postfix_expression_type_name_initializer_list_comma(type_name *tn,initializer_list *il);
    virtual ~postfix_expression_type_name_initializer_list_comma(void);

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Not implemented.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual postfix_expression * clone(void);

    AST_DEF_CHILDREN_2(m_tn,m_il)
};

// ===============================================================

#ifdef USE_CUT_ID_LIST
class cut_id_list {
public:
    virtual ~cut_id_list(void) {}
};

class cut_id_list_identifier : public cut_id_list {
protected:
    ii_ptr m_id;
public:
    cut_id_list_identifier(ii_ptr id) : m_id(id) {}
};

class cut_id_list_cut_id_list_identifier : public cut_id_list {
protected:
    cut_id_list *m_cil;
    ii_ptr m_id;
public:
    cut_id_list_cut_id_list_identifier(cut_id_list *cil, ii_ptr id) : m_cil(cil), m_id(id) {}
};
#endif

// ===============================================================

class basic_block_ref_events;

class call_expression : public AST_node {
protected:
    check_vector<ii_ptr > m_id_vec;
    unsigned m_unique;
    std::list<ii_ptr > m_read_write_address_refs;
public:
    call_expression(identifier_list *il);
    virtual ~call_expression(void);
    virtual void print(void) const = 0;
    virtual PILLAR2C_CALLCONV get_call_cc(void) const = 0;
    virtual call_expression_metadata * get_call_metadata(void) = 0;
    virtual check_vector<assignment_expression *> claim_args(void) = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual call_expression * prepend_arg_list(argument_expression_list *ael) = 0;
    virtual call_expression * append_arg_list(argument_expression_list *ael) = 0;
    virtual std::string get_func_name(void) = 0;
    virtual void change_func_name(const std::string &new_name)= 0;
    virtual expression_type * get_return_type(void) = 0;
    virtual void add_read_write_address_ref(ii_ptr ii) {
        m_read_write_address_refs.push_back(ii);
    }
    virtual void push_read_write(std::vector<basic_block_ref_events*> &vec);

    virtual call_expression * is_call_context(void) {
        call_expression *another_nest = m_parent->is_call_context();
        if(another_nest) {
            return another_nest;
        } else {
            return this;
        }
    }
    virtual call_expression * clone(void) = 0;

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }

    virtual check_vector<ii_ptr > get_also_cuts_to_vec(void) {
        return m_id_vec;
    }

    void add_vse_continuations_to_cuts(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);
    virtual void denest(function_definition *fd);
    virtual unsigned get_num_args(void) const = 0;
};

class call_expression_postfix_expression_empty_paren : public call_expression {
protected:
    postfix_expression *m_pe;
public:
    call_expression_postfix_expression_empty_paren(postfix_expression *pe, identifier_list *il = NULL) : call_expression(il), m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~call_expression_postfix_expression_empty_paren(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
        oprintf("()");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual postfix_expression * get_postfix_expression(void) {
        return m_pe;
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        return m_pe->get_call_cc();
    }

    virtual call_expression_metadata * get_call_metadata(void) {
        call_expression_metadata *cem = new call_expression_metadata;
        cem->m_pe_function = m_pe->clone();
        cem->m_pe_function->get_func_metadata(*cem);
        return cem;
    }

    virtual check_vector<assignment_expression *> claim_args(void) {
        check_vector<assignment_expression *> temp;
        return temp;
    }

    virtual call_expression * prepend_arg_list(argument_expression_list *ael);

    virtual call_expression * append_arg_list(argument_expression_list *ael) {
        return prepend_arg_list(ael);
    }

    virtual std::string get_func_name(void) {
        return m_pe->get_func_name();
    }

    virtual void change_func_name(const std::string &new_name) {
        m_pe->change_func_name(new_name);
    }

    virtual expression_type * get_type(void) {
        return m_pe->get_return_type();
    }

    virtual expression_type * get_return_type(void) {
        return m_pe->get_return_type();
    }

    virtual call_expression * clone(void) {
        call_expression *copy = new call_expression_postfix_expression_empty_paren(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual unsigned get_num_args(void) const {
        return 0;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class call_expression_postfix_expression_paren_argument_expression_list : public call_expression {
protected:
    postfix_expression *m_pe;
    argument_expression_list *m_ael;
public:
    call_expression_postfix_expression_paren_argument_expression_list(postfix_expression *pe,argument_expression_list *ael, identifier_list *il = NULL);
    virtual ~call_expression_postfix_expression_paren_argument_expression_list(void);

    virtual void print(void) const;

    virtual postfix_expression * get_postfix_expression(void) {
        return m_pe;
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        return m_pe->get_call_cc();
    }

    virtual argument_expression_list * get_ael(void) {
        return m_ael;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual call_expression_metadata * get_call_metadata(void);
    virtual check_vector<assignment_expression *> claim_args(void);
    virtual call_expression * prepend_arg_list(argument_expression_list *ael);
    virtual call_expression * append_arg_list(argument_expression_list *ael);
    virtual unsigned get_num_args(void) const;

    virtual std::string get_func_name(void) {
        return m_pe->get_func_name();
    }

    virtual void change_func_name(const std::string &new_name) {
        m_pe->change_func_name(new_name);
    }

    virtual expression_type * get_type(void) {
        return m_pe->get_return_type();
    }

    virtual expression_type * get_return_type(void) {
        return m_pe->get_return_type();
    }

    virtual call_expression * clone(void);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    AST_DEF_CHILDREN_2(m_pe,m_ael)
};

class call_expression_builtin_offsetof_type_name_identifier : public call_expression {
protected:
    type_name *m_tn;
    ii_ptr     m_ii;
public:
    call_expression_builtin_offsetof_type_name_identifier(type_name *tn, ii_ptr ii);
    virtual ~call_expression_builtin_offsetof_type_name_identifier(void);

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd) {
        // FIX FIX FIX ... probably nothing to do here
        return TranslateResult();
    }

    virtual PILLAR2C_CALLCONV get_call_cc(void) const {
        aeprintf("Should not be called for a builtin.\n");
        return ST_CDECL; // FIX FIX FIX
    }

    virtual call_expression_metadata * get_call_metadata(void) {
        aeprintf("Should not be called for a builtin.\n");
        return NULL;
    }

    virtual call_expression * prepend_arg_list(argument_expression_list *ael) {
        aeprintf("Should not be called for a builtin.\n");
    }

    virtual call_expression * append_arg_list(argument_expression_list *ael) {
        aeprintf("Should not be called for a builtin.\n");
    }

    virtual std::string get_func_name(void) {
        aeprintf("Should not be called for a builtin.\n");
        return "__builtin_offsetof";
    }

    virtual void change_func_name(const std::string &new_name) {
        aeprintf("Should not be called for a builtin.\n");
    }

    virtual expression_type * get_type(void) {
        primary_expression_constant_int peci("");
        return peci.get_type();
    }

    virtual expression_type * get_return_type(void) {
        return this->get_type();
    }

    virtual call_expression * clone(void);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        aeprintf("Should not be called for a builtin.\n");
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        aeprintf("Should not be called for a builtin.\n");
        return false;
    }
#endif

    virtual check_vector<assignment_expression *> claim_args(void) {
        aeprintf("Not implemented yet.\n");
    }

    virtual unsigned get_num_args(void) const {
        aeprintf("Should not call get_num_args for a builtin.\n");
    }

    AST_DEF_CHILDREN_1(m_tn)
};

// ===============================================================

class argument_expression_list : public AST_node {
public:
    virtual ~argument_expression_list (void) {}
    virtual void print(void) const = 0;
    virtual void vectorize(check_vector<assignment_expression *> &args) = 0;
    virtual void claim_vectorize(check_vector<assignment_expression *> &args) = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual argument_expression_list * prepend_arg_list(argument_expression_list *ael) = 0;
    virtual argument_expression_list * clone(void) = 0;

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual assignment_expression * get_ae(void) = 0;

    static argument_expression_list * new_recursive(argument_expression_list *ael,assignment_expression *ae);
};

class argument_expression_list_assignment_expression : public argument_expression_list {
protected:
    assignment_expression *m_ae;
public:
    argument_expression_list_assignment_expression(assignment_expression *ae);
    virtual ~argument_expression_list_assignment_expression(void);

    virtual void print(void) const;
    virtual void vectorize(check_vector<assignment_expression *> &args);
    virtual void claim_vectorize(check_vector<assignment_expression *> &args);
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual argument_expression_list * prepend_arg_list(argument_expression_list *ael);
    virtual argument_expression_list * clone(void);

    virtual assignment_expression * get_ae(void) {
        return m_ae;
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class argument_expression_list_argument_expression_list_assignment_expression : public argument_expression_list {
protected:
    argument_expression_list *m_ael;
    assignment_expression *m_ae;
public:
    argument_expression_list_argument_expression_list_assignment_expression(argument_expression_list *ael,assignment_expression *ae);
    virtual ~argument_expression_list_argument_expression_list_assignment_expression(void);

    virtual void print(void) const;
    virtual void vectorize(check_vector<assignment_expression *> &args);
    virtual void claim_vectorize(check_vector<assignment_expression *> &args);
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual argument_expression_list * prepend_arg_list(argument_expression_list *ael) {
        m_ael = m_ael->prepend_arg_list(ael);
        return this;
    }

    virtual argument_expression_list * clone(void);

    virtual void create_call_graph(function_definition *fd);

    virtual assignment_expression * get_ae(void) {
        return m_ae;
    }

    AST_DEF_CHILDREN_2(m_ael,m_ae)
};

// ===============================================================

class unary_expression : public AST_node {
public:
    virtual ~unary_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual unary_expression * clone(void) = 0;
};

class unary_expression_postfix_expression : public unary_expression {
protected:
    postfix_expression *m_pe;
public:
    unary_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~unary_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_pe->get_mainline();
    }

    virtual unary_expression * clone(void) {
        unary_expression *copy = new unary_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class unary_expression_mainline : public unary_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    unary_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~unary_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_pe->get_mainline();
    }

    virtual unary_expression_mainline * clone(void) {
        unary_expression_mainline *copy = new unary_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * unary_expression_mainline::saved = NULL;

class unary_expression_inc_unary_expression : public unary_expression {
protected:
    unary_expression *m_ue;
public:
    unary_expression_inc_unary_expression(unary_expression *ue) : m_ue(ue) {
        m_ue->set_parent(this);
    }
    virtual ~unary_expression_inc_unary_expression(void) {
        delete m_ue;
    }

    virtual void print(void) const {
        oprintf("++");
        m_ue->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ue,tr);
        return tr;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual unary_expression * clone(void) {
        unary_expression *copy = new unary_expression_inc_unary_expression(m_ue->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ue)
};

class unary_expression_dec_unary_expression : public unary_expression {
protected:
    unary_expression *m_ue;
public:
    unary_expression_dec_unary_expression(unary_expression *ue) : m_ue(ue) {
        m_ue->set_parent(this);
    }
    virtual ~unary_expression_dec_unary_expression(void) {
        delete m_ue;
    }

    virtual void print(void) const {
        oprintf("--");
        m_ue->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ue,tr);
        return tr;
    }

    virtual unary_expression * clone(void) {
        unary_expression *copy = new unary_expression_dec_unary_expression(m_ue->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_1(m_ue)
};

class unary_expression_unary_operator_cast_expression : public unary_expression {
protected:
    unary_operator  *m_uo;
    cast_expression *m_ce;
public:
    unary_expression_unary_operator_cast_expression(unary_operator *uo,cast_expression *ce);
    virtual ~unary_expression_unary_operator_cast_expression(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);
#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii);
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii);
#endif
    virtual unary_expression * clone(void);

    virtual AST_node * ref_used(void);
	virtual unary_operator * get_uo(void) { return m_uo; }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_uo,m_ce)
};

class unary_expression_sizeof_unary_expression : public unary_expression {
protected:
    unary_expression *m_ue;
public:
    unary_expression_sizeof_unary_expression(unary_expression *ue) : m_ue(ue) {
        m_ue->set_parent(this);
    }
    virtual ~unary_expression_sizeof_unary_expression(void) {
        delete m_ue;
    }

    virtual void print(void) const {
        oprintf("sizeof ");
        m_ue->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ue,tr);

        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

    virtual expression_type * get_type(void);

    virtual unary_expression * clone(void) {
        unary_expression *copy = new unary_expression_sizeof_unary_expression(m_ue->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_1(m_ue)
};

class unary_expression_sizeof_type_name : public unary_expression {
protected:
    type_name *m_tn;
public:
    unary_expression_sizeof_type_name(type_name *tn);
    virtual ~unary_expression_sizeof_type_name(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);
    virtual unary_expression * clone(void);

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_1(m_tn)
};

// ===============================================================

class unary_operator : public AST_node {
public:
    virtual ~unary_operator(void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual unary_operator * clone(void) = 0;
};

class unary_operator_and : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" & ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_and();
        copy->clone_copy(this);
        return copy;
    }
};

class unary_operator_star : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" * ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_star();
        copy->clone_copy(this);
        return copy;
    }
};

class unary_operator_plus : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" + ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_plus();
        copy->clone_copy(this);
        return copy;
    }
};

class unary_operator_minus : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" - ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_minus();
        copy->clone_copy(this);
        return copy;
    }
};

class unary_operator_tilde : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" ~ ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_tilde();
        copy->clone_copy(this);
        return copy;
    }
};

class unary_operator_bang : public unary_operator {
public:
    virtual void print(void) const {
        oprintf(" ! ");
    }

    virtual unary_operator * clone(void) {
        unary_operator *copy = new unary_operator_bang();
        copy->clone_copy(this);
        return copy;
    }
};

// ===============================================================

class cast_expression : public AST_node {
public:
    virtual ~cast_expression(void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual cast_expression * clone(void) = 0;
};

class cast_expression_postfix_expression : public cast_expression {
protected:
    postfix_expression *m_pe;
public:
    cast_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~cast_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual cast_expression_postfix_expression * clone(void) {
        cast_expression_postfix_expression *copy = new cast_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class cast_expression_mainline : public cast_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    cast_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~cast_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual cast_expression_mainline * clone(void) {
        cast_expression_mainline *copy = new cast_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * cast_expression_mainline::saved = NULL;

class cast_expression_unary_expression : public cast_expression {
protected:
    unary_expression *m_ue;
public:
    cast_expression_unary_expression(unary_expression *ue) : m_ue(ue) {
        m_ue->set_parent(this);
    }
    virtual ~cast_expression_unary_expression(void) {
        delete m_ue;
    }

    virtual void print(void) const {
        m_ue->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ue,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ue->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ue->get_mainline();
    }

    virtual cast_expression * clone(void) {
        cast_expression *copy = new cast_expression_unary_expression(m_ue->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual unary_expression * get_ue(void) {
        return m_ue;
    }

    AST_DEF_CHILDREN_1(m_ue)
};

class cast_expression_type_name_cast_expression : public cast_expression {
protected:
    type_name       *m_tn;
    cast_expression *m_ce;
public:
    cast_expression_type_name_cast_expression(type_name *tn,cast_expression *ce);
    virtual ~cast_expression_type_name_cast_expression(void);
    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);
    virtual PILLAR2C_CALLCONV get_call_conv_down(void);
#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return m_parent->get_lrb_value(this,ii);
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return m_parent->is_lvalue(this,ii);
    }
#endif

    virtual cast_expression * clone(void);
    virtual expression_type * get_return_type(void);

    AST_DEF_CHILDREN_2(m_tn,m_ce)
};

// ===============================================================

class multiplicative_expression : public AST_node {
public:
    virtual ~multiplicative_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual multiplicative_expression * clone(void) = 0;
};

class multiplicative_expression_postfix_expression : public multiplicative_expression {
protected:
    postfix_expression *m_pe;
public:
    multiplicative_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~multiplicative_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual multiplicative_expression_postfix_expression * clone(void) {
        multiplicative_expression_postfix_expression *copy = new multiplicative_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class multiplicative_expression_mainline : public multiplicative_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    multiplicative_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~multiplicative_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual multiplicative_expression_mainline * clone(void) {
        multiplicative_expression_mainline *copy = new multiplicative_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * multiplicative_expression_mainline::saved = NULL;

class multiplicative_expression_cast_expression : public multiplicative_expression {
protected:
    cast_expression *m_ce;
public:
    multiplicative_expression_cast_expression(cast_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~multiplicative_expression_cast_expression(void) {
        delete m_ce;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ce,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ce->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ce->get_mainline();
    }

    virtual multiplicative_expression * clone(void) {
        multiplicative_expression *copy = new multiplicative_expression_cast_expression(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class multiplicative_expression_multiplicative_expression_times_cast_expression : public multiplicative_expression {
protected:
    multiplicative_expression *m_me;
    cast_expression *m_ce;
public:
    multiplicative_expression_multiplicative_expression_times_cast_expression(multiplicative_expression *me,cast_expression *ce) : m_me(me), m_ce(ce) {
        m_me->set_parent(this);
        m_ce->set_parent(this);
    }
    virtual ~multiplicative_expression_multiplicative_expression_times_cast_expression(void) {
        delete m_me;
        delete m_ce;
    }

    virtual void print(void) const {
        m_me->print();
        oprintf(" * ");
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual multiplicative_expression * clone(void) {
        multiplicative_expression *copy = new multiplicative_expression_multiplicative_expression_times_cast_expression(m_me->clone(),m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        auto_ptr<expression_type> me(m_me->get_type());
        auto_ptr<expression_type> ce(m_ce->get_type());
        return determine_type_numeric_binary_operation(me,ce);
    }

    AST_DEF_CHILDREN_2(m_me,m_ce)
};

class multiplicative_expression_multiplicative_expression_div_cast_expression : public multiplicative_expression {
protected:
    multiplicative_expression *m_me;
    cast_expression *m_ce;
public:
    multiplicative_expression_multiplicative_expression_div_cast_expression(multiplicative_expression *me,cast_expression *ce) : m_me(me), m_ce(ce) {
        m_me->set_parent(this);
        m_ce->set_parent(this);
    }
    virtual ~multiplicative_expression_multiplicative_expression_div_cast_expression(void) {
        delete m_me;
        delete m_ce;
    }

    virtual void print(void) const {
        m_me->print();
        oprintf(" / ");
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual multiplicative_expression * clone(void) {
        multiplicative_expression *copy = new multiplicative_expression_multiplicative_expression_div_cast_expression(m_me->clone(),m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        auto_ptr<expression_type> me(m_me->get_type());
        auto_ptr<expression_type> ce(m_ce->get_type());
        return determine_type_numeric_binary_operation(me,ce);
    }

    AST_DEF_CHILDREN_2(m_me,m_ce)
};

class multiplicative_expression_multiplicative_expression_mod_cast_expression : public multiplicative_expression {
protected:
    multiplicative_expression *m_me;
    cast_expression *m_ce;
public:
    multiplicative_expression_multiplicative_expression_mod_cast_expression(multiplicative_expression *me,cast_expression *ce) : m_me(me), m_ce(ce) {
        m_me->set_parent(this);
        m_ce->set_parent(this);
    }
    virtual ~multiplicative_expression_multiplicative_expression_mod_cast_expression(void) {
        delete m_me;
        delete m_ce;
    }

    virtual void print(void) const {
        m_me->print();
        oprintf(" %% ");
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_me,tr1);
        TRANSLATE(m_ce,tr2);
        return tr1;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual multiplicative_expression * clone(void) {
        multiplicative_expression *copy = new multiplicative_expression_multiplicative_expression_mod_cast_expression(m_me->clone(),m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        auto_ptr<expression_type> me(m_me->get_type());
        auto_ptr<expression_type> ce(m_ce->get_type());
        return determine_type_numeric_binary_operation(me,ce);
    }

    AST_DEF_CHILDREN_2(m_me,m_ce)
};

// ===============================================================

class additive_expression : public AST_node {
public:
    virtual ~additive_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual additive_expression * clone(void) = 0;
};

class additive_expression_postfix_expression : public additive_expression {
protected:
    postfix_expression *m_pe;
public:
    additive_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~additive_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual additive_expression_postfix_expression * clone(void) {
        additive_expression_postfix_expression *copy = new additive_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class additive_expression_mainline : public additive_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    additive_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~additive_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual additive_expression_mainline * clone(void) {
        additive_expression_mainline *copy = new additive_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * additive_expression_mainline::saved = NULL;

class additive_expression_multiplicative_expression : public additive_expression {
protected:
    multiplicative_expression *m_me;
public:
    additive_expression_multiplicative_expression(multiplicative_expression *me) : m_me(me) {
        m_me->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~additive_expression_multiplicative_expression(void) {
        delete m_me;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_me->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_me,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_me->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_me->get_mainline();
    }

    virtual additive_expression * clone(void) {
        additive_expression *copy = new additive_expression_multiplicative_expression(m_me->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_me)
};

class additive_expression_additive_expression_plus_multiplicative_expression : public additive_expression {
protected:
    additive_expression       *m_ae;
    multiplicative_expression *m_me;
public:
    additive_expression_additive_expression_plus_multiplicative_expression(additive_expression *ae,multiplicative_expression *me) : m_ae(ae), m_me(me) {
        m_ae->set_parent(this);
        m_me->set_parent(this);
    }
    virtual ~additive_expression_additive_expression_plus_multiplicative_expression(void) {
        delete m_ae;
        delete m_me;
    }

    virtual void print(void) const {
        m_ae->print();
        oprintf(" + ");
        m_me->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual additive_expression * clone(void) {
        additive_expression *copy = new additive_expression_additive_expression_plus_multiplicative_expression(m_ae->clone(),m_me->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        auto_ptr<expression_type> me(m_me->get_type());
        auto_ptr<expression_type> ae(m_ae->get_type());
        return determine_type_numeric_binary_operation(me,ae);
    }

    AST_DEF_CHILDREN_2(m_ae,m_me)
};

class additive_expression_additive_expression_minus_multiplicative_expression : public additive_expression {
protected:
    additive_expression       *m_ae;
    multiplicative_expression *m_me;
public:
    additive_expression_additive_expression_minus_multiplicative_expression(additive_expression *ae,multiplicative_expression *me) : m_ae(ae), m_me(me) {
        m_ae->set_parent(this);
        m_me->set_parent(this);
    }
    virtual ~additive_expression_additive_expression_minus_multiplicative_expression(void) {
        delete m_ae;
        delete m_me;
    }

    virtual void print(void) const {
        m_ae->print();
        oprintf(" - ");
        m_me->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual additive_expression * clone(void) {
        additive_expression *copy = new additive_expression_additive_expression_minus_multiplicative_expression(m_ae->clone(),m_me->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        auto_ptr<expression_type> me(m_me->get_type());
        auto_ptr<expression_type> ae(m_ae->get_type());
        return determine_type_numeric_binary_operation(me,ae);
    }

    AST_DEF_CHILDREN_2(m_ae,m_me)
};

// ===============================================================

class shift_expression : public AST_node {
public:
    virtual ~shift_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual shift_expression * clone(void) = 0;
};

class shift_expression_postfix_expression : public shift_expression {
protected:
    postfix_expression *m_pe;
public:
    shift_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~shift_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual shift_expression_postfix_expression * clone(void) {
        shift_expression_postfix_expression *copy = new shift_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class shift_expression_mainline : public shift_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    shift_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~shift_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual shift_expression_mainline * clone(void) {
        shift_expression_mainline *copy = new shift_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * shift_expression_mainline::saved = NULL;

class shift_expression_additive_expression : public shift_expression {
protected:
    additive_expression *m_ae;
public:
    shift_expression_additive_expression(additive_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~shift_expression_additive_expression(void) {
        delete m_ae;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ae,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ae->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ae->get_mainline();
    }

    virtual shift_expression * clone(void) {
        shift_expression *copy = new shift_expression_additive_expression(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class shift_expression_shift_expression_left_additive_expression : public shift_expression {
protected:
    shift_expression    *m_se;
    additive_expression *m_ae;
public:
    shift_expression_shift_expression_left_additive_expression(shift_expression *se,additive_expression *ae) : m_se(se), m_ae(ae) {
        m_se->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~shift_expression_shift_expression_left_additive_expression(void) {
        delete m_se;;
        delete m_ae;;
    }

    virtual void print(void) const {
        m_se->print();
        oprintf(" << ");
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_se,tr1);
        TRANSLATE(m_ae,tr2);
        return tr1;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual shift_expression * clone(void) {
        shift_expression *copy = new shift_expression_shift_expression_left_additive_expression(m_se->clone(),m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        return m_se->get_type();
    }

    AST_DEF_CHILDREN_2(m_se,m_ae)
};

class shift_expression_shift_expression_right_additive_expression : public shift_expression {
protected:
    shift_expression    *m_se;
    additive_expression *m_ae;
public:
    shift_expression_shift_expression_right_additive_expression(shift_expression *se,additive_expression *ae) : m_se(se), m_ae(ae) {
        m_se->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~shift_expression_shift_expression_right_additive_expression(void) {
        delete m_se;
        delete m_ae;
    }

    virtual void print(void) const {
        m_se->print();
        oprintf(" >> ");
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_se,tr1);
        TRANSLATE(m_ae,tr2);
        return tr1;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual shift_expression * clone(void) {
        shift_expression *copy = new shift_expression_shift_expression_right_additive_expression(m_se->clone(),m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void) {
        return m_se->get_type();
    }

    AST_DEF_CHILDREN_2(m_se,m_ae)
};

// ===============================================================

class relational_expression : public AST_node {
public:
    virtual ~relational_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual relational_expression * clone(void) = 0;
};

class relational_expression_postfix_expression : public relational_expression {
protected:
    postfix_expression *m_pe;
public:
    relational_expression_postfix_expression(postfix_expression *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~relational_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual relational_expression_postfix_expression * clone(void) {
        relational_expression_postfix_expression *copy = new relational_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class relational_expression_mainline : public relational_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    relational_expression_mainline(AST_node *pe) : m_pe(pe) {
        m_pe->set_parent(this);
    }
    virtual ~relational_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual relational_expression_mainline * clone(void) {
        relational_expression_mainline *copy = new relational_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * relational_expression_mainline::saved = NULL;

class relational_expression_shift_expression : public relational_expression {
protected:
    shift_expression *m_se;
public:
    relational_expression_shift_expression(shift_expression *se) : m_se(se) {
        m_se->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~relational_expression_shift_expression(void) {
        delete m_se;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_se->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_se,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_se->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_se->get_mainline();
    }

    virtual relational_expression * clone(void) {
        relational_expression *copy = new relational_expression_shift_expression(m_se->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_se)
};

class relational_expression_relational_expression_less_shift_expression : public relational_expression {
protected:
    relational_expression *m_re;
    shift_expression *m_se;
public:
    relational_expression_relational_expression_less_shift_expression(relational_expression *re,shift_expression *se) : m_re(re), m_se(se) {
        m_re->set_parent(this);
        m_se->set_parent(this);
    }
    virtual ~relational_expression_relational_expression_less_shift_expression(void) {
        delete m_re;
        delete m_se;
    }

    virtual void print(void) const {
        m_re->print();
        oprintf(" < ");
        m_se->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_re,tr1);
        TRANSLATE(m_se,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual relational_expression * clone(void) {
        relational_expression *copy = new relational_expression_relational_expression_less_shift_expression(m_re->clone(),m_se->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_re,m_se)
};

class relational_expression_relational_expression_right_shift_expression : public relational_expression {
protected:
    relational_expression *m_re;
    shift_expression *m_se;
public:
    relational_expression_relational_expression_right_shift_expression(relational_expression *re,shift_expression *se) : m_re(re), m_se(se) {
        m_re->set_parent(this);
        m_se->set_parent(this);
    }
    virtual ~relational_expression_relational_expression_right_shift_expression(void) {
        delete m_re;
        delete m_se;
    }

    virtual void print(void) const {
        m_re->print();
        oprintf(" > ");
        m_se->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_re,tr1);
        TRANSLATE(m_se,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual relational_expression * clone(void) {
        relational_expression *copy = new relational_expression_relational_expression_right_shift_expression(m_re->clone(),m_se->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_re,m_se)
};

class relational_expression_relational_expression_le_shift_expression : public relational_expression {
protected:
    relational_expression *m_re;
    shift_expression *m_se;
public:
    relational_expression_relational_expression_le_shift_expression(relational_expression *re,shift_expression *se) : m_re(re), m_se(se) {
        m_re->set_parent(this);
        m_se->set_parent(this);
    }
    virtual ~relational_expression_relational_expression_le_shift_expression(void) {
        delete m_re;
        delete m_se;
    }

    virtual void print(void) const {
        m_re->print();
        oprintf(" <= ");
        m_se->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_re,tr1);
        TRANSLATE(m_se,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual relational_expression * clone(void) {
        relational_expression *copy = new relational_expression_relational_expression_le_shift_expression(m_re->clone(),m_se->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_re,m_se)
};

class relational_expression_relational_expression_ge_shift_expression : public relational_expression {
protected:
    relational_expression *m_re;
    shift_expression *m_se;
public:
    relational_expression_relational_expression_ge_shift_expression(relational_expression *re,shift_expression *se) : m_re(re), m_se(se) {
        m_re->set_parent(this);
        m_se->set_parent(this);
    }
    virtual ~relational_expression_relational_expression_ge_shift_expression(void) {
        delete m_re;
        delete m_se;
    }

    virtual void print(void) const {
        m_re->print();
        oprintf(" >= ");
        m_se->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_re,tr1);
        TRANSLATE(m_se,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual relational_expression * clone(void) {
        relational_expression *copy = new relational_expression_relational_expression_ge_shift_expression(m_re->clone(),m_se->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_re,m_se)
};

// ===============================================================

class equality_expression : public AST_node {
public:
    virtual ~equality_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual equality_expression * clone(void) = 0;
};

class equality_expression_postfix_expression : public equality_expression {
protected:
    postfix_expression *m_pe;
public:
    equality_expression_postfix_expression(postfix_expression *re) : m_pe(re) {
        m_pe->set_parent(this);
    }
    virtual ~equality_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual equality_expression_postfix_expression * clone(void) {
        equality_expression_postfix_expression *copy = new equality_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class equality_expression_mainline : public equality_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    equality_expression_mainline(AST_node *re) : m_pe(re) {
        m_pe->set_parent(this);
    }
    virtual ~equality_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual equality_expression_mainline * clone(void) {
        equality_expression_mainline *copy = new equality_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * equality_expression_mainline::saved = NULL;

class equality_expression_relational_expression : public equality_expression {
protected:
    relational_expression *m_re;
public:
    equality_expression_relational_expression(relational_expression *re) : m_re(re) {
        m_re->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~equality_expression_relational_expression(void) {
        delete m_re;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_re->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_re,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_re->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_re->get_mainline();
    }

    virtual equality_expression * clone(void) {
        equality_expression *copy = new equality_expression_relational_expression(m_re->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_re)
};

class equality_expression_equality_expression_eq_op_relational_expression : public equality_expression {
protected:
    equality_expression   *m_ee;
    relational_expression *m_re;
public:
    equality_expression_equality_expression_eq_op_relational_expression(equality_expression *ee,relational_expression *re) : m_ee(ee), m_re(re) {
        m_ee->set_parent(this);
        m_re->set_parent(this);
    }
    virtual ~equality_expression_equality_expression_eq_op_relational_expression(void) {
        delete m_ee;
        delete m_re;
    }

    virtual void print(void) const {
        m_ee->print();
        oprintf(" == ");
        m_re->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ee,tr1);
        TRANSLATE(m_re,tr2);

        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual equality_expression * clone(void) {
        equality_expression *copy = new equality_expression_equality_expression_eq_op_relational_expression(m_ee->clone(),m_re->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_ee,m_re)
};

class equality_expression_equality_expression_ne_op_relational_expression : public equality_expression {
protected:
    equality_expression   *m_ee;
    relational_expression *m_re;
public:
    equality_expression_equality_expression_ne_op_relational_expression(equality_expression *ee,relational_expression *re) : m_ee(ee), m_re(re) {
        m_ee->set_parent(this);
        m_re->set_parent(this);
    }
    virtual ~equality_expression_equality_expression_ne_op_relational_expression(void) {
        delete m_ee;
        delete m_re;
    }

    virtual void print(void) const {
        m_ee->print();
        oprintf(" != ");
        m_re->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ee,tr1);
        TRANSLATE(m_re,tr2);

        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual equality_expression * clone(void) {
        equality_expression *copy = new equality_expression_equality_expression_ne_op_relational_expression(m_ee->clone(),m_re->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_ee,m_re)
};

// ===============================================================

class and_expression : public AST_node {
public:
    virtual ~and_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual and_expression * clone(void) = 0;
};

class and_expression_postfix_expression : public and_expression {
protected:
    postfix_expression *m_pe;
public:
    and_expression_postfix_expression(postfix_expression *ee) : m_pe(ee) {
        m_pe->set_parent(this);
    }
    virtual ~and_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual and_expression_postfix_expression * clone(void) {
        and_expression_postfix_expression *copy = new and_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class and_expression_mainline : public and_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    and_expression_mainline(AST_node *ee) : m_pe(ee) {
        m_pe->set_parent(this);
    }
    virtual ~and_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual and_expression_mainline * clone(void) {
        and_expression_mainline *copy = new and_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * and_expression_mainline::saved = NULL;

class and_expression_equality_expression : public and_expression {
protected:
    equality_expression *m_ee;
public:
    and_expression_equality_expression(equality_expression *ee) : m_ee(ee) {
        m_ee->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~and_expression_equality_expression(void) {
        delete m_ee;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ee->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ee,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ee->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ee->get_mainline();
    }

    virtual and_expression * clone(void) {
        and_expression *copy = new and_expression_equality_expression(m_ee->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ee)
};

class and_expression_and_expression_equality_expression : public and_expression {
protected:
    and_expression      *m_ae;
    equality_expression *m_ee;
public:
    and_expression_and_expression_equality_expression(and_expression *ae,equality_expression *ee) : m_ae(ae), m_ee(ee) {
        m_ae->set_parent(this);
        m_ee->set_parent(this);
    }
    virtual ~and_expression_and_expression_equality_expression(void) {
        delete m_ae;
        delete m_ee;
    }

    virtual void print(void) const {
        m_ae->print();
        oprintf(" & ");
        m_ee->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual and_expression * clone(void) {
        and_expression *copy = new and_expression_and_expression_equality_expression(m_ae->clone(),m_ee->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_ae,m_ee)
};

// ===============================================================

class exclusive_or_expression : public AST_node {
public:
    virtual ~exclusive_or_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual exclusive_or_expression * clone(void) = 0;
};

class exclusive_or_expression_postfix_expression : public exclusive_or_expression {
protected:
    postfix_expression *m_pe;
public:
    exclusive_or_expression_postfix_expression(postfix_expression *ae) : m_pe(ae) {
        m_pe->set_parent(this);
    }
    virtual ~exclusive_or_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual exclusive_or_expression_postfix_expression * clone(void) {
        exclusive_or_expression_postfix_expression *copy = new exclusive_or_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class exclusive_or_expression_mainline : public exclusive_or_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    exclusive_or_expression_mainline(AST_node *ae) : m_pe(ae) {
        m_pe->set_parent(this);
    }
    virtual ~exclusive_or_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual exclusive_or_expression_mainline * clone(void) {
        exclusive_or_expression_mainline *copy = new exclusive_or_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * exclusive_or_expression_mainline::saved = NULL;

class exclusive_or_expression_and_expression : public exclusive_or_expression {
protected:
    and_expression *m_ae;
public:
    exclusive_or_expression_and_expression(and_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~exclusive_or_expression_and_expression(void) {
        delete m_ae;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ae,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ae->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ae->get_mainline();
    }

    virtual exclusive_or_expression * clone(void) {
        exclusive_or_expression *copy = new exclusive_or_expression_and_expression(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class exclusive_or_expression_exclusive_or_expression_and_expression : public exclusive_or_expression {
protected:
    exclusive_or_expression *m_eoe;
    and_expression *m_ae;
public:
    exclusive_or_expression_exclusive_or_expression_and_expression(exclusive_or_expression *eoe,and_expression *ae) : m_eoe(eoe), m_ae(ae) {
        m_eoe->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~exclusive_or_expression_exclusive_or_expression_and_expression(void) {
        delete m_eoe;
        delete m_ae;
    }

    virtual void print(void) const {
        m_eoe->print();
        oprintf(" ^ ");
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_eoe,tr1);
        TRANSLATE(m_ae,tr2);
        return tr1;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual exclusive_or_expression * clone(void) {
        exclusive_or_expression *copy = new exclusive_or_expression_exclusive_or_expression_and_expression(m_eoe->clone(),m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_eoe,m_ae)
};

// ===============================================================

class inclusive_or_expression : public AST_node {
public:
    virtual ~inclusive_or_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual inclusive_or_expression * clone(void) = 0;
};

class inclusive_or_expression_postfix_expression : public inclusive_or_expression {
protected:
    postfix_expression *m_pe;
public:
    inclusive_or_expression_postfix_expression(postfix_expression *eoe) : m_pe(eoe) {
        m_pe->set_parent(this);
    }
    virtual ~inclusive_or_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual inclusive_or_expression_postfix_expression * clone(void) {
        inclusive_or_expression_postfix_expression *copy = new inclusive_or_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class inclusive_or_expression_mainline : public inclusive_or_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    inclusive_or_expression_mainline(AST_node *eoe) : m_pe(eoe) {
        m_pe->set_parent(this);
    }
    virtual ~inclusive_or_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual inclusive_or_expression_mainline * clone(void) {
        inclusive_or_expression_mainline *copy = new inclusive_or_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * inclusive_or_expression_mainline::saved = NULL;

class inclusive_or_expression_exclusive_or_expression : public inclusive_or_expression {
protected:
    exclusive_or_expression *m_eoe;
public:
    inclusive_or_expression_exclusive_or_expression(exclusive_or_expression *eoe) : m_eoe(eoe) {
        m_eoe->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~inclusive_or_expression_exclusive_or_expression(void) {
        delete m_eoe;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_eoe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_eoe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_eoe->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_eoe->get_mainline();
    }

    virtual inclusive_or_expression * clone(void) {
        inclusive_or_expression *copy = new inclusive_or_expression_exclusive_or_expression(m_eoe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_eoe)
};

class inclusive_or_expression_inclusive_or_expression_exclusive_or_expression : public inclusive_or_expression {
protected:
    inclusive_or_expression *m_ioe;
    exclusive_or_expression *m_eoe;
public:
    inclusive_or_expression_inclusive_or_expression_exclusive_or_expression(inclusive_or_expression *ioe,exclusive_or_expression *eoe) : m_ioe(ioe), m_eoe(eoe) {
        m_ioe->set_parent(this);
        m_eoe->set_parent(this);
    }
    virtual ~inclusive_or_expression_inclusive_or_expression_exclusive_or_expression(void) {
        delete m_ioe;
        delete m_eoe;
    }

    virtual void print(void) const {
        m_ioe->print();
        oprintf(" | ");
        m_eoe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ioe,tr1);
        TRANSLATE(m_eoe,tr2);
        return tr1;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual inclusive_or_expression * clone(void) {
        inclusive_or_expression *copy = new inclusive_or_expression_inclusive_or_expression_exclusive_or_expression(m_ioe->clone(),m_eoe->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_ioe,m_eoe)
};

// ===============================================================

class logical_and_expression : public AST_node {
public:
    virtual ~logical_and_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual logical_and_expression * clone(void) = 0;
};

class logical_and_expression_postfix_expression : public logical_and_expression {
protected:
    postfix_expression *m_pe;
public:
    logical_and_expression_postfix_expression(postfix_expression *ioe) : m_pe(ioe) {
        m_pe->set_parent(this);
    }
    virtual ~logical_and_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual logical_and_expression_postfix_expression * clone(void) {
        logical_and_expression_postfix_expression *copy = new logical_and_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class logical_and_expression_mainline : public logical_and_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    logical_and_expression_mainline(AST_node *ioe) : m_pe(ioe) {
        m_pe->set_parent(this);
    }
    virtual ~logical_and_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual logical_and_expression_mainline * clone(void) {
        logical_and_expression_mainline *copy = new logical_and_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * logical_and_expression_mainline::saved = NULL;

class logical_and_expression_inclusive_or_expression : public logical_and_expression {
protected:
    inclusive_or_expression *m_ioe;
public:
    logical_and_expression_inclusive_or_expression(inclusive_or_expression *ioe) : m_ioe(ioe) {
        m_ioe->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~logical_and_expression_inclusive_or_expression(void) {
        delete m_ioe;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ioe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ioe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ioe->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ioe->get_mainline();
    }

    virtual logical_and_expression * clone(void) {
        logical_and_expression *copy = new logical_and_expression_inclusive_or_expression(m_ioe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ioe)
};

class logical_and_expression_logical_and_expression_inclusive_or_expression : public logical_and_expression {
protected:
    logical_and_expression  *m_lae;
    inclusive_or_expression *m_ioe;
public:
    logical_and_expression_logical_and_expression_inclusive_or_expression(logical_and_expression *lae,inclusive_or_expression *ioe) : m_lae(lae), m_ioe(ioe) {
        m_lae->set_parent(this);
        m_ioe->set_parent(this);
    }
    virtual ~logical_and_expression_logical_and_expression_inclusive_or_expression(void) {
        delete m_lae;
        delete m_ioe;
    }

    virtual void print(void) const {
        m_lae->print();
        oprintf(" && ");
        m_ioe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_lae,tr1);
        TRANSLATE(m_ioe,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual logical_and_expression * clone(void) {
        logical_and_expression *copy = new logical_and_expression_logical_and_expression_inclusive_or_expression(m_lae->clone(),m_ioe->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_lae,m_ioe)
};

// ===============================================================

class logical_or_expression : public AST_node {
public:
    virtual ~logical_or_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual logical_or_expression * clone(void) = 0;
};

class logical_or_expression_postfix_expression : public logical_or_expression {
protected:
    postfix_expression *m_pe;
public:
    logical_or_expression_postfix_expression(postfix_expression *lae) : m_pe(lae) {
        m_pe->set_parent(this);
    }
    virtual ~logical_or_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual logical_or_expression_postfix_expression * clone(void) {
        logical_or_expression_postfix_expression *copy = new logical_or_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class logical_or_expression_mainline : public logical_or_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    logical_or_expression_mainline(AST_node *lae) : m_pe(lae) {
        m_pe->set_parent(this);
    }
    virtual ~logical_or_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual logical_or_expression_mainline * clone(void) {
        logical_or_expression_mainline *copy = new logical_or_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * logical_or_expression_mainline::saved = NULL;

class logical_or_expression_logical_and_expression : public logical_or_expression {
protected:
    logical_and_expression *m_lae;
public:
    logical_or_expression_logical_and_expression(logical_and_expression *lae) : m_lae(lae) {
        m_lae->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~logical_or_expression_logical_and_expression(void) {
        delete m_lae;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_lae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_lae,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_lae->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_lae->get_mainline();
    }

    virtual logical_or_expression * clone(void) {
        logical_or_expression *copy = new logical_or_expression_logical_and_expression(m_lae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_lae)
};

class logical_or_expression_logical_or_expression_logical_and_expression : public logical_or_expression {
protected:
    logical_or_expression  *m_loe;
    logical_and_expression *m_lae;
public:
    logical_or_expression_logical_or_expression_logical_and_expression(logical_or_expression *loe,logical_and_expression *lae) : m_loe(loe), m_lae(lae) {
        m_loe->set_parent(this);
        m_lae->set_parent(this);
    }
    virtual ~logical_or_expression_logical_or_expression_logical_and_expression(void) {
        delete m_loe;
        delete m_lae;
    }

    virtual void print(void) const {
        m_loe->print();
        oprintf(" || ");
        m_lae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_loe,tr1);
        TRANSLATE(m_lae,tr2);
        if(g_expression_type) {
            primary_expression_constant_int peci("");
            return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
        } else {
            return TranslateResult();
        }
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual logical_or_expression * clone(void) {
        logical_or_expression *copy = new logical_or_expression_logical_or_expression_logical_and_expression(m_loe->clone(),m_lae->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool value_used(AST_node *node) {
        return true;
    }

    AST_DEF_CHILDREN_2(m_loe,m_lae)
};

// ===============================================================

class conditional_expression : public AST_node {
public:
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual conditional_expression * clone(void) = 0;
};

class conditional_expression_postfix_expression : public conditional_expression {
protected:
    postfix_expression *m_pe;
public:
    conditional_expression_postfix_expression(postfix_expression *loe) : m_pe(loe) {
        m_pe->set_parent(this);
    }
    virtual ~conditional_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual conditional_expression_postfix_expression * clone(void) {
        conditional_expression_postfix_expression *copy = new conditional_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class conditional_expression_mainline : public conditional_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    conditional_expression_mainline(AST_node *loe) : m_pe(loe) {
        m_pe->set_parent(this);
    }
    virtual ~conditional_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual conditional_expression_mainline * clone(void) {
        conditional_expression_mainline *copy = new conditional_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * conditional_expression_mainline::saved = NULL;

class conditional_expression_logical_or_expression : public conditional_expression {
protected:
    logical_or_expression *m_loe;
public:
    conditional_expression_logical_or_expression(logical_or_expression *loe) : m_loe(loe) {
        m_loe->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~conditional_expression_logical_or_expression(void) {
        delete m_loe;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_loe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_loe,tr);
        return tr;
    }

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_loe->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_loe->get_mainline();
    }

    virtual conditional_expression * clone(void) {
        conditional_expression *copy = new conditional_expression_logical_or_expression(m_loe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_loe)
};

class conditional_expression_logical_or_expression_expression_conditional_expression : public conditional_expression {
protected:
    logical_or_expression  *m_loe;
    expression             *m_e;
    conditional_expression *m_ce;
public:
    conditional_expression_logical_or_expression_expression_conditional_expression(logical_or_expression *loe,expression *e,conditional_expression *ce);
    virtual ~conditional_expression_logical_or_expression_expression_conditional_expression(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual conditional_expression * clone(void);

    virtual bool value_used(AST_node *node) {
        return true;
    }

    virtual expression_type * get_type(void);

    AST_DEF_CHILDREN_3(m_loe,m_e,m_ce)
};

// ===============================================================

class assignment_expression : public AST_node {
public:
    virtual ~assignment_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd) {
        aeprintf("assignment_expression::gen_struct_declaration not overloaded for %s.\n",typeid(this).name());
    }
    virtual assignment_expression * clone(void) = 0;
};

class assignment_expression_postfix_expression : public assignment_expression {
protected:
    postfix_expression *m_pe;
public:
    assignment_expression_postfix_expression(postfix_expression *ce) : m_pe(ce) {
        m_pe->set_parent(this);
    }
    virtual ~assignment_expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual assignment_expression_postfix_expression * clone(void) {
        assignment_expression_postfix_expression *copy = new assignment_expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class assignment_expression_mainline : public assignment_expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    assignment_expression_mainline(AST_node *ce) : m_pe(ce) {
        m_pe->set_parent(this);
    }
    virtual ~assignment_expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pe,tr);
        return tr;
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual assignment_expression_mainline * clone(void) {
        assignment_expression_mainline *copy = new assignment_expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * assignment_expression_mainline::saved = NULL;

class assignment_expression_conditional_expression : public assignment_expression {
protected:
    conditional_expression *m_ce;
public:
    assignment_expression_conditional_expression(conditional_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
        ++g_unneeded_nodes;
    }
    virtual ~assignment_expression_conditional_expression(void) {
        delete m_ce;
        --g_unneeded_nodes;
    }

    virtual void print(void) const {
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ce,tr);
        return tr;
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ce->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ce->get_mainline();
    }

    virtual assignment_expression * clone(void) {
        assignment_expression *copy = new assignment_expression_conditional_expression(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class assignment_expression_unary_expression_assignment_operator_assignment_expression : public assignment_expression {
protected:
    unary_expression      *m_ue;
    assignment_operator   *m_ao;
    assignment_expression *m_ae;
public:
    assignment_expression_unary_expression_assignment_operator_assignment_expression(unary_expression *ue,assignment_operator *ao,assignment_expression *ae);
    virtual ~assignment_expression_unary_expression_assignment_operator_assignment_expression(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii);
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii);
#endif
    virtual assignment_expression * clone(void);
    virtual bool value_used(AST_node *node) {
        if(node == m_ae) {
            return true;
        }
        aeprintf("Don't think should get here.\n");
    }

	bool is_part_of_lhs(AST_node *node);
	void add_volatile_void_rhs_cast();
	void add_rhs_cast(type_name *the_cast);

    AST_DEF_CHILDREN_3(m_ue,m_ao,m_ae)
};

class assignment_expression_multiple_ret_expr_equal_postfix_expression : public assignment_expression {
protected:
    multiple_ret_expr  *m_mre;
    postfix_expression *m_pe;
    unsigned m_unique;
public:
    assignment_expression_multiple_ret_expr_equal_postfix_expression(multiple_ret_expr *mre, postfix_expression *pe);

    virtual void print(void) const {
        aeprintf("assignment_expression_multiple_ret_expr_equal_call_expression should not support print");
    }
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual assignment_expression * clone(void) {
        aeprintf("assignment_expression_multiple_ret_expr_equal_call_expression should not support clone");
    }

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }

    AST_DEF_CHILDREN_2(m_mre,m_pe)
};

class assignment_expression_text : public assignment_expression {
protected:
    std::string m_text;
public:
    assignment_expression_text(const std::string &et) : m_text(et) {}
   ~assignment_expression_text(void) {}

    virtual void print(void) const {
        oprintf(m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("emit_text should be created but never processed by translate_pillar.\n");
    }

    virtual assignment_expression_text * clone(void) {
        aeprintf("emit_text should be created but never processed by clone.\n");
    }
};


// ===============================================================

class assignment_operator : public AST_node {
public:
    virtual ~assignment_operator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual assignment_operator * clone(void) = 0;
    virtual bool read_write(void) const {
        return false;
    }
};

class assignment_operator_equal : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_equal();
        copy->clone_copy(this);
        return copy;
    }
};

class assignment_operator_mul : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("*=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_mul();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_div : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("/=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_div();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_mod : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("%%=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_mod();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_add : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("+=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_add();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_sub : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("-=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_sub();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_left : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("<<=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_left();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_right : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf(">>=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_right();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_and : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("&=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_and();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_xor : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("^=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_xor();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

class assignment_operator_or : public assignment_operator {
public:
    virtual void print(void) const {
        oprintf("|=");
    }

    virtual assignment_operator * clone(void) {
        assignment_operator *copy = new assignment_operator_or();
        copy->clone_copy(this);
        return copy;
    }
    virtual bool read_write(void) const {
        return true;
    }
};

// ===============================================================

class expression : public AST_node {
public:
    virtual ~expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual expression * clone(void) = 0;
};


class expression_postfix_expression : public expression {
protected:
    postfix_expression *m_pe;
public:
    expression_postfix_expression(postfix_expression *ae) : m_pe(ae) {
        m_pe->set_parent(this);
    }
    virtual ~expression_postfix_expression(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual expression_postfix_expression * clone(void) {
        expression_postfix_expression *copy = new expression_postfix_expression(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pe)
};

class expression_mainline : public expression {
protected:
    AST_node *m_pe;
    static void * saved;
public:
    expression_mainline(AST_node *ae) : m_pe(ae) {
        m_pe->set_parent(this);
    }
    virtual ~expression_mainline(void) {
        delete m_pe;
    }

    virtual void print(void) const {
        m_pe->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_pe->is_mainline(one);
        }
    }

    virtual expression_mainline * clone(void) {
        expression_mainline *copy = new expression_mainline(m_pe->clone());
        copy->clone_copy(this);
        return copy;
    }

    MAINLINE_CACHE_CODE
    AST_DEF_CHILDREN_1(m_pe)
};

void * expression_mainline::saved = NULL;

class expression_assignment_expression : public expression {
protected:
    assignment_expression *m_ae;
public:
    expression_assignment_expression(assignment_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
    }
    virtual ~expression_assignment_expression(void) {
        delete m_ae;
    }

    virtual void print(void) const {
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual AST_node * is_mainline(const std::type_info &one) {
        if(one == typeid(*this)) {
            return this;
        } else {
            return m_ae->is_mainline(one);
        }
    }

    virtual AST_node * get_mainline(void) {
        return m_ae->get_mainline();
    }

    virtual expression * clone(void) {
        expression *copy = new expression_assignment_expression(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class expression_expression_assignment_expression : public expression {
protected:
    expression            *m_e;
    assignment_expression *m_ae;
public:
    expression_expression_assignment_expression(expression *e,assignment_expression *ae) : m_e(e), m_ae(ae) {
        m_e->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~expression_expression_assignment_expression(void) {
        delete m_e;
        delete m_ae;
    }

    virtual bool value_used(AST_node *node) {
        if(node == m_e) {
            return false;
        }
        if(node == m_ae) {
            return m_parent->value_used(this);
        }
        aeprintf("Don't think should get here.\n");
    }

    virtual expression_type * get_type(void) {
        return m_ae->get_type();
    }

    virtual void print(void) const {
        m_e->print();
        oprintf(" , ");
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1,tr2;
        TRANSLATE(m_e,tr1);
        TRANSLATE(m_ae,tr2);
        return tr2;
    }

    virtual expression * clone(void) {
        expression *copy = new expression_expression_assignment_expression(m_e->clone(),m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    static expression * new_recursive(expression *expr,assignment_expression *ae) {
        if(expr) {
            return new expression_expression_assignment_expression(expr,ae);
        } else {
            return new expression_assignment_expression(ae);
        }
    }

    AST_DEF_CHILDREN_2(m_e,m_ae)
};

// ===============================================================

class constant_expression : public AST_node {
public:
    virtual ~constant_expression (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual constant_expression * clone(void) = 0;
};

class constant_expression_conditional_expression : public constant_expression {
protected:
    conditional_expression *m_ce;
public:
    constant_expression_conditional_expression(conditional_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~constant_expression_conditional_expression(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ce,tr);
        return tr;
    }

    virtual constant_expression * clone(void) {
        constant_expression *copy = new constant_expression_conditional_expression(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

// ===============================================================

class declaration : public AST_node {
protected:
//ii_ptr m_ii;
public:
    std::list<std::pair<ii_ptr ,declarator*> > m_ii;

    virtual bool is_function(void) const {
        if(m_ii.size()) {
            ii_ptr temp_ii = m_ii.front().first;
            return temp_ii->is_function();
        } else {
            return false;
        }
    }

    declaration(void) {}
    virtual ~declaration (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual bool declares_name(const char *name) {
        return false;
    }
    virtual declaration_specifiers * get_declaration_specifiers(void) = 0;
    virtual declarator * get_declarator_with_name(const char *name) {
        return NULL;
    }
    virtual declaration * clone(void) = 0;
    virtual void add_volatile(void) = 0;
    virtual void get_func_metadata(call_expression_metadata &cem) = 0;
    virtual expression_type * get_return_type(void) = 0;
    virtual expression_type * get_type(void) {
        return get_return_type();
    }
};

class declaration_declaration_specifiers : public declaration {
protected:
    declaration_specifiers *m_ds;
public:
    declaration_declaration_specifiers(declaration_specifiers *ds);
    virtual ~declaration_declaration_specifiers(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_return_type(void);
    virtual declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }
    virtual bool declares_name(const char *name);

    virtual declaration * clone(void);
    virtual void add_volatile(void);
    virtual void get_func_metadata(call_expression_metadata &cem) {
        print();
        printf("\n");
        aeprintf("Get get func metadata on this kind of declaration.\n");
    }

    AST_DEF_CHILDREN_1(m_ds)
};

#if 1

class attr_or_uuasmuu : public AST_node {
public:
    virtual TranslateResult translate_pillar(function_definition*) {
        return TranslateResult();
    }
};

class attr_or_uuasmuu_attribute : public attr_or_uuasmuu {
protected:
    std::string m_s;
public:
    attr_or_uuasmuu_attribute(const std::string &s) : m_s(s) {}

    virtual void print(void) const {
        oprintf("%s",m_s.c_str());
    }
};

class attr_or_uuasmuu_attr_or_uuasmuu_attribute : public attr_or_uuasmuu {
protected:
    attr_or_uuasmuu *m_au;
    std::string m_s;
public:
    attr_or_uuasmuu_attr_or_uuasmuu_attribute(attr_or_uuasmuu *au, const std::string &s) : m_au(au), m_s(s) {}

    virtual void print(void) const {
        m_au->print();
        oprintf("%s",m_s.c_str());
    }

    AST_DEF_CHILDREN_1(m_au)
};

class attr_or_uuasmuu_uuasmuu : public attr_or_uuasmuu {
protected:
    std::string m_s;
public:
    attr_or_uuasmuu_uuasmuu(const std::string &s) : m_s(s) {}

    virtual void print(void) const {
        oprintf("%s",m_s.c_str());
    }
};

class attr_or_uuasmuu_attr_or_uuasmuu_uuasmuu : public attr_or_uuasmuu {
protected:
    attr_or_uuasmuu *m_au;
    std::string m_s;
public:
    attr_or_uuasmuu_attr_or_uuasmuu_uuasmuu(attr_or_uuasmuu *au, const std::string &s) : m_au(au), m_s(s) {}

    virtual void print(void) const {
        m_au->print();
        oprintf("%s",m_s.c_str());
    }

    AST_DEF_CHILDREN_1(m_au)
};

class declaration_declaration_specifiers_init_declarator_list : public declaration {
protected:
    declaration_specifiers *m_ds;
    init_declarator_list   *m_idl;
    std::string m_before_s;
    attr_or_uuasmuu *m_au;
public:
    declaration_declaration_specifiers_init_declarator_list(declaration_specifiers *ds,init_declarator_list *idl,const std::string &before="",attr_or_uuasmuu *au=NULL);
    virtual ~declaration_declaration_specifiers_init_declarator_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::list<ii_ptr > get_enclosing_symbols(void);

    virtual void sub_destroyed(AST_node *node);
    virtual bool declares_name(const char *name);
    virtual expression_type * get_return_type(void);
    virtual declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual declaration * clone(void);

    init_declarator_list * get_init_declarator_list(void) const {
        return m_idl;
    }

    init_declarator_list * get_init_declarator_list(void) {
        return m_idl;
    }

    virtual void add_volatile(void);

    virtual void get_func_metadata(call_expression_metadata &cem);

    virtual declarator * get_declarator_with_name(const char *name);

    AST_DEF_CHILDREN_2(m_ds,m_idl)
};

#else

class declaration_declaration_specifiers_init_declarator_list : public declaration {
protected:
    declaration_specifiers *m_ds;
    init_declarator_list   *m_idl;
    std::string m_before_s;
    std::string m_after_s;
public:
    declaration_declaration_specifiers_init_declarator_list(declaration_specifiers *ds,init_declarator_list *idl,const std::string &before="",const std::string &after="");
    virtual ~declaration_declaration_specifiers_init_declarator_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::list<ii_ptr > get_enclosing_symbols(void);

    virtual void sub_destroyed(AST_node *node);
    virtual bool declares_name(const char *name);
    virtual expression_type * get_return_type(void);
    virtual declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual declaration * clone(void);

    init_declarator_list * get_init_declarator_list(void) const {
        return m_idl;
    }

    init_declarator_list * get_init_declarator_list(void) {
        return m_idl;
    }

    virtual void add_volatile(void);
};
#endif

// ===============================================================

class storage_class_specifier : public AST_node {
public:
    virtual ~storage_class_specifier (void) {}

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual bool is_static(void) {
        return false;
    }
    virtual storage_class_specifier * clone(void) = 0;
    virtual storage_class_specifier * remove_static(void) {
        aeprintf("remove_static called on non-static storage_class_specifier.\n");
    }
};

class storage_class_specifier_TYPEDEF : public storage_class_specifier {
public:
    bool is_typedef(void) const {
        return true;
    }

    virtual void print(void) const {
        oprintf("typedef");
    }

    virtual storage_class_specifier * clone(void) {
        storage_class_specifier *copy = new storage_class_specifier_TYPEDEF();
        copy->clone_copy(this);
        return copy;
    }
};

class storage_class_specifier_EXTERN : public storage_class_specifier {
public:
    virtual void print(void) const {
        oprintf("extern");
    }

    virtual storage_class_specifier * clone(void) {
        storage_class_specifier *copy = new storage_class_specifier_EXTERN();
        copy->clone_copy(this);
        return copy;
    }
};

class storage_class_specifier_STATIC : public storage_class_specifier {
public:
    virtual void print(void) const {
        oprintf("static");
    }
    virtual bool is_static(void) {
        return true;
    }

    virtual storage_class_specifier * clone(void) {
        storage_class_specifier *copy = new storage_class_specifier_STATIC();
        copy->clone_copy(this);
        return copy;
    }
    virtual storage_class_specifier * remove_static(void) {
        delete this;
        return NULL;
    }
};

class storage_class_specifier_AUTO : public storage_class_specifier {
public:
    virtual void print(void) const {
        oprintf("auto");
    }

    virtual storage_class_specifier * clone(void) {
        storage_class_specifier *copy = new storage_class_specifier_AUTO();
        copy->clone_copy(this);
        return copy;
    }
};

class storage_class_specifier_REGISTER : public storage_class_specifier {
public:
    virtual void print(void) const {
        oprintf("register");
    }

    virtual storage_class_specifier * clone(void) {
        storage_class_specifier *copy = new storage_class_specifier_REGISTER();
        copy->clone_copy(this);
        return copy;
    }
};

// ===============================================================

class ts_comma_list : public AST_node {
public:
    virtual ~ts_comma_list(void) {}
    virtual void print(void) const = 0;
    virtual void flatten(check_vector<type_name *> &flat_vec) = 0;
};

class ts_comma_list_ts : public ts_comma_list {
protected:
    type_name *m_tn;
public:
    ts_comma_list_ts(type_name *tn);
    virtual void print(void) const {
        aeprintf("Shouldn't print ts_comma_list_ts\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Shouldn't translate ts_comma_list_ts\n");
    }
    void flatten(check_vector<type_name *> &flat_vec) {
        flat_vec.push_back(m_tn);
    }

    AST_DEF_CHILDREN_1(m_tn)
};

class ts_comma_list_ts_ts_comma_list : public ts_comma_list {
protected:
    type_name *m_tn;
    ts_comma_list  *m_tscl;
public:
    ts_comma_list_ts_ts_comma_list(type_name *ts, ts_comma_list *tscl);
    virtual void print(void) const {
        aeprintf("Shouldn't print ts_comma_list_ts_ts_comma_list\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Shouldn't translate ts_comma_list_ts_ts_comma_list\n");
    }
    void flatten(check_vector<type_name *> &flat_vec) {
        flat_vec.push_back(m_tn);
        m_tscl->flatten(flat_vec);
    }

    AST_DEF_CHILDREN_2(m_tn,m_tscl)
};

class multiple_ret_value : public AST_node {
public:
    virtual void flatten(check_vector<type_name *> &flat_vec) = 0;
};

class multiple_ret_value_ts : public multiple_ret_value {
protected:
    type_name *m_tn;
    ts_comma_list  *m_tscl;
public:
    multiple_ret_value_ts(type_name *tn, ts_comma_list *tscl);
    virtual ~multiple_ret_value_ts(void) {}

    virtual void print(void) const {
        aeprintf("Shouldn't print multiple_ret_value_ts\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Shouldn't translate multiple_ret_value_ts\n");
    }

    void flatten(check_vector<type_name *> &flat_vec) {
        flat_vec.push_back(m_tn);
        m_tscl->flatten(flat_vec);
    }

    AST_DEF_CHILDREN_2(m_tn,m_tscl)
};

class assignment_expression_list : public AST_node {
public:
    virtual void flatten(check_vector<assignment_expression *> &flat_vec) = 0;
};

class assignment_expression_list_assignment_expression : public assignment_expression_list {
protected:
    assignment_expression *m_ae;
public:
    assignment_expression_list_assignment_expression(assignment_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
    }
    virtual void print(void) const {
        aeprintf("Shouldn't print assignment_expression_list_assignment_expression\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Shouldn't translate assignment_expression_list_assignment_expression\n");
    }

    virtual void flatten(check_vector<assignment_expression *> &flat_vec) {
        flat_vec.push_back(m_ae);
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class assignment_expression_list_assignment_expression_assignment_expression_list : public assignment_expression_list {
protected:
    assignment_expression *m_ae;
    assignment_expression_list *m_ael;
public:
    assignment_expression_list_assignment_expression_assignment_expression_list(assignment_expression *ae, assignment_expression_list *aelist) {
        m_ae->set_parent(this);
        m_ael->set_parent(this);
    }
    virtual void print(void) const {
        aeprintf("Shouldn't print assignment_expression_list_assignment_expression_assignment_expression_list\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Shouldn't translate assignment_expression_list_assignment_expression_assignment_expression_list\n");
    }

    virtual void flatten(check_vector<assignment_expression *> &flat_vec) {
        flat_vec.push_back(m_ae);
        m_ael->flatten(flat_vec);
    }

    AST_DEF_CHILDREN_2(m_ae,m_ael)
};

class multiple_ret_expr : public AST_node {
public:
    virtual void flatten(check_vector<assignment_expression *> &flat_vec) = 0;
};

class multiple_ret_expr_assignment_expression_assignment_expression_list : public multiple_ret_expr {
protected:
    assignment_expression *m_ae;
    assignment_expression_list *m_ael;
    unsigned m_unique;
public:
    multiple_ret_expr_assignment_expression_assignment_expression_list(assignment_expression *ae, assignment_expression_list *aelist) : m_ae(ae), m_ael(aelist) {
        m_ae->set_parent(this);
        m_ael->set_parent(this);
        m_unique = g_unique_id++;
    }
    virtual void print(void) const {
        aeprintf("Shouldn't print multiple_ret_expr_ae\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void flatten(check_vector<assignment_expression *> &flat_vec) {
        flat_vec.push_back(m_ae);
        m_ael->flatten(flat_vec);
    }

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }

    AST_DEF_CHILDREN_2(m_ae,m_ael)
};

// ===============================================================

class declaration_specifiers : public AST_node {
public:
    virtual ~declaration_specifiers (void) {}
    virtual ii_ptr  add_to_symbol_table(void) const = 0;
    virtual bool is_typedef(void) const = 0;
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual type_specifier * get_type_specifier(void) const = 0;
    virtual bool is_this_int(void) { return false; }
    virtual bool is_this_long(void) { return false; }
    virtual bool is_this_double(void) { return false; }
    virtual declaration_specifiers * remove_first(void) { return NULL; }
    virtual bool is_void(void) {
        return false;
    }
    virtual bool is_volatile(void) = 0;

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        aeprintf("%s failed to overload gen_specifier_qualifier_list.\n",typeid(this).name());
    }
    virtual bool declares_name(const char *name) {
        return false;
    }
    virtual bool is_static(void) = 0;
    virtual declaration_specifiers * remove_static(void) = 0;
    virtual bool has_noreturn(void)= 0;
    virtual declaration_specifiers * add_noinline(void);
#ifndef __x86_64__
    virtual declaration_specifiers * add_no_regparm(void);
#endif
    virtual declaration_specifiers * add_volatile(void);
    virtual declaration_specifiers * clone(void) = 0;
    virtual declaration_specifiers * append(declaration_specifiers *to_append) = 0;
};

class declaration_specifiers_storage_class_specifier : public declaration_specifiers {
protected:
    storage_class_specifier *m_scs;
public:
    declaration_specifiers_storage_class_specifier(storage_class_specifier *scs) : m_scs(scs) {
        m_scs->set_parent(this);
    }
    virtual ~declaration_specifiers_storage_class_specifier(void) {
        delete m_scs;
    }

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("declaration_specifiers_storage_class_specifier::add_to_symbol_table.\n");
        return NULL;
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool is_typedef(void) const {
        return m_scs->is_typedef();
    }

    virtual void print(void) const {
        m_scs->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_scs,tr);
        return tr;
    }

    virtual type_specifier * get_type_specifier(void) const {
        return NULL;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return NULL;
    }

    virtual bool is_static(void) {
        return m_scs->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_scs = m_scs->remove_static();
            if(!m_scs) {
                delete this;
                return NULL;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        declaration_specifiers *copy = new declaration_specifiers_storage_class_specifier(m_scs->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool has_noreturn(void) {
        return false;
    }

    AST_DEF_CHILDREN_1(m_scs)
};

class declaration_specifiers_storage_class_specifier_declaration_specifiers : public declaration_specifiers {
protected:
    storage_class_specifier *m_scs;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_storage_class_specifier_declaration_specifiers(storage_class_specifier *scs,declaration_specifiers *ds) : m_scs(scs), m_ds(ds) {
        m_scs->set_parent(this);
        m_ds->set_parent(this);
    }
    virtual ~declaration_specifiers_storage_class_specifier_declaration_specifiers(void) {
        delete m_scs;
        delete m_ds;
    }

//    bool is_typedef(void) const;

    ii_ptr  add_to_symbol_table(void) const {
        return m_ds->add_to_symbol_table();
    }

    virtual bool is_volatile(void) {
        return m_ds->is_volatile();
    }

    virtual bool is_typedef(void) const {
        return m_scs->is_typedef();
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual void print(void) const {
        m_scs->print();
        oprintf(" ");
        m_ds->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_scs,tr1);
        TRANSLATE(m_ds,tr2);
        return TranslateResult();
    }

    virtual type_specifier * get_type_specifier(void) const {
        return m_ds->get_type_specifier();
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return m_ds->gen_specifier_qualifier_list();
    }

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual bool is_static(void) {
        return m_scs->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_scs = m_scs->remove_static();
            if(!m_scs) {
                declaration_specifiers *ret = m_ds;
                ret->set_parent(get_parent());
                m_ds = NULL;
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        declaration_specifiers *copy = new declaration_specifiers_storage_class_specifier_declaration_specifiers(m_scs->clone(),m_ds->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_scs,m_ds)
};

class declaration_specifiers_type_specifier : public declaration_specifiers {
protected:
    type_specifier *m_ts;
public:
    declaration_specifiers_type_specifier(type_specifier *ts);
    virtual ~declaration_specifiers_type_specifier(void);

    ii_ptr  add_to_symbol_table(void) const;

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return m_ts;
    }
    virtual bool is_void(void);

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void);

    virtual bool declares_name(const char *name);

    virtual bool is_static(void) {
        return false;
    }

    virtual declaration_specifiers * remove_static(void) {
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool has_noreturn(void) {
        return false;
    }

    virtual bool is_this_int(void);
    virtual bool is_this_long(void);
    virtual bool is_this_double(void);

    AST_DEF_CHILDREN_1(m_ts)
};

class declaration_specifiers_type_specifier_declaration_specifiers : public declaration_specifiers {
protected:
    type_specifier *m_ts;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_type_specifier_declaration_specifiers(type_specifier *ts,declaration_specifiers *ds);
    virtual ~declaration_specifiers_type_specifier_declaration_specifiers(void);

    ii_ptr  add_to_symbol_table(void) const {
        return m_ds->add_to_symbol_table();
    }

    virtual bool is_typedef(void) const {
        return m_ds->is_typedef();
    }

    virtual bool is_volatile(void) {
        return m_ds->is_volatile();
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        type_specifier *ts = m_ds->get_type_specifier();
        if(ts) return ts;
        else   return m_ts;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void);

    virtual bool is_static(void) {
        return m_ds->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_ds = m_ds->remove_static();
            if(!m_ds) {
                type_specifier *ts = m_ts;
                m_ts = NULL;
                declaration_specifiers *ret = new declaration_specifiers_type_specifier(ts);
                ret->set_parent(get_parent());
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    virtual bool is_this_int(void);
    virtual bool is_this_long(void);
    virtual bool is_this_double(void);

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    virtual AST_node * remove_volatile(void) {
        declaration_specifiers  *ds = (declaration_specifiers*)m_ds->remove_volatile();
        if(ds) {
            m_ds = ds;
            return this;
        } else {
            delete m_ds;
            m_ds = NULL;
            type_specifier *ts = m_ts;
            m_ts = NULL;
            delete this;
            return new declaration_specifiers_type_specifier(ts);
        }
    }

    AST_DEF_CHILDREN_2(m_ts,m_ds)
};

class declaration_specifiers_mrv : public declaration_specifiers {
protected:
    multiple_ret_value *m_ts;
public:
    declaration_specifiers_mrv(multiple_ret_value *ts);
    virtual ~declaration_specifiers_mrv(void);

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("declaration_specifiers_mrv::add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual void print(void) const {
        aeprintf("declaration_specifiers_mrv::print\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        assert(0);
        return NULL;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        aeprintf("declaration_specifiers_mrv::gen_specifier_qualifer_list\n");
    }

    virtual bool is_static(void) {
        return false;
    }

    virtual declaration_specifiers * remove_static(void) {
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        aeprintf("declaration_specifiers_mrv::clone\n");
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool has_noreturn(void) {
        return false;
    }

    AST_DEF_CHILDREN_1(m_ts)
};

class declaration_specifiers_mrv_declaration_specifiers : public declaration_specifiers {
protected:
    multiple_ret_value *m_ts;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_mrv_declaration_specifiers(multiple_ret_value *ts,declaration_specifiers *ds);
    virtual ~declaration_specifiers_mrv_declaration_specifiers(void);

    ii_ptr  add_to_symbol_table(void) const {
        return m_ds->add_to_symbol_table();
    }

    virtual bool is_volatile(void) {
        return m_ds->is_volatile();
    }

    virtual bool is_typedef(void) const {
        return m_ds->is_typedef();
    }

    virtual void print(void) const {
        aeprintf("declaration_specifiers_mrv::print\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return m_ds->get_type_specifier();
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        aeprintf("declaration_specifiers_mrv::gen_specifier_qualifer_list\n");
    }

    virtual bool is_static(void) {
        return m_ds->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_ds = m_ds->remove_static();
            if(!m_ds) {
                multiple_ret_value *ts = m_ts;
                m_ts = NULL;
                declaration_specifiers *ret = new declaration_specifiers_mrv(ts);
                ret->set_parent(get_parent());
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        aeprintf("declaration_specifiers_mrv::clone\n");
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_ts,m_ds)
};

class declaration_specifiers_type_qualifier : public declaration_specifiers {
protected:
    type_qualifier *m_tq;
public:
    declaration_specifiers_type_qualifier(type_qualifier *tq);
    virtual ~declaration_specifiers_type_qualifier(void);

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("declaration_specifiers_type_qualifer::add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual bool is_volatile(void);

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return NULL;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void);

    virtual bool is_static(void) {
        return false;
    }

    virtual declaration_specifiers * remove_static(void) {
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool has_noreturn(void) {
        return false;
    }

    virtual AST_node * remove_volatile(void);

    AST_DEF_CHILDREN_1(m_tq)
};

class declaration_specifiers_type_qualifier_declaration_specifiers : public declaration_specifiers {
protected:
    type_qualifier *m_tq;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_type_qualifier_declaration_specifiers(type_qualifier *tq,declaration_specifiers *ds);
    virtual ~declaration_specifiers_type_qualifier_declaration_specifiers(void);

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return m_ds->is_typedef();
    }

    virtual bool is_volatile(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return m_ds->get_type_specifier();
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void);

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual bool is_static(void) {
        return m_ds->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_ds = m_ds->remove_static();
            if(!m_ds) {
                type_qualifier *tq = m_tq;
                m_tq = NULL;
                declaration_specifiers *ret = new declaration_specifiers_type_qualifier(tq);
                ret->set_parent(get_parent());
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_tq,m_ds)
};

class declaration_specifiers_function_specifier : public declaration_specifiers {
protected:
    function_specifier *m_fs;
public:
    declaration_specifiers_function_specifier(function_specifier *fs);
    virtual ~declaration_specifiers_function_specifier(void);

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return NULL;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return NULL;
    }

    virtual bool is_static(void) {
        return false;
    }

    virtual declaration_specifiers * remove_static(void) {
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool has_noreturn(void);

    AST_DEF_CHILDREN_1(m_fs)
};

class declaration_specifiers_function_specifier_declaration_specifiers : public declaration_specifiers {
protected:
    function_specifier *m_fs;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_function_specifier_declaration_specifiers(function_specifier *fs,declaration_specifiers *ds);
    virtual ~declaration_specifiers_function_specifier_declaration_specifiers(void);

    ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return m_ds->is_typedef();
    }

    virtual bool is_volatile(void) {
        return m_ds->is_volatile();
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return m_ds->get_type_specifier();
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return m_ds->gen_specifier_qualifier_list();
    }

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual bool is_static(void) {
        return m_ds->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_ds = m_ds->remove_static();
            if(!m_ds) {
                function_specifier *fs = m_fs;
                m_fs = NULL;
                declaration_specifiers *ret = new declaration_specifiers_function_specifier(fs);
                ret->set_parent(get_parent());
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void);

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual bool has_noreturn(void);

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_fs,m_ds)
};

class declaration_specifiers_gcc_attribute : public declaration_specifiers {
protected:
    std::string m_s;
public:
    declaration_specifiers_gcc_attribute(const char *s) : m_s(s) {}
    virtual ~declaration_specifiers_gcc_attribute(void) {}

    ii_ptr  add_to_symbol_table(void) const {
//        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual bool is_typedef(void) const {
        return false;
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual void print(void) const {
        oprintf("%s",m_s.c_str());
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual type_specifier * get_type_specifier(void) const {
        return NULL;
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return NULL;
    }

    virtual bool is_static(void) {
        return false;
    }

    virtual declaration_specifiers * remove_static(void) {
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        aeprintf("\n");
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append);

    virtual bool has_noreturn(void) {
        aeprintf("FIX\n");
        return false;
    }
};

class declaration_specifiers_gcc_attribute_declaration_specifiers : public declaration_specifiers {
protected:
    std::string m_s;
    declaration_specifiers  *m_ds;
public:
    declaration_specifiers_gcc_attribute_declaration_specifiers(const char *s,declaration_specifiers *ds);
    virtual ~declaration_specifiers_gcc_attribute_declaration_specifiers(void);

    ii_ptr  add_to_symbol_table(void) const {
        return m_ds->add_to_symbol_table();
    }

    virtual bool is_typedef(void) const {
        return m_ds->is_typedef();
    }

    virtual bool is_volatile(void) {
        return m_ds->is_volatile();
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual type_specifier * get_type_specifier(void) const {
        return m_ds->get_type_specifier();
    }

    virtual specifier_qualifier_list *gen_specifier_qualifier_list(void) {
        return m_ds->gen_specifier_qualifier_list();
    }

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual bool is_static(void) {
        return m_ds->is_static();
    }

    virtual declaration_specifiers * remove_static(void) {
        if(is_static()) {
            m_ds = m_ds->remove_static();
            if(!m_ds) {
                std::string s = m_s;
                declaration_specifiers *ret = new declaration_specifiers_gcc_attribute(s.c_str());
                ret->set_parent(get_parent());
                delete this;
                return ret;
            }
        }
        return this;
    }

    virtual declaration_specifiers * clone(void) {
        aeprintf("\n");
    }

    virtual declaration_specifiers * append(declaration_specifiers *to_append) {
        m_ds = m_ds->append(to_append);
        return this;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    virtual declaration_specifiers * remove_first(void) {
        declaration_specifiers *ret = m_ds;
        m_ds = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_1(m_ds)
};

// ====================================================================

class direct_declarator : public AST_node {
public:
    virtual ~direct_declarator (void) {}
    virtual ii_ptr  add_to_symbol_table(bool is_typedef) = 0;
    virtual ii_ptr  add_to_symbol_table(symbol_type st) = 0;
    virtual void print(void) const = 0;
    virtual PILLAR2C_CALLCONV get_call_conv(void) = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual direct_declarator * clone(void) = 0;
    virtual bool is_regular_function(void) const { return false; }
    virtual direct_declarator * prepend_params(parameter_list *pl) {
        aeprintf("prepend_params called for something that isn't a function.\n");
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) = 0;

    virtual Scope * get_param_scope(void) {
        aeprintf("direct_declarator::get_param_scope not overloaded for %s.\n",typeid(this).name());
    }

#if 1
    virtual std::string get_name(void) {
        aeprintf("direct_declarator::get_name not overloaded for %s.\n",typeid(this).name());
    }
#endif

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        print();
        printf("\n");
        aeprintf("vectorize_params not overridden for some sub-class of direct_declarator.\n");
    }

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces) {
        print();
        aeprintf("direct_declarator::clone_for_struct_decl not overloaded for %s.\n",typeid(this).name());
    }

    virtual bool is_array(void) const {
        return false;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        aeprintf("direct_declarator::gen_postfix_expression_for_init not overloaded for %s.\n",typeid(this).name());
    }

    virtual unary_expression * gen_unary_expression_for_init(unsigned index) {
        return new unary_expression_postfix_expression(gen_postfix_expression_for_init(index));
    }

    virtual abstract_declarator * gen_abstract_declarator(void) {
        return NULL;
    }

    virtual bool is_pointer(void) {
        return false;
    }

    virtual direct_abstract_declarator * gen_direct_abstract_declarator(void) {
        aeprintf("direct_declarator::gen_direct_abstract_declarator not overloaded for %s.\n",typeid(this).name());
    }

    virtual abstract_declarator * gen_func_type(void) {
        aeprintf("direct_declarator::gen_func_type not overloaded for %s.\n",typeid(this).name());
    }
};

postfix_expression * gen_pseudo_pe(const std::string &pseudo_field, AST_node *node);

class direct_declarator_IDENTIFIER : public direct_declarator {
protected:
    ii_ptr m_ii;
public:
    direct_declarator_IDENTIFIER(ii_ptr ii) : m_ii(ii) {}

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        if(g_scope_stack.in_current_scope(m_ii)) {
            if(m_ii->add(st)) {
                aeprintf("Incompatible type redeclaration.\n");
            }
        } else {
            m_ii = g_scope_stack.add_symbol(m_ii->get_string(),st);
        }
        return m_ii;
    }

    virtual ii_ptr  get_ii(void) {
        return m_ii;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        symbol_type st = is_typedef ? IIT_TYPEDEF_VAR : IIT_VAR;
        return add_to_symbol_table(st);
    }

    virtual direct_declarator * clone(void) {
        direct_declarator *copy = new direct_declarator_IDENTIFIER(m_ii);
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        oprintf((char*)m_ii->get_name());
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        if(m_ii->get_declarator().size() == 0) {
            m_ii->set_declarator(search_up_for_type<declarator>(this));
        }
        PILLAR2C_CALLCONV ret = m_ii->get_function_cc();
        if(ret == ST_NOT_DEFINED) {
            ret = fix_cc_default(ST_NOT_DEFINED);
            m_ii->set_function_cc(ret);
        }
        return ret;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        std::list<ii_ptr > the_list;
        the_list.push_back(m_ii);
        return the_list;
    }

#if 1
    virtual std::string get_name(void) {
        return m_ii->get_string();
    }
#endif

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces) {
        return new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(new_name));
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        const char *rfn = m_ii->get_qualified_ref_field_name();
        if(rfn) {
            return new postfix_expression_postfix_expression_dot_identifier(
                     new postfix_expression_postfix_expression_dot_identifier(
                       gen_pseudo_pe("prt_refs_and_array",this),
                       "prt_refs"),
                     rfn);
        } else {
            return new postfix_expression_primary_expression(new primary_expression_identifier(m_ii));
        }
    }

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);
    virtual direct_abstract_declarator * gen_direct_abstract_declarator(void) {
        return NULL;
    }
};

class direct_declarator_paren_declarator : public direct_declarator {
protected:
    declarator *m_d;
public:
    direct_declarator_paren_declarator(declarator *d);
    virtual ~direct_declarator_paren_declarator(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef);
    virtual ii_ptr  add_to_symbol_table(symbol_type st);
    virtual void print(void) const;
    virtual PILLAR2C_CALLCONV get_call_conv(void);
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::string get_name(void);
    virtual std::list<ii_ptr > get_enclosing_symbols(void);
    virtual direct_declarator * clone(void);

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces);

    virtual declarator *get_declarator(void) {
        return m_d;
    }
    virtual abstract_declarator * gen_abstract_declarator(void);
    virtual direct_abstract_declarator * gen_direct_abstract_declarator(void);
    virtual bool is_pointer(void);

    virtual bool is_regular_function(void) const;
    virtual Scope * get_param_scope(void);
    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);
    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc);

    AST_DEF_CHILDREN_1(m_d)
};

class direct_declarator_direct_declarator_type_qualifier_list_assignment_expression : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    type_qualifier_list   *m_tql;
    assignment_expression *m_ae;
public:
    direct_declarator_direct_declarator_type_qualifier_list_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae);
    virtual ~direct_declarator_direct_declarator_type_qualifier_list_assignment_expression(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_3(m_dd,m_tql,m_ae)
};

class direct_declarator_direct_declarator_type_qualifier_list : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    type_qualifier_list   *m_tql;
public:
    direct_declarator_direct_declarator_type_qualifier_list(direct_declarator *dd,type_qualifier_list *tql);
    virtual ~direct_declarator_direct_declarator_type_qualifier_list(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_2(m_dd,m_tql)
};

class direct_declarator_direct_declarator_assignment_expression : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    assignment_expression *m_ae;
public:
    direct_declarator_direct_declarator_assignment_expression(direct_declarator *dd,assignment_expression *ae) : m_dd(dd), m_ae(ae) {
        m_dd->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~direct_declarator_direct_declarator_assignment_expression(void) {
        delete m_dd;
        delete m_ae;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces) {
        assert(remove_braces);
        return m_dd->clone_for_struct_decl(new_name,remove_braces);
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        std::stringstream index_as_char;
        index_as_char << index;
        return new postfix_expression_postfix_expression_brace_expression(
                 m_dd->gen_postfix_expression_for_init((unsigned)-1),
                 new expression_assignment_expression(
                  expr_gen(assignment_expression,primary_expression,new primary_expression_constant(index_as_char.str()))));
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_2(m_dd,m_ae)
};

class direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    type_qualifier_list   *m_tql;
    assignment_expression *m_ae;
public:
    direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae);
    virtual ~direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_3(m_dd,m_tql,m_ae)
};

class direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    type_qualifier_list   *m_tql;
    assignment_expression *m_ae;
public:
    direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae);
    virtual ~direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_3(m_dd,m_tql,m_ae)
};

class direct_declarator_direct_declarator_type_qualifier_list_star : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    type_qualifier_list   *m_tql;
public:
    direct_declarator_direct_declarator_type_qualifier_list_star(direct_declarator *dd,type_qualifier_list *tql);
    virtual ~direct_declarator_direct_declarator_type_qualifier_list_star(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_2(m_dd,m_tql)
};

class direct_declarator_direct_declarator_star : public direct_declarator {
protected:
    direct_declarator     *m_dd;
public:
    direct_declarator_direct_declarator_star(direct_declarator *dd) : m_dd(dd) {
        m_dd->set_parent(this);
    }
    virtual ~direct_declarator_direct_declarator_star(void) {
        delete m_dd;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        aeprintf("add_to_symbol_table\n");
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        aeprintf("add_to_symbol_table\n");
        return NULL;
    }

    virtual direct_declarator * clone(void) {
        direct_declarator *copy = new direct_declarator_direct_declarator_star(m_dd->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        m_dd->print();
        oprintf(" [*] ");
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_dd,tr);
        return tr;
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }

    AST_DEF_CHILDREN_1(m_dd)
};

class direct_declarator_direct_declarator_empty_brace : public direct_declarator {
protected:
    direct_declarator     *m_dd;
public:
    direct_declarator_direct_declarator_empty_brace(direct_declarator *dd) : m_dd(dd) {
        m_dd->set_parent(this);
    }
    virtual ~direct_declarator_direct_declarator_empty_brace(void) {
        delete m_dd;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        return m_dd->add_to_symbol_table(st);
    }

    virtual direct_declarator * clone(void) {
        direct_declarator *copy = new direct_declarator_direct_declarator_empty_brace(m_dd->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        m_dd->print();
        oprintf(" [ ] ");
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_dd,tr);
        return tr;
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces) {
        assert(remove_braces);
        return m_dd->clone_for_struct_decl(new_name,remove_braces);
    }

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual bool is_array(void) const {
        return true;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        std::stringstream index_as_char;
        index_as_char << index;
        return new postfix_expression_postfix_expression_brace_expression(
                 m_dd->gen_postfix_expression_for_init((unsigned)-1),
                 new expression_assignment_expression(
                  expr_gen(assignment_expression,primary_expression,new primary_expression_constant(index_as_char.str()))));
    }

    AST_DEF_CHILDREN_1(m_dd)
};

class direct_declarator_direct_declarator_parameter_type_list : public direct_declarator {
protected:
    direct_declarator     *m_dd;
    parameter_type_list   *m_ptl;
public:
    direct_declarator_direct_declarator_parameter_type_list(direct_declarator *dd,parameter_type_list *ptl);
    virtual ~direct_declarator_direct_declarator_parameter_type_list(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef);

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool is_regular_function(void) const {
        return !m_dd->is_regular_function();
    }

    virtual direct_declarator * prepend_params(parameter_list *pl);

    virtual Scope * get_param_scope(void) {
        assert(m_scope);
        return m_scope;
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);

    virtual expression_type * get_return_type(void) {
        return m_dd->get_return_type();
    }
    virtual direct_declarator * clone(void);
    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces);

    virtual abstract_declarator * gen_abstract_declarator(void);
    virtual direct_abstract_declarator * gen_direct_abstract_declarator(void);
    virtual abstract_declarator * gen_func_type(void);

    AST_DEF_CHILDREN_2(m_dd,m_ptl)
};

class direct_declarator_direct_declarator_identifier_list : public direct_declarator {
protected:
    direct_declarator *m_dd;
    identifier_list   *m_il;
public:
    direct_declarator_direct_declarator_identifier_list(direct_declarator *dd,identifier_list *il);
    virtual ~direct_declarator_direct_declarator_identifier_list(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef);

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }
    virtual direct_declarator * clone(void);

    AST_DEF_CHILDREN_2(m_dd,m_il)
};

class direct_declarator_direct_declarator_empty_paren : public direct_declarator {
protected:
    direct_declarator     *m_dd;
public:
    direct_declarator_direct_declarator_empty_paren(direct_declarator *dd) : m_dd(dd) {
        m_dd->set_parent(this);
    }
    virtual ~direct_declarator_direct_declarator_empty_paren(void) {
        delete m_dd;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef);

    virtual ii_ptr  add_to_symbol_table(symbol_type st) {
        return m_dd->add_to_symbol_table(st);
    }

    virtual direct_declarator * clone(void) {
        direct_declarator *copy = new direct_declarator_direct_declarator_empty_paren(m_dd->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        m_dd->print();
        oprintf(" ( ) ");
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool is_regular_function(void) const {
        return !m_dd->is_regular_function();
    }

    virtual direct_declarator * prepend_params(parameter_list *pl);

    virtual Scope * get_param_scope(void) {
        return NULL;
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        ellipsis = false;
    }

    virtual direct_abstract_declarator * gen_direct_abstract_declarator(void);

    AST_DEF_CHILDREN_1(m_dd)
};

// ====================================================================

class declarator : public AST_node {
protected:
    bool m_suppress_explicit_call_conv;
    bool m_proxy_explicit_call_conv;
public:
    declarator(void) : m_suppress_explicit_call_conv(false), m_proxy_explicit_call_conv(false) {}
    virtual ~declarator (void) {}
    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const = 0;
    virtual ii_ptr  add_to_symbol_table(symbol_type st) const = 0;
    virtual void print(void) const = 0;
    virtual PILLAR2C_CALLCONV get_call_conv(void) = 0;
    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        return get_call_conv();
    }
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        aeprintf("Some class didn't override add_explicit_call_conv.\n");
    }
    virtual bool is_regular_function(void) const = 0;
    virtual void prepend_params(parameter_list *pl) = 0;
    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        aeprintf("Some class didn't override get_param_scope.\n");
    }
    virtual std::list<ii_ptr > get_enclosing_symbols(void) = 0;
#if 1
    virtual std::string get_one_name(void) {
        std::list<ii_ptr> the_list = get_enclosing_symbols();
        if(the_list.size() != 1) {
            aeprintf("get_one_name\n");
        }
        return the_list.front()->get_string();
    }
#endif
    virtual void suppress_declarator_explicit_call_conv(void) {
        m_suppress_explicit_call_conv = true;
    }
    virtual void proxy_explicit_call_conv(void) {
        m_proxy_explicit_call_conv = true;
    }

    virtual bool declares_name(const char *name) {
        std::string sname(name);
        std::list<ii_ptr > declared_names = get_enclosing_symbols();
        std::list<ii_ptr >::iterator iter;
        for(iter  = declared_names.begin();
            iter != declared_names.end();
          ++iter) {
          if((*iter)->get_string() == sname) {
              return true;
          }
        }
        return false;
    }

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        aeprintf("vectorize_params\n");
    }

    virtual struct_declarator * gen_struct_declarator(std::string arg_name) {
        aeprintf("declarator::gen_struct_declarator not overloaded for %s.\n",typeid(this).name());
    }

    virtual abstract_declarator * gen_abstract_declarator(void) {
        aeprintf("declarator::gen_abstract_declarator not overloaded for %s.\n",typeid(this).name());
    }

    virtual abstract_declarator * gen_abstract_declarator_for_type(void) {
        return gen_abstract_declarator();
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) = 0;

    virtual bool is_pointer(void) const { return false; }
    virtual declarator * clone(void) = 0;
    virtual direct_declarator * get_direct_declarator(void) = 0;

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces) {
        print();
        printf("\n");
        aeprintf("declarator::clone_for_struct_decl not overloaded for %s.\n",typeid(this).name());
    }

    virtual expression_type * get_type(void) {
        declaration *decl = search_up_for_type<declaration>(this);
        if(!decl) {
            aeprintf("Could not find the declaration corresponding to a declarator.\n");
        }

        expression_type *ret = new expression_type;

        ret->m_sql = decl->get_declaration_specifiers()->gen_specifier_qualifier_list();

        std::list<ii_ptr> the_list = get_enclosing_symbols();
        if(the_list.size() == 0) {
            aeprintf("get_type has no name\n");
        }

        ret->m_ad  = decl->get_declarator_with_name(the_list.front()->get_string().c_str())->gen_abstract_declarator();

        return ret;
    }
};

class declarator_pointer_direct_declarator : public declarator {
protected:
    pointer *m_p;
    direct_declarator *m_dd;
    std::string m_s;
public:
    declarator_pointer_direct_declarator(pointer *p,direct_declarator *dd,const std::string &s="");
    virtual ~declarator_pointer_direct_declarator(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) const {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc);

    virtual bool is_regular_function(void) const {
        return m_dd->is_regular_function();
    }

    virtual void prepend_params(parameter_list *pl) {
        m_dd->prepend_params(pl);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        return m_dd->get_param_scope();
    }
    virtual std::string get_name(void) {
        return m_dd->get_name();
    }
    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_dd->vectorize_params(params,ellipsis);
    }

    virtual struct_declarator * gen_struct_declarator(std::string arg_name);
    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        return m_dd->gen_postfix_expression_for_init(index);
    }

    virtual bool is_pointer(void) const { return true; }

    virtual declarator * clone(void);

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces);

    virtual direct_declarator * get_direct_declarator(void) {
        return m_dd;
    }

    AST_DEF_CHILDREN_2(m_p,m_dd)
};

class declarator_direct_declarator : public declarator {
protected:
    direct_declarator *m_dd;
    std::string m_s;
public:
    declarator_direct_declarator(direct_declarator *dd,const std::string &s="") :
        m_dd(dd),
        m_s(s) {
        m_dd->set_parent(this);
    }
    virtual ~declarator_direct_declarator(void) {
        delete m_dd;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) const {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const {
        if(m_s != "") {
            oprintf("%s ",m_s.c_str());
        }
        m_dd->print();
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dd->get_call_conv();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc);

    virtual bool is_regular_function(void) const {
        return m_dd->is_regular_function();
    }

    virtual void prepend_params(parameter_list *pl) {
        m_dd->prepend_params(pl);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        return m_dd->get_param_scope();
    }

    virtual direct_declarator * get_direct_declarator(void) const {
        return m_dd;
    }
    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_dd->vectorize_params(params,ellipsis);
    }

    virtual struct_declarator * gen_struct_declarator(std::string arg_name);

    virtual abstract_declarator * gen_abstract_declarator(void);

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        return m_dd->gen_postfix_expression_for_init(index);
    }

    virtual declarator * clone(void) {
        declarator *copy = new declarator_direct_declarator(m_dd->clone(),m_s);
        copy->clone_copy(this);
        return copy;
    }

    virtual direct_declarator * get_direct_declarator(void) {
        return m_dd;
    }

    virtual bool is_pointer(void) const {
        return m_dd->is_pointer();
    }

    AST_DEF_CHILDREN_1(m_dd)
};

class declarator_pointer_call_conv_specifier_direct_declarator : public declarator {
protected:
    pointer *m_p;
    call_conv_specifier *m_ccs;
    direct_declarator *m_dd;
    bool m_post_translate;
    std::string m_s;
public:
    declarator_pointer_call_conv_specifier_direct_declarator(pointer *p,call_conv_specifier *ccs,direct_declarator *dd,const std::string &s="");
    virtual ~declarator_pointer_call_conv_specifier_direct_declarator(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) const {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;
    virtual PILLAR2C_CALLCONV get_call_conv(void);
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        return this;
    }

    virtual bool is_regular_function(void) const {
        return m_dd->is_regular_function();
    }

    virtual void prepend_params(parameter_list *pl) {
        m_dd->prepend_params(pl);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        return m_dd->get_param_scope();
    }

    virtual std::string get_name(void) {
        return m_dd->get_name();
    }

    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_dd->vectorize_params(params,ellipsis);
    }

    virtual abstract_declarator * gen_abstract_declarator_for_type(void);
    virtual abstract_declarator * gen_abstract_declarator(void) {
        return gen_abstract_declarator_for_type();
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        return m_dd->gen_postfix_expression_for_init(index);
    }

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces);

    virtual bool is_pointer(void) const { return true; }

    virtual declarator * clone(void);

    virtual direct_declarator * get_direct_declarator(void) {
        return m_dd;
    }

    AST_DEF_CHILDREN_3(m_p,m_ccs,m_dd)
};

class declarator_call_conv_specifier_pointer_direct_declarator : public declarator {
protected:
    call_conv_specifier *m_ccs;
    pointer *m_p;
    direct_declarator *m_dd;
    bool m_post_translate;
    std::string m_s;
public:
    declarator_call_conv_specifier_pointer_direct_declarator(call_conv_specifier *ccs,pointer *p,direct_declarator *dd,const std::string &s="");
    virtual ~declarator_call_conv_specifier_pointer_direct_declarator(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) const {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;
    virtual PILLAR2C_CALLCONV get_call_conv(void);
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        return this;
    }

    virtual bool is_regular_function(void) const {
        return m_dd->is_regular_function();
    }

    virtual void prepend_params(parameter_list *pl) {
        m_dd->prepend_params(pl);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        return m_dd->get_param_scope();
    }
    virtual std::string get_name(void) {
        return m_dd->get_name();
    }
    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_dd->vectorize_params(params,ellipsis);
    }

    virtual abstract_declarator * gen_abstract_declarator_for_type(void);
    virtual abstract_declarator * gen_abstract_declarator(void) {
        return gen_abstract_declarator_for_type();
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        return m_dd->gen_postfix_expression_for_init(index);
    }

    virtual bool is_pointer(void) const { return true; }

    virtual declarator * clone(void);

    virtual AST_node * clone_for_struct_decl(std::string &new_name,bool remove_braces);

    virtual direct_declarator * get_direct_declarator(void) {
        return m_dd;
    }

    AST_DEF_CHILDREN_3(m_ccs,m_p,m_dd)
};

class declarator_call_conv_specifier_direct_declarator : public declarator {
protected:
    call_conv_specifier *m_ccs;
    direct_declarator *m_dd;
    std::string m_s;
public:
    declarator_call_conv_specifier_direct_declarator(call_conv_specifier *ccs,direct_declarator *dd,const std::string &s="");
    virtual ~declarator_call_conv_specifier_direct_declarator(void);

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_dd->add_to_symbol_table(is_typedef);
    }

    virtual ii_ptr  add_to_symbol_table(symbol_type st) const {
        return m_dd->add_to_symbol_table(st);
    }

    virtual void print(void) const;
    virtual PILLAR2C_CALLCONV get_call_conv(void);
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual declarator * add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        return this;
    }

    virtual bool is_regular_function(void) const {
        return m_dd->is_regular_function();
    }

    virtual void prepend_params(parameter_list *pl) {
        m_dd->prepend_params(pl);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_dd->get_enclosing_symbols();
    }

    virtual Scope * get_param_scope(void) {
        if(!is_regular_function()) {
            aeprintf("get_param_scope called for a non-function declarator.\n");
        }
        return m_dd->get_param_scope();
    }
    virtual std::string get_name(void) {
        return m_dd->get_name();
    }
    virtual void vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_dd->vectorize_params(params,ellipsis);
    }

    virtual abstract_declarator * gen_abstract_declarator_for_type(void);
    virtual abstract_declarator * gen_abstract_declarator(void) {
        return gen_abstract_declarator_for_type();
    }

    virtual postfix_expression * gen_postfix_expression_for_init(unsigned index) {
        return m_dd->gen_postfix_expression_for_init(index);
    }

    virtual struct_declarator * gen_struct_declarator(std::string arg_name);

    virtual declarator * clone(void);

    virtual direct_declarator * get_direct_declarator(void) {
        return m_dd;
    }

    AST_DEF_CHILDREN_2(m_ccs,m_dd)
};

// ===============================================================

class init_declarator : public AST_node {
public:
    virtual ~init_declarator (void) {}
    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const = 0;
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) = 0;
    virtual declarator * get_declarator(void) = 0;
    virtual bool declares_name(const char *name) {
        return false;
    }
    virtual init_declarator * clone(void) = 0;
    virtual std::list<ii_ptr > get_enclosing_symbols(void) = 0;
};

class init_declarator_declarator : public init_declarator {
protected:
    declarator *m_d;
public:
    init_declarator_declarator(declarator *d) : m_d(d) {
        m_d->set_parent(this);
    }
    virtual ~init_declarator_declarator(void) {
        delete m_d;
    }

    virtual ii_ptr  add_to_symbol_table(bool is_typedef) const {
        return m_d->add_to_symbol_table(is_typedef);
    }

    virtual void print(void) const {
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_d,tr);

        if(m_d->is_regular_function() && !g_intel64) {
            m_d->add_explicit_call_conv(m_d->get_call_conv());
        }

        return tr;
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        m_d->add_explicit_call_conv(cc);
    }

    virtual declarator * get_declarator(void) {
        return m_d;
    }

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_d) {
            delete m_d;
            m_d = NULL;
            m_parent->sub_destroyed(this);
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual bool declares_name(const char *name) {
        return m_d->declares_name(name);
    }

    virtual init_declarator * clone(void) {
        init_declarator *copy = new init_declarator_declarator(m_d->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_d->get_enclosing_symbols();
    }

    AST_DEF_CHILDREN_1(m_d)
};

class init_declarator_declarator_initializer : public init_declarator_declarator {
protected:
    initializer *m_i;
public:
    init_declarator_declarator_initializer(declarator *d,initializer *i);
    virtual ~init_declarator_declarator_initializer(void);
    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        aeprintf("add_explicit_call_conv\n");
    }

    virtual void sub_destroyed(AST_node *node);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        if((AST_node*)m_i == child) return LRB_RVALUE;
        if(m_d == child) return LRB_LVALUE;
        aeprintf("init_declarator_declarator_initializer is_lvalue got a child not equal to m_i or m_d\n");
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        if((AST_node*)m_i == child) return false;
        if(m_d == child) return true;
        aeprintf("init_declarator_declarator_initializer is_lvalue got a child not equal to m_i or m_d\n");
        return false;
    }
#endif

    virtual init_declarator * clone(void);

    virtual initializer * get_initializer(void) const {
        return m_i;
    }

    virtual unsigned get_num_children(void) const { return 2; }
    virtual AST_node **begin_child_iter(void) const {
        return (AST_node**)&m_d;
    }
    virtual AST_node **next_child_iter(AST_node **cur) const {
        if(cur == (AST_node**)&m_d)
            return (AST_node**)&m_i;
        else if(cur == (AST_node**)&m_i)
            return NULL;
        else aeprintf("next_child_iter problem");
    }
//    AST_DEF_CHILDREN_2(m_d,m_i)
};

// ===============================================================

class init_declarator_list : public AST_node {
public:
    virtual ~init_declarator_list (void) {}
    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table(bool is_typedef) const = 0;
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) = 0;
    virtual bool declares_name(const char *name) = 0;
    virtual init_declarator_list * clone(void) = 0;
    virtual declarator * get_declarator_with_name(const char *name) = 0;
};

class init_declarator_list_init_declarator : public init_declarator_list {
protected:
    init_declarator *m_id;
public:
    init_declarator_list_init_declarator(init_declarator *id) : m_id(id) {
        m_id->set_parent(this);
    }
    virtual ~init_declarator_list_init_declarator(void) {
        delete m_id;
    }

    init_declarator * get_init_declarator(void) const {
        return m_id;
    }

    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table(bool is_typedef) const {
        std::list<std::pair<ii_ptr ,declarator *> > ret;
        ret.push_back(std::pair<ii_ptr,declarator*>(m_id->add_to_symbol_table(is_typedef),m_id->get_declarator()));
        return ret;
    }

    virtual void print(void) const {
        m_id->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_id,tr);
        return tr;
    }

    virtual declarator * get_declarator_with_name(const char *name) {
        if(m_id->declares_name(name)) {
            return m_id->get_declarator();
        }
        return NULL;
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        m_id->add_explicit_call_conv(cc);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_id->get_enclosing_symbols();
    }

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_id) {
            delete m_id;
            m_id = NULL;
            m_parent->sub_destroyed(this);
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual bool declares_name(const char *name) {
        return m_id->declares_name(name);
    }

    virtual init_declarator_list * clone(void) {
        init_declarator_list *copy = new init_declarator_list_init_declarator(m_id->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_id)
};

class init_declarator_list_init_declarator_comma : public init_declarator_list {
protected:
    init_declarator_list *m_idl;
    init_declarator *m_id;
public:
    init_declarator_list_init_declarator_comma(init_declarator_list *idl,
                                               init_declarator *id) :
        m_idl(idl),
        m_id(id) {
        m_idl->set_parent(this);
        m_id->set_parent(this);
    }
    virtual ~init_declarator_list_init_declarator_comma(void) {
        delete m_idl;
        delete m_id;
    }

    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table(bool is_typedef) const {
        std::list<std::pair<ii_ptr ,declarator *> > ret = m_idl->add_to_symbol_table(is_typedef);
        ret.push_back(std::pair<ii_ptr,declarator*>(m_id->add_to_symbol_table(is_typedef),m_id->get_declarator()));
        return ret;
    }

    virtual void print(void) const {
        m_idl->print();
        oprintf(" , ");
        m_id->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_idl,tr1);
        TRANSLATE(m_id,tr2);
        return TranslateResult();
    }

    virtual declarator * get_declarator_with_name(const char *name) {
        if(m_id->declares_name(name)) {
            return m_id->get_declarator();
        } else {
            return m_idl->get_declarator_with_name(name);
        }
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        printf("Let's hope add_explicit_call_conv for init_declarator_list_init_declarator_comma is implemented correctly.\n");
        m_idl->add_explicit_call_conv(cc);
        m_id->add_explicit_call_conv(cc);
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_id->get_enclosing_symbols();
    }

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_id) {
            delete m_id;
            m_id = NULL;

            m_parent->replace(this,m_idl);
        } else if(node == m_idl) {
            delete m_idl;
            m_idl = NULL;

            init_declarator_list_init_declarator *new_node = new
              init_declarator_list_init_declarator(m_id);
            m_parent->replace(this,new_node);

            m_id = NULL;
            delete this;
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual bool declares_name(const char *name) {
        return m_id->declares_name(name) || m_idl->declares_name(name);
    }

    virtual init_declarator_list * clone(void) {
        init_declarator_list *copy = new init_declarator_list_init_declarator_comma(m_idl->clone(),m_id->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_idl,m_id)
};

// ===============================================================

class call_conv_specifier : public AST_node {
public:
    virtual ~call_conv_specifier (void) {}
    virtual void print(void) const = 0;
    virtual PILLAR2C_CALLCONV get_call_conv(void) = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual call_conv_specifier * clone(void) = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class call_conv_specifier_CDECL : public call_conv_specifier {
public:
    virtual void print(void) const {
        if(!g_intel64) {
            if(g_gcc_compatible) {
                oprintf("__attribute__((cdecl))");
            } else {
                oprintf("__cdecl");
            }
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return ST_CDECL;
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_CDECL *copy = new call_conv_specifier_CDECL();
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(!g_intel64) {
            if(g_gcc_compatible) {
                os << "__attribute__((cdecl))";
            } else {
                os << "__cdecl";
            }
        }
        return os;
    }
};

class call_conv_specifier_UCDECL : public call_conv_specifier {
public:
    virtual void print(void) const {
        if(!g_intel64) {
            oprintf("_cdecl");
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return ST_CDECL;
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_UCDECL *copy = new call_conv_specifier_UCDECL();
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(!g_intel64) {
            os << "_cdecl";
        }
        return os;
    }
};

class call_conv_specifier_STDCALL : public call_conv_specifier {
public:
    virtual void print(void) const {
        if(!g_intel64) {
            if(g_gcc_compatible) {
                oprintf("__attribute__((stdcall))");
            } else {
                oprintf("__stdcall");
            }
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return ST_STDCALL;
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_STDCALL *copy = new call_conv_specifier_STDCALL();
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(!g_intel64) {
            if(g_gcc_compatible) {
                os << "__attribute__((stdcall))";
            } else {
                os << "__stdcall";
            }
        }
        return os;
    }
};

class call_conv_specifier_PASCAL : public call_conv_specifier {
public:
    virtual void print(void) const {
        if(!g_intel64) {
            oprintf("__pascal");
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("get_call_conv\n");
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_PASCAL *copy = new call_conv_specifier_PASCAL();
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(!g_intel64) {
            os << "__pascal";
        }
        return os;
    }
};

class call_conv_specifier_PRT_PDECL : public call_conv_specifier {
protected:
    bool m_post_translate;
public:
    call_conv_specifier_PRT_PDECL(void) : m_post_translate(g_translation_started) {}

    virtual void print(void) const {
        if(m_post_translate) {
            if(!g_intel64) {
                if(g_gcc_compatible) {
                    oprintf("__attribute__((stdcall))");
                } else {
                    oprintf("__stdcall");
                }
            }
        } else {
            oprintf("__pdecl");
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return ST_PDECL;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        m_post_translate = true;
        return TranslateResult();
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_PRT_PDECL *copy = new call_conv_specifier_PRT_PDECL();
        copy->m_post_translate = m_post_translate;
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(m_post_translate) {
            if(!g_intel64) {
                if(g_gcc_compatible) {
                    os << "__attribute__((stdcall))";
                } else {
                    os << "__stdcall";
                }
            }
        } else {
            os << "__pdecl";
        }
        return os;
    }
};

class call_conv_specifier_PRT_PCDECL : public call_conv_specifier {
protected:
    bool m_post_translate;
public:
    call_conv_specifier_PRT_PCDECL(void) : m_post_translate(g_translation_started) {}

    virtual void print(void) const {
        if(m_post_translate) {
            if(!g_intel64) {
                if(g_gcc_compatible) {
                    oprintf("__attribute__((cdecl))");
                } else {
                    oprintf("__cdecl");
                }
            }
        } else {
            oprintf("__pcdecl");
        }
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return ST_PCDECL;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        m_post_translate = true;
        return TranslateResult();
    }

    virtual call_conv_specifier * clone(void) {
        call_conv_specifier_PRT_PCDECL *copy = new call_conv_specifier_PRT_PCDECL();
        copy->m_post_translate = m_post_translate;
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        if(m_post_translate) {
            if(!g_intel64) {
                if(g_gcc_compatible) {
                    os << "__attribute__((cdecl))";
                } else {
                    os << "__cdecl";
                }
            }
        } else {
            os << "__pcdecl";
        }
        return os;
    }
};

// ===============================================================

class type_specifier : public AST_node {
public:
    virtual ~type_specifier (void) {}
    virtual ii_ptr  add_to_symbol_table(void) const {
        aeprintf("Don't think add_to_symbol_table should be called for basic types.\n");
        return NULL;
    }
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual bool is_void(void) {
        return false;
    }
    virtual type_specifier * clone(void) const = 0;
    virtual AST_node * vararg_clone(void) const {
        return clone();
    }
    virtual AST_node * param_clone(void) const {
        return clone();
    }

    virtual bool is_struct(Scope *&struct_scope) {
        return false;
    }

    virtual bool declares_name(const char *name) {
        return false;
    }

    virtual bool is_ultimate_prt_ref(void) {
        return false;
    }

    virtual type_specifier_PRT_REF * get_ultimate_prt_ref(void) {
        return NULL;
    }

    virtual bool operator==(const type_specifier *other) {
        if(typeid(*this) == typeid(*other)) {
            return true;
        } else {
            return false;
        }
    }

    virtual std::ostream & strprint(std::ostream &os) const = 0;

    virtual bool is_base_type(void) {
        return true;
    }

    virtual type_specifier * get_base_type(void) {
        // most types are base types except for typename
        return this;
    }

    virtual bool is_float_type(void) const {
        return false;
    }

    virtual bool is_int_type(void) const {
        return false;
    }

    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        return ST_NOT_DEFINED;
    }

    virtual bool param_larger_than_register(void) const {
        return false;
    }

    virtual unsigned get_minimum_size(void) = 0;
    virtual unsigned get_param_size(void) = 0;
};

std::ostream & operator<<(std::ostream &os, const type_specifier &rhs) {
    return rhs.strprint(os);
}

std::ostream & operator<<(std::ostream &os, const struct_or_union_specifier &rhs);
std::ostream & operator<<(std::ostream &os, const struct_or_union &rhs);
std::ostream & operator<<(std::ostream &os, const enum_specifier &rhs);

class type_specifier_VOID : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("void");
    }
    virtual bool is_void(void) {
        return true;
    }
    virtual type_specifier * clone(void) const {
        type_specifier_VOID *copy = new type_specifier_VOID();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "void";
        return os;
    }

    virtual unsigned get_minimum_size(void) {
        throw unknown_size();
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
};

class type_specifier_CHAR : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("char");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_CHAR *copy = new type_specifier_CHAR();
        copy->clone_copy(this);
        return copy;
    }
    virtual AST_node * vararg_clone(void) const;
    virtual AST_node * param_clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "char";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 1;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
};
class type_specifier_SHORT : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("short");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_SHORT *copy = new type_specifier_SHORT();
        copy->clone_copy(this);
        return copy;
    }
    virtual AST_node * vararg_clone(void) const;
    virtual AST_node * param_clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "short";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 2;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
};

class type_specifier_INT : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("int");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_INT *copy = new type_specifier_INT();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "int";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 4;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual AST_node * param_clone(void) const;
};

class type_specifier_INT64 : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("__int64");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_INT64 *copy = new type_specifier_INT64();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "__int64";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual bool param_larger_than_register(void) const {
#ifdef __x86_64__
        return false;
#else
        return true;
#endif
    }

    virtual unsigned get_minimum_size(void) {
        return 8;
    }
    virtual unsigned get_param_size(void) {
        return 8;
    }
};

class type_specifier_INT32 : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("__int32");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_INT32 *copy = new type_specifier_INT32();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "__int32";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 4;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual AST_node * param_clone(void) const;
};

class type_specifier_INT16 : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("__int16");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_INT16 *copy = new type_specifier_INT16();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "__int16";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 2;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual AST_node * param_clone(void) const;
};

class type_specifier_INT8 : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("__int8");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_INT8 *copy = new type_specifier_INT8();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "__int8";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 1;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual AST_node * param_clone(void) const;
};

class type_specifier_LONG : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("long");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_LONG *copy = new type_specifier_LONG();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "long";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual unsigned get_minimum_size(void) {
#ifdef __x86_64__
        return 8;
#else  // __x86_64__
        return 4;
#endif // __x86_64__
    }
};

class type_specifier_LONG_LONG : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("long long");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_LONG_LONG *copy = new type_specifier_LONG_LONG();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "long long";
        return os;
    }

    virtual bool param_larger_than_register(void) const {
#ifdef __x86_64__
        return false;
#else
        return true;
#endif
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_param_size(void) {
        return 8;
    }

    virtual unsigned get_minimum_size(void) {
        return 8;
    }
};

class type_specifier_FLOAT : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("float");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_FLOAT *copy = new type_specifier_FLOAT();
        copy->clone_copy(this);
        return copy;
    }
    virtual AST_node * vararg_clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "float";
        return os;
    }

    virtual bool is_float_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 4;
    }
    virtual AST_node * param_clone(void) const;
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
};

class type_specifier_DOUBLE : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("double");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_DOUBLE *copy = new type_specifier_DOUBLE();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "double";
        return os;
    }

    virtual bool is_float_type(void) const {
        return true;
    }

    virtual bool param_larger_than_register(void) const {
#ifdef __x86_64__
        return false;
#else
        return true;
#endif
    }

    virtual unsigned get_minimum_size(void) {
        return 8;
    }
    virtual unsigned get_param_size(void) {
        return 8;
    }
};

class type_specifier_LONG_DOUBLE : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("long double");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_LONG_DOUBLE *copy = new type_specifier_LONG_DOUBLE();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "long double";
        return os;
    }

    virtual bool is_float_type(void) const {
        return true;
    }

    virtual bool param_larger_than_register(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        throw unknown_size();
    }

    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
};

class type_specifier_SIGNED : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("signed");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_SIGNED *copy = new type_specifier_SIGNED();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "signed";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 4;
    }
    virtual AST_node * param_clone(void) const;
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
};

class type_specifier_UNSIGNED : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("unsigned");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_UNSIGNED *copy = new type_specifier_UNSIGNED();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "unsigned";
        return os;
    }

    virtual bool is_int_type(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        return 4;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    virtual AST_node * param_clone(void) const;
};

class type_specifier_BUILTIN_VA_LIST : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("__builtin_va_list");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_BUILTIN_VA_LIST *copy = new type_specifier_BUILTIN_VA_LIST();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "__builtin_va_list";
        return os;
    }

    virtual bool param_larger_than_register(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
};

class type_specifier_BOOL : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("_Bool");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_BOOL *copy = new type_specifier_BOOL();
        copy->clone_copy(this);
        return copy;
    }
    virtual AST_node * vararg_clone(void) const {
        type_specifier_INT *copy = new type_specifier_INT();
        copy->clone_copy(this);
        return copy;
    }
    virtual AST_node * param_clone(void) const {
#ifdef __x86_64__
        type_specifier_LONG *copy = new type_specifier_LONG();
        copy->clone_copy(this);
        return copy;
#else  // __x86_64__
        type_specifier_INT *copy = new type_specifier_INT();
        copy->clone_copy(this);
        return copy;
#endif // __x86_64__
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "_Bool";
        return os;
    }

    virtual unsigned get_minimum_size(void) {
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
};

class type_specifier_COMPLEX : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("_Complex");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_COMPLEX *copy = new type_specifier_COMPLEX();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "_Complex";
        return os;
    }

    virtual bool param_larger_than_register(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
};

class type_specifier_IMAGINARY : public type_specifier {
public:
    virtual void print(void) const {
        oprintf("_Imaginary");
    }
    virtual type_specifier * clone(void) const {
        type_specifier_IMAGINARY *copy = new type_specifier_IMAGINARY();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "_Imaginary";
        return os;
    }

    virtual bool param_larger_than_register(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
};

class type_specifier_TYPE_NAME : public type_specifier {
protected:
    ii_ptr m_ii;
public:
    type_specifier_TYPE_NAME(ii_ptr ii) : m_ii(ii) {}

    virtual void print(void) const {
        oprintf((char*)m_ii->get_name());
    }

    virtual ii_ptr  add_to_symbol_table(void) const {
        return m_ii;
    }

    virtual ii_ptr  get_id_info(void) const {
        return m_ii;
    }

    virtual bool is_base_type(void) {
        return false;
    }

    virtual type_specifier * get_base_type(void) {
        type_specifier *ts = m_ii->get_base_type();
        if(ts == NULL) {
            return this;
        } else {
            return ts;
        }
    }

    virtual type_specifier * clone(void) const {
        type_specifier_TYPE_NAME *copy = new type_specifier_TYPE_NAME(m_ii);
        copy->clone_copy(this);
        return copy;
    }
    virtual bool is_struct(Scope *&struct_scope);

    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        return m_ii->get_function_cc();
    }

    virtual bool is_ultimate_prt_ref(void) {
        return m_ii->is_ultimate_prt_ref();
    }

    virtual type_specifier_PRT_REF * get_ultimate_prt_ref(void) {
        return m_ii->get_ultimate_prt_ref();
    }

    virtual bool operator==(const type_specifier *other) {
        if(typeid(*this) == typeid(*other)) {
            const type_specifier_TYPE_NAME * const other_tn = dynamic_cast<const type_specifier_TYPE_NAME * const>(other);
            assert(other_tn);
            if(m_ii == other_tn->m_ii) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << m_ii->get_string();
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool param_larger_than_register(void) const;

    virtual unsigned get_minimum_size(void) {
        return m_ii->get_minimum_size();
    }
    virtual unsigned get_param_size(void) {
        return m_ii->get_param_size();
    }
};

class type_specifier_struct_or_union_specifier : public type_specifier {
protected:
    struct_or_union_specifier *m_sous;
public:
    type_specifier_struct_or_union_specifier(struct_or_union_specifier *sous);
    virtual ~type_specifier_struct_or_union_specifier(void);

    virtual ii_ptr  add_to_symbol_table(void) const;
    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual type_specifier * clone(void) const;
    virtual bool is_struct(Scope *&struct_scope);
    virtual bool is_base_type(void) {
        return true;
    }
    virtual bool declares_name(const char *name);

    virtual bool operator==(const type_specifier *other);
    virtual std::ostream & strprint(std::ostream &os) const {
        os << *m_sous;
        return os;
    }

    virtual bool param_larger_than_register(void) const {
        return true;
    }

    virtual unsigned get_minimum_size(void) {
        throw unknown_size();
        aeprintf("Should never ask for minimum size of this type.\n");
    }

    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }
    AST_DEF_CHILDREN_1(m_sous)
};

class type_specifier_enum_specifier : public type_specifier {
protected:
    enum_specifier *m_es;
public:
    type_specifier_enum_specifier(enum_specifier *es);
    virtual ~type_specifier_enum_specifier(void);
    virtual ii_ptr  add_to_symbol_table(void) const;
    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual type_specifier * clone(void) const;

    virtual bool operator==(const type_specifier *other) {
        if(typeid(*this) == typeid(*other)) {
            aeprintf("a\n");
            return true;
        } else {
            return false;
        }
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << *m_es;
        return os;
    }

    virtual unsigned get_minimum_size(void) {
        aeprintf("Should never ask for minimum size of this type.\n");
    }
    virtual unsigned get_param_size(void) {
        throw unknown_size();
    }

    AST_DEF_CHILDREN_1(m_es)
};

class type_specifier_PRT_REF : public type_specifier {
protected:
    bool m_post_translate;
    type_specifier *m_ts;
    int m_tag;
public:
    type_specifier_PRT_REF(type_specifier *ts, int tag) : m_post_translate(g_translation_started), m_ts(ts), m_tag(tag) {}

    virtual void print(void) const {
        if(m_post_translate) {
            if(m_ts) {
                m_ts->print();
                oprintf(" *");
            } else {
                oprintf("void *");
            }
        } else {
            if(m_ts) {
                oprintf("ref(");
                m_ts->print();
                oprintf(",%d) ",m_tag);
            } else {
                oprintf("ref ");
            }
        }
    }

    virtual std::ostream & strprint(std::ostream &os) const {
        if(m_ts) {
            os << *m_ts << " *";
        } else {
            os << "void *";
        }
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        m_post_translate = true;
        return TranslateResult();
    }

    virtual type_specifier * clone(void) const {
        type_specifier_PRT_REF *copy = new type_specifier_PRT_REF(m_ts ? (type_specifier*)m_ts->clone() : NULL,m_tag);
        copy->m_post_translate = m_post_translate;
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_ultimate_prt_ref(void) {
        return true;
    }

    virtual type_specifier_PRT_REF * get_ultimate_prt_ref(void) {
        return this;
    }

    virtual type_specifier * get_type_specifier(void) {
        return m_ts;
    }

    virtual int get_gen_ref_tag(void) {
        return m_tag;
    }

    virtual void * get_gen_ref_id(void) {
        return 0;
    }

    virtual unsigned get_minimum_size(void) {
        return REGISTER_PARAM_SIZE;
    }

    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }
    //AST_DEF_CHILDREN_1(m_ts)
};

class type_specifier_continuation : public type_specifier {
protected:
    bool m_post_translate;
    continuation_var_type *m_cvt;
    unsigned m_unique;
public:
    type_specifier_continuation(continuation_var_type *cvt);
    virtual ~type_specifier_continuation(void);

    virtual void print(void) const {
        if(m_post_translate) {
            oprintf("void *");
        } else {
            oprintf("continuation<>");
//            aeprintf("Should also print the continuation args here.\n");
            printf("Should also print the continuation args here.\n");
        }
    }
    virtual type_specifier * clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        if(m_post_translate) {
            os << "void *";
        } else {
            aeprintf("type_specifier_continuation being used internally before translation.\n");
        }
        return os;
    }
    continuation_var_type * get_var_type(void) {
        return m_cvt;
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        m_post_translate = true;
        return TranslateResult();
    }

    virtual bool param_larger_than_register(void) const {
        return false;
    }

    virtual unsigned get_minimum_size(void) {
        return REGISTER_PARAM_SIZE;
    }

    virtual unsigned get_num_children(void) const { return (m_cvt != NULL ? 1 : 0); }
    virtual AST_node **begin_child_iter(void) const { return (m_cvt != NULL ? (AST_node**)&m_cvt : NULL); }
    virtual AST_node **next_child_iter(AST_node **cur) const { return NULL; }

    virtual bool is_int_type(void) const {
        return true;
    }
    virtual unsigned get_param_size(void) {
        return REGISTER_PARAM_SIZE;
    }

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }
};

// ===============================================================

class type_list : public AST_node {
public:
    virtual void print(void) const {
        aeprintf("type_list print\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("type_list translate\n");
    }
    virtual type_list * clone(void) const = 0;
    virtual void get_types(check_vector<type_specifier*> &ts_vec) = 0;
};

class type_list_type : public type_list {
protected:
    type_specifier *m_ts;
public:
    type_list_type(type_specifier *ts) : m_ts(ts) {
        m_ts->set_parent(this);
    }

    virtual ~type_list_type(void) {
        delete m_ts;
    }

    virtual type_list_type * clone(void) const {
        type_list_type *copy = new type_list_type(m_ts->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual void get_types(check_vector<type_specifier*> &ts_vec) {
        ts_vec.push_back(m_ts);
    }

    AST_DEF_CHILDREN_1(m_ts)
};

class type_list_type_list_type : public type_list {
protected:
    type_list      *m_tl;
    type_specifier *m_ts;
public:
    type_list_type_list_type(type_list * tl, type_specifier *ts) : m_tl(tl), m_ts(ts) {
        m_ts->set_parent(this);
        m_tl->set_parent(this);
    }

    virtual ~type_list_type_list_type(void) {
        delete m_tl;
        delete m_ts;
    }

    virtual type_list_type_list_type * clone(void) const {
        type_list_type_list_type *copy = new type_list_type_list_type(m_tl->clone(),m_ts->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void get_types(check_vector<type_specifier*> &ts_vec) {
        m_tl->get_types(ts_vec);
        ts_vec.push_back(m_ts);
    }

    AST_DEF_CHILDREN_2(m_tl,m_ts)
};

// ===============================================================

class continuation_var_type;

class continuation_type : public AST_node {
protected:
    type_list *m_tl;
public:
    continuation_type(type_list *tl) : m_tl(tl) {
        if(m_tl) {
            m_tl->set_parent(this);
        }
    }

    virtual ~continuation_type(void) {
        delete m_tl;
    }

    virtual void print(void) const {
        aeprintf("continuation_type print\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("continuation_type translate\n");
    }
    virtual void get_types(check_vector<type_specifier*> &ts_vec) {
        if(m_tl) {
            m_tl->get_types(ts_vec);
        }
    }
    virtual continuation_var_type * to_continuation_var(void);

    virtual unsigned get_num_children(void) const { return (m_tl != NULL ? 1 : 0); }
    virtual AST_node **begin_child_iter(void) const { return (m_tl != NULL ? (AST_node**)&m_tl : NULL); }
    virtual AST_node **next_child_iter(AST_node **cur) const { return NULL; }
};

// ===============================================================

class continuation_var_type : public AST_node {
protected:
    type_list *m_tl;
public:
    continuation_var_type(type_list *tl) : m_tl(tl) {
        if(m_tl) {
            m_tl->set_parent(this);
        }
    }

    virtual ~continuation_var_type(void) {
        delete m_tl;
    }

    virtual void print(void) const {
        aeprintf("continuation_var_type print\n");
    }
    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("continuation_var_type translate\n");
    }
    virtual continuation_var_type * clone(void) const {
        continuation_var_type *copy = new continuation_var_type(m_tl ? m_tl->clone() : NULL);
        copy->clone_copy(this);
        return copy;
    }
    virtual void get_types(check_vector<type_specifier*> &ts_vec) {
        if(m_tl) {
            m_tl->get_types(ts_vec);
        }
    }

    virtual unsigned get_num_children(void) const { return (m_tl ? 1 : 0); }
    virtual AST_node **begin_child_iter(void) const { return (m_tl ? (AST_node**)&m_tl : NULL); }
    virtual AST_node **next_child_iter(AST_node **cur) const { return NULL; }
};

continuation_var_type * continuation_type::to_continuation_var(void) {
    return new continuation_var_type(m_tl ? m_tl->clone() : NULL);
}

// ===============================================================

class struct_or_union_specifier : public AST_node {
protected:
    bool m_symbol_added;
public:
    struct_or_union_specifier(void) : m_symbol_added(false) {}
    virtual ~struct_or_union_specifier(void) {}
    virtual ii_ptr  add_to_symbol_table(void) = 0;
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual AST_node * clone(void) const = 0;
    virtual void clone_copy(const struct_or_union_specifier *other) {
        m_symbol_added = other->m_symbol_added;
        AST_node::clone_copy(other);
    }

    virtual bool declares_name(const char *name) {
        return false;
    }

    virtual std::ostream & strprint(std::ostream &os) const = 0;
    virtual bool operator==(const struct_or_union_specifier *other) const = 0;
};

std::ostream & operator<<(std::ostream &os, const struct_or_union_specifier &rhs) {
    return rhs.strprint(os);
}

class struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list : public struct_or_union_specifier {
protected:
    struct_or_union         *m_sou;
    std::string              m_id;
    struct_declaration_list *m_sdl;
public:
    struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(struct_or_union *sou,const std::string &id,struct_declaration_list *sdl,bool add_symbol=true);
    virtual ~struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(void);

    virtual ii_ptr add_to_symbol_table(void) {
        if(m_symbol_added) {
            ii_ptr ii = g_scope_stack.find_symbol(m_id);
            assert(ii);
            return ii;
        }

        m_symbol_added = true;

        ii_ptr ii = g_scope_stack.find_symbol(m_id);
        if(ii) {
            if(g_scope_stack.in_current_scope(ii)) {
                if(ii->add(IIT_STRUCT_ENUM)) {
                    aeprintf("Incompatible type redeclaration.\n");
                } else {
                    if(ii->define_struct() == false) {
                        aeprintf("Redefinition of struct %s.\n",m_id.c_str());
                    }
                }
            } else {
                ii = g_scope_stack.add_symbol(m_id, IIT_STRUCT_ENUM);
                ii->define_struct();
            }
        } else {
            ii = g_scope_stack.add_symbol(m_id, IIT_STRUCT_ENUM);
            ii->define_struct();
        }
        assert(g_scope_stack.in_current_scope(ii));
        return ii;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual AST_node * clone(void) const;

    virtual std::string get_name(void) {
        return std::string(m_id);
    }

    virtual bool declares_name(const char *name) {
        if(strcmp(name,m_id.c_str()) == 0) return true;
        return false;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented.\n");
        return os;
    }
    virtual bool operator==(const struct_or_union_specifier *other) const {
        const struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list *other_cast =
            dynamic_cast<const struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list *>(other);
        if(other_cast) {
            return m_id == other_cast->m_id;
        } else {
            return false;
        }
    }

    AST_DEF_CHILDREN_2(m_sou,m_sdl)
};

class struct_or_union_specifier_struct_or_union_struct_declaration_list : public struct_or_union_specifier {
protected:
    struct_or_union *m_sou;
    struct_declaration_list *m_sdl;
public:
    struct_or_union_specifier_struct_or_union_struct_declaration_list(struct_or_union *sou,struct_declaration_list *sdl);
    virtual ~struct_or_union_specifier_struct_or_union_struct_declaration_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual ii_ptr  add_to_symbol_table(void) {
        aeprintf("Don't get here.\n");
        return NULL;
    }

    virtual AST_node * clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented.\n");
        return os;
    }
    virtual bool operator==(const struct_or_union_specifier *other) const {
        aeprintf("struct_or_union_specifier_struct_or_union_struct_declaration_list::operator==\n");
    }

    AST_DEF_CHILDREN_2(m_sou,m_sdl)
};

class struct_or_union_specifier_struct_or_union_identifier : public struct_or_union_specifier {
protected:
    struct_or_union *m_sou;
    std::string m_id;
public:
    struct_or_union_specifier_struct_or_union_identifier(struct_or_union *sou,const std::string &id);
    virtual ~struct_or_union_specifier_struct_or_union_identifier(void);

    virtual ii_ptr  add_to_symbol_table(void) {
        if(m_symbol_added) {
            ii_ptr ii = g_scope_stack.find_symbol(m_id);
            assert(ii);
            return ii;
        }

        m_symbol_added = true;

        ii_ptr ii = g_scope_stack.find_symbol(m_id);
        if(ii) {
            if(g_scope_stack.in_current_scope(ii)) {
                if(ii->add(IIT_STRUCT_ENUM)) {
                   aeprintf("Incompatible type redeclaration.\n");
                }
            } else {
                ii = g_scope_stack.add_symbol(m_id, IIT_STRUCT_ENUM);
//                ii->define_struct();
            }
        } else {
            ii = g_scope_stack.add_symbol(m_id, IIT_STRUCT_ENUM);
//            ii->define_struct();
        }
        assert(g_scope_stack.in_current_scope(ii));
        return ii;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual AST_node * clone(void) const;

    virtual std::string get_name(void) {
        return std::string(m_id);
    }

    virtual bool declares_name(const char *name) {
        if(m_id == name) return true;
        return false;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << *m_sou << " " << m_id;
        return os;
    }
    virtual bool operator==(const struct_or_union_specifier *other) const {
        const struct_or_union_specifier_struct_or_union_identifier *other_cast =
            dynamic_cast<const struct_or_union_specifier_struct_or_union_identifier *>(other);
        if(other_cast) {
            return m_id == other_cast->m_id;
        } else {
            return false;
        }
    }

    AST_DEF_CHILDREN_1(m_sou)
};

// ===============================================================

class uudeclspec_list : public AST_node {
public:
    virtual ~uudeclspec_list(void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual uudeclspec_list * clone(void) const = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class uudeclspec_list_uudeclspec : public uudeclspec_list {
protected:
    declspec_specifier *m_ds;
public:
    uudeclspec_list_uudeclspec(declspec_specifier *ds);

    virtual void print(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }
    virtual uudeclspec_list_uudeclspec * clone(void) const;

    AST_DEF_CHILDREN_1(m_ds)
};

class uudeclspec_list_uudeclspec_list_uudeclspec : public uudeclspec_list {
protected:
    uudeclspec_list *m_ul;
    declspec_specifier *m_ds;
public:
    uudeclspec_list_uudeclspec_list_uudeclspec(uudeclspec_list *ul,declspec_specifier *ds) : m_ul(ul), m_ds(ds) {}

    virtual void print(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }
    virtual uudeclspec_list_uudeclspec_list_uudeclspec * clone(void) const;

    AST_DEF_CHILDREN_2(m_ul,m_ds)
};

// ===============================================================

class struct_or_union : public AST_node {
public:
    virtual ~struct_or_union (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual struct_or_union * clone(void) const = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

std::ostream & operator<<(std::ostream &os, const struct_or_union &rhs) {
    return rhs.strprint(os);
}

class struct_or_union_STRUCT : public struct_or_union {
public:
    virtual void print(void) const {
        oprintf("struct");
    }
    virtual struct_or_union_STRUCT * clone(void) const {
        struct_or_union_STRUCT *copy = new struct_or_union_STRUCT();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "struct";
        return os;
    }
};

class struct_or_union_STRUCT_declspec : public struct_or_union {
protected:
    uudeclspec_list *m_ds;
public:
    struct_or_union_STRUCT_declspec(uudeclspec_list *ds) : m_ds(ds) {
        m_ds->set_parent(this);
    }
   ~struct_or_union_STRUCT_declspec(void);
    virtual void print(void) const;
    virtual struct_or_union_STRUCT_declspec * clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    AST_DEF_CHILDREN_1(m_ds)
};

class struct_or_union_UNION : public struct_or_union {
public:
    virtual void print(void) const {
        oprintf("union");
    }
    virtual struct_or_union_UNION * clone(void) const {
        struct_or_union_UNION *copy = new struct_or_union_UNION();
        copy->clone_copy(this);
        return copy;
    }
    virtual std::ostream & strprint(std::ostream &os) const {
        os << "union";
        return os;
    }
};

class struct_or_union_UNION_declspec : public struct_or_union {
protected:
    uudeclspec_list *m_ds;
public:
    struct_or_union_UNION_declspec(uudeclspec_list *ds) : m_ds(ds) {
        m_ds->set_parent(this);
    }
   ~struct_or_union_UNION_declspec(void);
    virtual void print(void) const;
    virtual struct_or_union_UNION_declspec * clone(void) const;
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    AST_DEF_CHILDREN_1(m_ds)
};

// ===============================================================

class struct_declaration_list : public AST_node {
public:
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual struct_declaration_list * clone(void) const = 0;

    static struct_declaration_list * new_recursive(struct_declaration_list *sdl,struct_declaration *sd);
};

class struct_declaration_list_struct_declaration : public struct_declaration_list {
protected:
    struct_declaration *m_sd;
public:
    struct_declaration_list_struct_declaration(struct_declaration *sd);
    virtual ~struct_declaration_list_struct_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual struct_declaration_list_struct_declaration * clone(void) const;

    AST_DEF_CHILDREN_1(m_sd)
};

class struct_declaration_list_struct_declaration_list_struct_declaration : public struct_declaration_list {
protected:
    struct_declaration_list *m_sdl;
    struct_declaration *m_sd;
public:
    struct_declaration_list_struct_declaration_list_struct_declaration(struct_declaration_list *sdl,struct_declaration *sd);
    virtual ~struct_declaration_list_struct_declaration_list_struct_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual struct_declaration_list_struct_declaration_list_struct_declaration * clone(void) const;

    AST_DEF_CHILDREN_2(m_sdl,m_sd)
};

class struct_declaration_list_anonymous_struct_declaration : public struct_declaration_list {
protected:
    anonymous_struct_declaration *m_sd;
public:
    struct_declaration_list_anonymous_struct_declaration(anonymous_struct_declaration *sd);
    virtual ~struct_declaration_list_anonymous_struct_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual struct_declaration_list_anonymous_struct_declaration * clone(void) const;

    AST_DEF_CHILDREN_1(m_sd)
};

class struct_declaration_list_struct_declaration_list_anonymous_struct_declaration : public struct_declaration_list {
protected:
    struct_declaration_list *m_sdl;
    anonymous_struct_declaration *m_sd;
public:
    struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(struct_declaration_list *sdl,anonymous_struct_declaration *sd);
    virtual ~struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual struct_declaration_list_struct_declaration_list_anonymous_struct_declaration * clone(void) const;

    AST_DEF_CHILDREN_2(m_sdl,m_sd)
};


// ===============================================================

class struct_declaration : public AST_node {
public:
    virtual ~struct_declaration (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual struct_declaration * clone(void) const = 0;
};

class struct_declaration_specifier_qualifier_list_struct_declarator_list : public struct_declaration {
protected:
    specifier_qualifier_list *m_sql;
    struct_declarator_list   *m_sdl;
public:
    struct_declaration_specifier_qualifier_list_struct_declarator_list(specifier_qualifier_list *sql,struct_declarator_list *sdl);
    virtual ~struct_declaration_specifier_qualifier_list_struct_declarator_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual struct_declaration_specifier_qualifier_list_struct_declarator_list * clone(void) const;

    AST_DEF_CHILDREN_2(m_sql,m_sdl)
};

class struct_declaration_HASH : public struct_declaration {
protected:
    char *m_hash;
public:
    struct_declaration_HASH(char *hash) : m_hash(hash) {}

    virtual void print(void) const {
        oprintf("%s\n",m_hash);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual struct_declaration * clone(void) const {
        aeprintf("struct_declaration_HASH::clone\n");
    }
};

class struct_declaration_pound_line : public struct_declaration {
protected:
    std::string m_text;
public:
    struct_declaration_pound_line(const std::string &text) : m_text(text) {}

    virtual void print(void) const {
        oprintf("%s\n",m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual struct_declaration * clone(void) const {
        return new struct_declaration_pound_line(m_text);
    }
};

// ===============================================================

class anonymous_struct_declaration : public AST_node {
public:
    virtual ~anonymous_struct_declaration (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual anonymous_struct_declaration * clone(void) const = 0;
};

class anonymous_struct_declaration_specifier_qualifier_list : public anonymous_struct_declaration {
protected:
    specifier_qualifier_list *m_sql;
public:
    anonymous_struct_declaration_specifier_qualifier_list(specifier_qualifier_list *sql);
    virtual ~anonymous_struct_declaration_specifier_qualifier_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual anonymous_struct_declaration_specifier_qualifier_list * clone(void) const;

    AST_DEF_CHILDREN_1(m_sql)
};

// ===============================================================

class specifier_qualifier_list : public AST_node {
public:
    virtual ~specifier_qualifier_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual specifier_qualifier_list * clone(void) = 0;
    virtual AST_node * vararg_clone(void) = 0;
    virtual AST_node * param_clone(void) = 0;
    virtual bool is_struct(Scope *&struct_scope) = 0;
    virtual type_specifier * get_type_specifier(void) = 0;
    virtual bool is_this_int(void) { return false; }
    virtual bool is_this_long(void) { return false; }
    virtual bool is_this_double(void) { return false; }
    virtual specifier_qualifier_list * remove_first(void) { return NULL; }
    virtual specifier_qualifier_list * remove_volatile(void) = 0;
    virtual bool is_volatile(void) = 0;

    virtual bool operator==(const specifier_qualifier_list *other) {
        if(typeid(*this) == typeid(*other)) {
            return true;
        } else {
            return false;
        }
    }
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class specifier_qualifier_list_type_specifier_specifier_qualifier_list : public specifier_qualifier_list {
protected:
    type_specifier *m_ts;
    specifier_qualifier_list *m_ql;
public:
    specifier_qualifier_list_type_specifier_specifier_qualifier_list(type_specifier *ts,specifier_qualifier_list *ql) : m_ts(ts), m_ql(ql) {
        m_ts->set_parent(this);
        m_ql->set_parent(this);
    }
    virtual ~specifier_qualifier_list_type_specifier_specifier_qualifier_list(void) {
        delete m_ts;
        delete m_ql;
    }

    virtual void print(void) const {
        m_ts->print();
        oprintf(" ");
        m_ql->print();
    }

    std::ostream & strprint(std::ostream &os) const {
        m_ts->strprint(os);
        os << " ";
        m_ql->strprint(os);
        return os;
    }

    virtual bool operator==(const specifier_qualifier_list *other) {
        if(typeid(*this) == typeid(*other)) {
            const specifier_qualifier_list_type_specifier_specifier_qualifier_list * const other_sql = dynamic_cast<const specifier_qualifier_list_type_specifier_specifier_qualifier_list * const>(other);
            assert(other_sql);
            if(*m_ql == other_sql->m_ql &&
               *m_ts == other_sql->m_ts) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    virtual bool is_volatile(void) {
        return m_ql->is_volatile();
    }

    virtual specifier_qualifier_list * remove_volatile(void);

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ts,tr1);
        TRANSLATE(m_ql,tr2);
        return TranslateResult();
    }

    virtual specifier_qualifier_list * clone(void) {
        specifier_qualifier_list_type_specifier_specifier_qualifier_list *copy = new specifier_qualifier_list_type_specifier_specifier_qualifier_list(
                (type_specifier*)m_ts->clone(),
                (specifier_qualifier_list*)m_ql->clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual AST_node * vararg_clone(void) {
        specifier_qualifier_list_type_specifier_specifier_qualifier_list *copy = new specifier_qualifier_list_type_specifier_specifier_qualifier_list(
                (type_specifier*)m_ts->vararg_clone(),
                (specifier_qualifier_list*)m_ql->vararg_clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual AST_node * param_clone(void) {
        specifier_qualifier_list_type_specifier_specifier_qualifier_list *copy = new specifier_qualifier_list_type_specifier_specifier_qualifier_list(
                (type_specifier*)m_ts->param_clone(),
                (specifier_qualifier_list*)m_ql->param_clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_struct(Scope *&struct_scope) {
        return m_ts->is_struct(struct_scope);
    }

    virtual type_specifier * get_type_specifier(void) {
        type_specifier *more_ts = m_ql->get_type_specifier();
        if(more_ts) {
            if(dynamic_cast<type_specifier_UNSIGNED*>(m_ts)) {
                return more_ts;
            } else {
                if(dynamic_cast<type_specifier_SHORT*>(m_ts)) {
                    if(dynamic_cast<type_specifier_INT*>(more_ts)) {
                        return m_ts;
                    }
                }
                if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
                    if(dynamic_cast<type_specifier_INT*>(more_ts)) {
                        return m_ts;
                    }
                }
                if(dynamic_cast<type_specifier_SIGNED*>(m_ts)) {
                    return more_ts;
                }
                if(dynamic_cast<type_specifier_UNSIGNED*>(more_ts)) {
                    return m_ts;
                } else {
                    aeprintf("Multiple type_specifiers in a specifier_qualifier_list and neither are unsigned at line %d.\n",get_line_number());
                }
            }
        }
        return m_ts;
    }

    virtual bool is_this_int(void) {
        if(dynamic_cast<type_specifier_INT*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    virtual bool is_this_long(void) {
        if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    virtual bool is_this_double(void) {
        if(dynamic_cast<type_specifier_DOUBLE*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    virtual specifier_qualifier_list * remove_first(void) {
        specifier_qualifier_list *ret = m_ql;
        m_ql = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_ts,m_ql)
};

class specifier_qualifier_list_type_specifier : public specifier_qualifier_list {
protected:
    type_specifier *m_ts;
public:
    specifier_qualifier_list_type_specifier(type_specifier *ts) : m_ts(ts) {
        m_ts->set_parent(this);
    }
    virtual ~specifier_qualifier_list_type_specifier(void) {
        delete m_ts;
    }

    virtual void print(void) const {
        m_ts->print();
    }

    std::ostream & strprint(std::ostream &os) const {
        return m_ts->strprint(os);
    }

    virtual bool is_volatile(void) {
        return false;
    }

    virtual specifier_qualifier_list * remove_volatile(void) {
        return this;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ts,tr);
        return tr;
    }

    virtual bool operator==(const specifier_qualifier_list *other) {
        if(typeid(*this) == typeid(*other)) {
            const specifier_qualifier_list_type_specifier * const other_sql = dynamic_cast<const specifier_qualifier_list_type_specifier * const>(other);
            assert(other_sql);
            if(*m_ts == other_sql->m_ts) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    virtual specifier_qualifier_list * clone(void) {
        specifier_qualifier_list_type_specifier *copy = new specifier_qualifier_list_type_specifier(
                (type_specifier*)m_ts->clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual AST_node * vararg_clone(void) {
        specifier_qualifier_list_type_specifier *copy = new specifier_qualifier_list_type_specifier(
                (type_specifier*)m_ts->vararg_clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual AST_node * param_clone(void) {
        specifier_qualifier_list_type_specifier *copy = new specifier_qualifier_list_type_specifier(
                (type_specifier*)m_ts->param_clone()
               );
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_struct(Scope *&struct_scope) {
        return m_ts->is_struct(struct_scope);
    }

    virtual type_specifier * get_type_specifier(void) {
        return m_ts;
    }

    virtual bool is_this_int(void) {
        if(dynamic_cast<type_specifier_INT*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    virtual bool is_this_long(void) {
        if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    virtual bool is_this_double(void) {
        if(dynamic_cast<type_specifier_DOUBLE*>(m_ts)) {
            return true;
        } else {
            return false;
        }
    }

    AST_DEF_CHILDREN_1(m_ts)
};

class specifier_qualifier_list_type_qualifier_specifier_qualifier_list : public specifier_qualifier_list {
protected:
    type_qualifier *m_tq;
    specifier_qualifier_list *m_ql;
public:
    specifier_qualifier_list_type_qualifier_specifier_qualifier_list(type_qualifier *tq,specifier_qualifier_list *ql);
    virtual ~specifier_qualifier_list_type_qualifier_specifier_qualifier_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual specifier_qualifier_list * clone(void);
    virtual AST_node * vararg_clone(void);
    virtual AST_node * param_clone(void);

    virtual bool is_struct(Scope *&struct_scope) {
        return m_ql->is_struct(struct_scope);
    }

    virtual type_specifier * get_type_specifier(void) {
        return m_ql->get_type_specifier();
    }

    std::ostream & strprint(std::ostream &os) const;

    virtual bool is_volatile(void);

    virtual specifier_qualifier_list * remove_volatile(void);

    virtual specifier_qualifier_list * remove_first(void) {
        specifier_qualifier_list *ret = m_ql;
        m_ql = NULL;
        return ret;
    }

    AST_DEF_CHILDREN_2(m_tq,m_ql)
};

class specifier_qualifier_list_type_qualifier : public specifier_qualifier_list {
protected:
    type_qualifier *m_tq;
public:
    specifier_qualifier_list_type_qualifier(type_qualifier *tq);
    virtual ~specifier_qualifier_list_type_qualifier(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual specifier_qualifier_list * clone(void);
    virtual AST_node * vararg_clone(void);
    virtual AST_node * param_clone(void);

    virtual bool is_struct(Scope *&struct_scope) {
        return false;
    }

    virtual type_specifier * get_type_specifier(void) {
        return NULL;
    }

    virtual bool is_volatile(void);

    virtual specifier_qualifier_list * remove_volatile(void);

    std::ostream & strprint(std::ostream &os) const;

    AST_DEF_CHILDREN_1(m_tq)
};

// ====================================================================

class struct_declarator_list : public AST_node {
public:
    virtual ~struct_declarator_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table() const = 0;
    virtual struct_declarator_list * clone(void) const = 0;
};

class struct_declarator_list_struct_declarator : public struct_declarator_list {
protected:
    struct_declarator *m_sd;
public:
    struct_declarator_list_struct_declarator(struct_declarator *sd);
    virtual ~struct_declarator_list_struct_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table() const;
    virtual struct_declarator_list_struct_declarator * clone(void) const;

    AST_DEF_CHILDREN_1(m_sd)
};

class struct_declarator_list_struct_declarator_list_struct_declarator : public struct_declarator_list {
protected:
    struct_declarator_list *m_sdl;
    struct_declarator *m_sd;
public:
    struct_declarator_list_struct_declarator_list_struct_declarator(struct_declarator_list *sdl,struct_declarator *sd);
    virtual ~struct_declarator_list_struct_declarator_list_struct_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::list<std::pair<ii_ptr ,declarator *> > add_to_symbol_table() const;
    virtual struct_declarator_list_struct_declarator_list_struct_declarator * clone(void) const;

    AST_DEF_CHILDREN_2(m_sdl,m_sd)
};

// ====================================================================

class struct_declarator : public AST_node {
public:
    virtual ~struct_declarator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual ii_ptr  add_to_symbol_table(void) const = 0;
    virtual declarator * get_declarator(void) = 0;
    virtual struct_declarator * clone(void) const = 0;
};

class struct_declarator_declarator : public struct_declarator {
protected:
    declarator *m_d;
public:
    struct_declarator_declarator(declarator *d) : m_d(d) {
        m_d->set_parent(this);
    }
    virtual ~struct_declarator_declarator(void) {
        delete m_d;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual ii_ptr  add_to_symbol_table(void) const {
        return m_d->add_to_symbol_table(IIT_VAR);
    }

    virtual declarator * get_declarator(void) {
        return m_d;
    }

    virtual struct_declarator_declarator * clone(void) const {
        struct_declarator_declarator * copy = new struct_declarator_declarator(m_d->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_d)
};

class struct_declarator_constant_expression : public struct_declarator {
protected:
    constant_expression *m_ce;
public:
    struct_declarator_constant_expression(constant_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~struct_declarator_constant_expression(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        oprintf(" : ");
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
    }

    virtual declarator * get_declarator(void) {
        return NULL;
    }

    virtual struct_declarator_constant_expression * clone(void) const {
        struct_declarator_constant_expression * copy = new struct_declarator_constant_expression(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class struct_declarator_declarator_constant_expression : public struct_declarator {
protected:
    declarator *m_d;
    constant_expression *m_ce;
public:
    struct_declarator_declarator_constant_expression(declarator *d,constant_expression *ce) : m_d(d), m_ce(ce) {
        m_d->set_parent(this);
        m_ce->set_parent(this);
    }
    virtual ~struct_declarator_declarator_constant_expression(void) {
        delete m_d;
        delete m_ce;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual ii_ptr  add_to_symbol_table(void) const {
        return m_d->add_to_symbol_table(IIT_VAR);
    }

    virtual declarator * get_declarator(void) {
        return m_d;
    }

    virtual struct_declarator_declarator_constant_expression * clone(void) const {
        struct_declarator_declarator_constant_expression * copy = new struct_declarator_declarator_constant_expression(m_d->clone(),m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_d,m_ce)
};

// ====================================================================

class enum_specifier : public AST_node {
public:
    virtual ~enum_specifier (void) {}
    virtual ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
    }
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual AST_node * clone(void) const = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

std::ostream & operator<<(std::ostream &os, const enum_specifier &rhs) {
    return rhs.strprint(os);
}

class enum_specifier_enumerator_list : public enum_specifier {
protected:
    enumerator_list *m_el;
public:
    enum_specifier_enumerator_list(enumerator_list *el);
    virtual ~enum_specifier_enumerator_list(void);

    virtual ii_ptr  add_to_symbol_table(void) const {
        // Intentionally do nothing since this is an anonymous enum.
        return NULL;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    virtual enum_specifier_enumerator_list * clone(void) const;

    AST_DEF_CHILDREN_1(m_el)
};

class enum_specifier_identifier_enumerator_list : public enum_specifier {
protected:
    std::string m_id;
    enumerator_list *m_el;
public:
    enum_specifier_identifier_enumerator_list(const std::string &id,enumerator_list *el);
    virtual ~enum_specifier_identifier_enumerator_list(void);

    virtual ii_ptr  add_to_symbol_table(void) const {
        std::string s(m_id);
        ii_ptr ii = g_scope_stack.find_symbol(s);
        if(ii) {
            if(g_scope_stack.in_current_scope(ii)) {
                if(ii->add(IIT_STRUCT_ENUM)) {
                   aeprintf("Incompatible type redeclaration.\n");
                }
            } else {
                ii = g_scope_stack.add_symbol(s, IIT_STRUCT_ENUM);
                ii->define_struct();
            }
        } else {
            ii = g_scope_stack.add_symbol(s, IIT_STRUCT_ENUM);
            ii->define_struct();
        }
        assert(g_scope_stack.in_current_scope(ii));
        return ii;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    virtual enum_specifier_identifier_enumerator_list * clone(void) const;

    AST_DEF_CHILDREN_1(m_el)
};

class enum_specifier_enumerator_list_comma : public enum_specifier {
protected:
    enumerator_list *m_el;
public:
    enum_specifier_enumerator_list_comma(enumerator_list *el);
    virtual ~enum_specifier_enumerator_list_comma(void);

    virtual ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    virtual enum_specifier_enumerator_list_comma * clone(void) const;

    AST_DEF_CHILDREN_1(m_el)
};

#ifdef USE_ESELCPL
class enum_specifier_enumerator_list_comma_pound_line : public enum_specifier_enumerator_list_comma {
protected:
    std::string m_text;
public:
    enum_specifier_enumerator_list_comma_pound_line(enumerator_list *el,const std::string &text) : enum_specifier_enumerator_list_comma(el), m_text(text) {}

    virtual void print(void) const {
        enum_specifier_enumerator_list_comma::print();
        oprintf("%s ",m_text.c_str());
    }
};
#endif

class enum_specifier_identifier_enumerator_list_comma : public enum_specifier {
protected:
    std::string m_id;
    enumerator_list *m_el;
public:
    enum_specifier_identifier_enumerator_list_comma(const std::string &id,enumerator_list *el);
    virtual ~enum_specifier_identifier_enumerator_list_comma(void);

    virtual ii_ptr  add_to_symbol_table(void) const {
        // FIX FIX FIX...don't need to do anything here?
        return NULL;
    }

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::ostream & strprint(std::ostream &os) const {
        aeprintf("Not implemented yet.\n");
        return os;
    }

    virtual enum_specifier_identifier_enumerator_list_comma * clone(void) const;

    AST_DEF_CHILDREN_1(m_el)
};

#ifdef USE_ES_IELCPL
class enum_specifier_identifier_enumerator_list_comma_pound_line : public enum_specifier_identifier_enumerator_list_comma {
protected:
    std::string m_text;
public:
    enum_specifier_identifier_enumerator_list_comma_pound_line(const char *id,enumerator_list *el,const std::string &text) : enum_specifier_identifier_enumerator_list_comma(id,el), m_text(text) {}

    virtual void print(void) const {
        enum_specifier_identifier_enumerator_list_comma::print();
        oprintf("%s ",m_text.c_str());
    }
};
#endif

class enum_specifier_identifier : public enum_specifier {
protected:
    std::string m_id;
public:
    enum_specifier_identifier(const std::string &id) : m_id(id) {}

    virtual ii_ptr  add_to_symbol_table(void) const {
        aeprintf("add_to_symbol_table\n");
    }

    virtual void print(void) const {
        oprintf("enum %s ",m_id.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual enum_specifier_identifier * clone(void) const {
        enum_specifier_identifier *copy = new enum_specifier_identifier(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual std::ostream & strprint(std::ostream &os) const {
        os << "enum " << m_id.c_str();
        return os;
    }
};

// ====================================================================

class enumerator_list : public AST_node {
public:
    virtual ~enumerator_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual enumerator_list * clone(void) const = 0;
};

class enumerator_list_enumerator : public enumerator_list {
protected:
    enumerator *m_e;
public:
    enumerator_list_enumerator(enumerator *e);
    virtual ~enumerator_list_enumerator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual enumerator_list_enumerator * clone(void) const;

    AST_DEF_CHILDREN_1(m_e)
};

class enumerator_list_enumerator_list_enumerator : public enumerator_list {
protected:
    enumerator_list *m_el;
    enumerator *m_e;
public:
    enumerator_list_enumerator_list_enumerator(enumerator_list *el,enumerator *e);
    virtual ~enumerator_list_enumerator_list_enumerator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual enumerator_list_enumerator_list_enumerator * clone(void) const;

    AST_DEF_CHILDREN_2(m_el,m_e)
};

// ====================================================================

class enumerator : public AST_node {
public:
    virtual ~enumerator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual enumerator * clone(void) const = 0;
};

class enumerator_identifier : public enumerator {
protected:
    //const char *m_id;
    std::string m_id;
public:
    enumerator_identifier(const std::string &id) : m_id(id) {}

    virtual void print(void) const {
        oprintf("%s ",m_id.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual enumerator_identifier * clone(void) const {
        enumerator_identifier *copy = new enumerator_identifier(m_id);
        copy->clone_copy(this);
        return copy;
    }
};

class enumerator_identifier_constant_expression : public enumerator {
protected:
    std::string m_id;
    constant_expression *m_ce;
public:
    enumerator_identifier_constant_expression(const std::string &id,constant_expression *ce) : m_id(id), m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~enumerator_identifier_constant_expression(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        oprintf("%s = ",m_id.c_str());
        m_ce->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ce,tr);
        return tr;
    }

    virtual enumerator_identifier_constant_expression * clone(void) const {
        enumerator_identifier_constant_expression *copy = new enumerator_identifier_constant_expression(m_id,m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class enumerator_pound_line : public enumerator {
protected:
    std::string m_text;
public:
    enumerator_pound_line(const std::string &text) : m_text(text) {}

    virtual void print(void) const {
        oprintf("%s\n",m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual enumerator_pound_line * clone(void) const {
        enumerator_pound_line *copy = new enumerator_pound_line(m_text);
        copy->clone_copy(this);
        return copy;
    }
};

// ====================================================================

class type_qualifier : public AST_node {
public:
    virtual ~type_qualifier (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual type_qualifier * clone(void) = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
    virtual bool is_volatile(void) const {
        return false;
    }
};

class type_qualifier_const : public type_qualifier {
public:
    virtual void print(void) const {
        oprintf("const");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << "const";
        return os;
    }

    virtual type_qualifier * clone(void) {
        type_qualifier_const *copy = new type_qualifier_const();
        copy->clone_copy(this);
        return copy;
    }
};

class type_qualifier_restrict : public type_qualifier {
public:
    virtual void print(void) const {
        oprintf("restrict");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << "restrict";
        return os;
    }

    virtual type_qualifier * clone(void) {
        type_qualifier_restrict *copy = new type_qualifier_restrict();
        copy->clone_copy(this);
        return copy;
    }
};

class type_qualifier_uurestrict : public type_qualifier {
public:
    virtual void print(void) const {
        oprintf("__restrict");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << "__restrict";
        return os;
    }

    virtual type_qualifier * clone(void) {
        type_qualifier_uurestrict *copy = new type_qualifier_uurestrict();
        copy->clone_copy(this);
        return copy;
    }
};

class type_qualifier_volatile : public type_qualifier {
public:
    virtual void print(void) const {
        oprintf("volatile");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << "volatile";
        return os;
    }

    virtual type_qualifier * clone(void) {
        type_qualifier_volatile *copy = new type_qualifier_volatile();
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_volatile(void) const {
        return true;
    }
};

// ====================================================================

class declspec_specifier : public AST_node {
public:
    virtual ~declspec_specifier (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual declspec_specifier * clone(void) = 0;
    virtual bool has_noreturn(void) {
        return false;
    }
};

class declspec_specifier_NORETURN : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("noreturn");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_NORETURN;
    }
    virtual bool has_noreturn(void) {
        return true;
    }
};

class declspec_specifier_ALIGN512 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(512)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN512;
    }
};

class declspec_specifier_ALIGN256 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(256)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN256;
    }
};

class declspec_specifier_ALIGN128 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(128)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN128;
    }
};

class declspec_specifier_ALIGN64 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(64)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN64;
    }
};

class declspec_specifier_ALIGN32 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(32)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN32;
    }
};

class declspec_specifier_ALIGN16 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(16)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN16;
    }
};

class declspec_specifier_ALIGN8 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(8)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN8;
    }
};

class declspec_specifier_ALIGN4 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(4)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN4;
    }
};

class declspec_specifier_ALIGN2 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(2)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN2;
    }
};

class declspec_specifier_ALIGN1 : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("align(1)");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_ALIGN1;
    }
};

class declspec_specifier_DLLIMPORT : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("dllimport");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_DLLIMPORT;
    }
};

class declspec_specifier_DLLEXPORT : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("dllexport");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_DLLEXPORT;
    }
};

class declspec_specifier_NAKED : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("naked");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_NAKED;
    }
};

class declspec_specifier_NOALIAS : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("noalias");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_NOALIAS;
    }
};

class declspec_specifier_RESTRICT : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("restrict");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_RESTRICT;
    }
};

class declspec_specifier_UURESTRICT : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("__restrict");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_UURESTRICT;
    }
};

class declspec_specifier_DEPRECATED : public declspec_specifier {
protected:
//    char *m_id;
public:
    declspec_specifier_DEPRECATED(char *id) {}
//    declspec_specifier_DEPRECATED(char *id) : m_id(id) {}
    virtual ~declspec_specifier_DEPRECATED(void) {}
    virtual void print(void) const {
        oprintf("deprecated");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_DEPRECATED(NULL);
    }
};

class declspec_specifier_NOINLINE : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("noinline");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_NOINLINE;
    }
};

class declspec_specifier_INTRIN_TYPE : public declspec_specifier {
public:
    virtual void print(void) const {
        oprintf("intrin_type");
    }
    virtual declspec_specifier * clone(void) {
        return new declspec_specifier_INTRIN_TYPE;
    }
};

// ====================================================================

class function_specifier : public AST_node {
public:
    virtual ~function_specifier (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }
    virtual function_specifier * clone(void) = 0;
    virtual bool has_noreturn(void) {
        return false;
    }
};

class function_specifier_INLINE : public function_specifier {
public:
    virtual void print(void) const {
        oprintf("inline");
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_INLINE();
        copy->clone_copy(this);
        return copy;
    }
};

class function_specifier_UINLINE : public function_specifier {
public:
    virtual void print(void) const {
        oprintf("_inline");
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_UINLINE();
        copy->clone_copy(this);
        return copy;
    }
};

class function_specifier_UUINLINE : public function_specifier {
public:
    virtual void print(void) const {
        oprintf("__inline");
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_UUINLINE();
        copy->clone_copy(this);
        return copy;
    }
};

class function_specifier_UUINLINEUU : public function_specifier {
public:
    virtual void print(void) const {
        oprintf("__inline__");
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_UUINLINEUU();
        copy->clone_copy(this);
        return copy;
    }
};

class function_specifier_FORCEINLINE : public function_specifier {
public:
    virtual void print(void) const {
        oprintf("__forceinline");
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_FORCEINLINE();
        copy->clone_copy(this);
        return copy;
    }
};

class function_specifier_udeclspec_specifier : public function_specifier {
protected:
    declspec_specifier *m_ds;
public:
    function_specifier_udeclspec_specifier(declspec_specifier *ds) : m_ds(ds) {
        m_ds->set_parent(this);
    }
    virtual ~function_specifier_udeclspec_specifier(void) {
        delete m_ds;
    }

    virtual void print(void) const {
        oprintf("_declspec(");
        m_ds->print();
        oprintf(") ");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ds,tr);
        return tr;
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_udeclspec_specifier(m_ds->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    AST_DEF_CHILDREN_1(m_ds)
};

class function_specifier_uudeclspec_specifier : public function_specifier {
protected:
    declspec_specifier *m_ds;
public:
    function_specifier_uudeclspec_specifier(declspec_specifier *ds) : m_ds(ds) {
        m_ds->set_parent(this);
    }
    virtual ~function_specifier_uudeclspec_specifier(void) {
        delete m_ds;
    }

    virtual void print(void) const {
        oprintf("__declspec(");
        m_ds->print();
        oprintf(")");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ds,tr);
        return tr;
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_uudeclspec_specifier(m_ds->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool has_noreturn(void) {
        return m_ds->has_noreturn();
    }

    AST_DEF_CHILDREN_1(m_ds)
};

class function_specifier_text : public function_specifier {
protected:
    std::string m_s;
public:
    function_specifier_text(const std::string &s) : m_s(s) {}

    virtual ~function_specifier_text(void) {}

    virtual void print(void) const {
        oprintf("%s ",m_s.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("Should not get here.\n");
        return TranslateResult();
    }

    virtual function_specifier * clone(void) {
        function_specifier *copy = new function_specifier_text(m_s);
        copy->clone_copy(this);
        return copy;
    }
};

// ====================================================================

class pointer : public AST_node {
public:
    virtual ~pointer (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual pointer * clone(void) const = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
    virtual pointer * append(pointer *other) = 0;
};

class pointer_star : public pointer {
public:
    virtual void print(void) const {
        oprintf("*");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual pointer * clone(void) const {
        pointer_star *copy = new pointer_star();
        copy->clone_copy(this);
        return copy;
    }

    std::ostream & strprint(std::ostream &os) const {
        os << "*";
        return os;
    }
    virtual pointer * append(pointer *other);
};

class pointer_star_type_qualifier_list : public pointer {
protected:
    type_qualifier_list *m_tql;
public:
    pointer_star_type_qualifier_list(type_qualifier_list *tql);
    virtual ~pointer_star_type_qualifier_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual pointer * clone(void) const;

    std::ostream & strprint(std::ostream &os) const;
    virtual pointer * append(pointer *other);

    AST_DEF_CHILDREN_1(m_tql)
};

class pointer_star_pointer : public pointer {
protected:
    pointer *m_p;
public:
    pointer_star_pointer(pointer *p) : m_p(p) {
        m_p->set_parent(this);
    }
    virtual ~pointer_star_pointer(void) {
        delete m_p;
    }

    virtual void print(void) const {
        oprintf("* ");
        m_p->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_p,tr);
        return tr;
    }

    virtual pointer * clone(void) const {
        pointer_star_pointer *copy = new pointer_star_pointer((pointer*)m_p->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual pointer * get_pointer(void) {
        return m_p;
    }

    virtual pointer * append(pointer *other);

    std::ostream & strprint(std::ostream &os) const {
        os << "* ";
        return m_p->strprint(os);
    }

    AST_DEF_CHILDREN_1(m_p)
};

class pointer_star_type_qualifier_list_pointer : public pointer {
protected:
    type_qualifier_list *m_tql;
    pointer *m_p;
public:
    pointer_star_type_qualifier_list_pointer(type_qualifier_list *tql,pointer *p);
    virtual ~pointer_star_type_qualifier_list_pointer(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual pointer * clone(void) const;

    virtual pointer * get_pointer(void) {
        return m_p;
    }

    virtual pointer * append(pointer *other);

    std::ostream & strprint(std::ostream &os) const;

    AST_DEF_CHILDREN_2(m_tql,m_p)
};

// ====================================================================

class type_qualifier_list : public AST_node {
public:
    virtual ~type_qualifier_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual type_qualifier_list * clone(void) const = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class type_qualifier_list_type_qualifier : public type_qualifier_list {
protected:
    type_qualifier *m_tq;
public:
    type_qualifier_list_type_qualifier(type_qualifier *tq) : m_tq(tq) {
        m_tq->set_parent(this);
    }
    virtual ~type_qualifier_list_type_qualifier(void) {
        delete m_tq;
    }

    virtual void print(void) const {
       m_tq->print();
    }

    std::ostream & strprint(std::ostream &os) const {
        return m_tq->strprint(os);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_tq,tr);
        return tr;
    }

    virtual type_qualifier_list * clone(void) const {
        type_qualifier_list_type_qualifier *copy = new type_qualifier_list_type_qualifier((type_qualifier*)m_tq->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_tq)
};

class type_qualifier_list_type_qualifier_list_type_qualifier : public type_qualifier_list {
protected:
    type_qualifier_list *m_tql;
    type_qualifier *m_tq;
public:
    type_qualifier_list_type_qualifier_list_type_qualifier(type_qualifier_list *tql,type_qualifier *tq) : m_tql(tql), m_tq(tq) {
        m_tql->set_parent(this);
        m_tq->set_parent(this);
    }
    virtual ~type_qualifier_list_type_qualifier_list_type_qualifier(void) {
        delete m_tql;
        delete m_tq;
    }

    virtual void print(void) const {
       m_tql->print();
       oprintf(" ");
       m_tq->print();
    }

    std::ostream & strprint(std::ostream &os) const {
        m_tql->strprint(os);
        os << " ";
        return m_tq->strprint(os);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_tql,tr1);
        TRANSLATE(m_tq,tr2);
        aeprintf("type problem\n");
        // FIX FIX FIX combine tr1 and tr2
        return tr1;
    }

    virtual type_qualifier_list * clone(void) const {
        type_qualifier_list_type_qualifier_list_type_qualifier *copy = new type_qualifier_list_type_qualifier_list_type_qualifier((type_qualifier_list*)m_tql->clone(),(type_qualifier*)m_tq->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_tql,m_tq)
};

// ====================================================================

class parameter_list : public AST_node {
public:
    virtual ~parameter_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual void prepend_params(parameter_list *pl) = 0;
    virtual bool is_void(void) = 0;
    virtual void vectorize(check_vector<parameter_declaration *> &params) = 0;
    virtual parameter_list * clone(void) = 0;
    virtual parameter_list * clone_abstract(void) = 0;
    static parameter_list * new_recursive(parameter_list *pl,parameter_declaration *pd);
};

class parameter_list_parameter_declaration : public parameter_list {
protected:
    parameter_declaration *m_pd;
public:
    parameter_list_parameter_declaration(parameter_declaration *pd);
    virtual ~parameter_list_parameter_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void prepend_params(parameter_list *pl);

    virtual bool is_void(void);

    virtual void vectorize(check_vector<parameter_declaration *> &params) {
        params.push_back(m_pd);
    }

    virtual parameter_list * clone(void);
    virtual parameter_list * clone_abstract(void);

    AST_DEF_CHILDREN_1(m_pd)
};

class parameter_list_parameter_list_parameter_declaration : public parameter_list {
protected:
    parameter_list        *m_pl;
    parameter_declaration *m_pd;
public:
    parameter_list_parameter_list_parameter_declaration(parameter_list *pl,parameter_declaration *pd);
    virtual ~parameter_list_parameter_list_parameter_declaration(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void prepend_params(parameter_list *pl) {
        m_pl->prepend_params(pl);
    }

    virtual bool is_void(void) {
        return false;
    }

    virtual void vectorize(check_vector<parameter_declaration *> &params) {
        m_pl->vectorize(params);
        params.push_back(m_pd);
    }

    virtual parameter_list * clone(void);
    virtual parameter_list * clone_abstract(void);

    AST_DEF_CHILDREN_2(m_pl,m_pd)
};

// ====================================================================

class parameter_type_list : public AST_node {
public:
    virtual ~parameter_type_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual void prepend_params(parameter_list *pl) = 0;
    virtual void vectorize(check_vector<parameter_declaration *> &params, bool &ellipsis) = 0;
    virtual parameter_type_list * clone(void) = 0;
    virtual parameter_type_list * clone_abstract(void) = 0;
    virtual int get_parameter_index(parameter_declaration *pd) {
        check_vector<parameter_declaration *> pdvec;
        bool ellipsis;
        vectorize(pdvec,ellipsis);
        for(unsigned i = 0; i < pdvec.size(); ++i) {
            if(pdvec[i] == pd) return i;
        }
        aeprintf("Could not find specified parameter in get_parameter_index.\n");
    }
};

class parameter_type_list_parameter_list : public parameter_type_list {
protected:
    parameter_list *m_pl;
public:
    parameter_type_list_parameter_list(parameter_list *pl) : m_pl(pl) {
        m_pl->set_parent(this);
    }
    virtual ~parameter_type_list_parameter_list(void) {
        delete m_pl;
    }

    virtual void print(void) const {
        m_pl->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void prepend_params(parameter_list *pl) {
        if(m_pl->is_void()) {
            parameter_list *to_delete = m_pl;
            m_pl = pl;
            delete to_delete;
        } else {
            m_pl->prepend_params(pl);
        }
    }

    virtual void vectorize(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        if(!m_pl->is_void()) {
            m_pl->vectorize(params);
        }
        ellipsis = false;
    }

    virtual parameter_type_list * clone(void) {
        parameter_type_list *copy = new parameter_type_list_parameter_list(m_pl->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual parameter_type_list * clone_abstract(void) {
        parameter_type_list *copy = new parameter_type_list_parameter_list(m_pl->clone_abstract());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pl)
};

class parameter_type_list_parameter_list_ellipsis : public parameter_type_list {
protected:
    parameter_list *m_pl;
public:
    parameter_type_list_parameter_list_ellipsis(parameter_list *pl) : m_pl(pl) {
        m_pl->set_parent(this);
    }
    virtual ~parameter_type_list_parameter_list_ellipsis(void) {
        delete m_pl;
    }

    virtual void print(void) const {
        m_pl->print();
        oprintf(" , ... ");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_pl,tr);

        return tr;
    }

    virtual void prepend_params(parameter_list *pl) {
        m_pl->prepend_params(pl);
    }

    virtual void vectorize(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_pl->vectorize(params);
        ellipsis = true;
    }

    virtual parameter_type_list * clone(void) {
        parameter_type_list *copy = new parameter_type_list_parameter_list_ellipsis(m_pl->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual parameter_type_list * clone_abstract(void) {
        parameter_type_list *copy = new parameter_type_list_parameter_list(m_pl->clone_abstract());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_pl)
};

// ====================================================================

class parameter_declaration : public AST_node {
protected:
    ii_ptr m_ii;
    type_specifier *m_type;
public:
    parameter_declaration(void) : m_ii(NULL), m_type(NULL) {}

    virtual ~parameter_declaration (void) {}

    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;

    virtual void set_symbol_table(ii_ptr ii) {
        m_ii = ii;
    }

    virtual ii_ptr  get_symbol(void) const {
        return m_ii;
    }

    virtual void set_type(type_specifier *ts) {
        assert(!m_type);
        m_type = ts;
    }

    virtual type_specifier * get_type_specifier(void) const {
        return m_type;
    }

    virtual bool is_void(void) = 0;

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param) = 0;
    virtual struct_declaration * gen_struct_declaration(unsigned arg_num) = 0;

    virtual parameter_declaration * clone(void) = 0;
    virtual parameter_declaration * clone_abstract(void) = 0;
    virtual void add_volatile(void) = 0;
    virtual expression_type * get_type(void) = 0;
    virtual expression_type * get_return_type(void) {
        return get_type();
    }
    virtual declaration_specifiers * get_declaration_specifiers(void) = 0;

    virtual unsigned get_param_size(void) = 0;
};

class parameter_declaration_declaration_specifiers_declarator : public parameter_declaration {
protected:
    declaration_specifiers *m_ds;
    declarator             *m_d;
public:
    parameter_declaration_declaration_specifiers_declarator(declaration_specifiers *ds, declarator *d) : m_ds(ds), m_d(d) {
        m_ds->set_parent(this);
        m_d->set_parent(this);
    }
    virtual ~parameter_declaration_declaration_specifiers_declarator(void) {
        delete m_ds;
        delete m_d;
    }

    virtual void print(void) const {
        m_ds->print();
        oprintf(" ");
        m_d->print();
    }

    declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual void add_volatile(void) {
        m_ds = m_ds->add_volatile();
    }

    virtual parameter_declaration * clone(void) {
        parameter_declaration *copy = new parameter_declaration_declaration_specifiers_declarator(m_ds->clone(),m_d->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual parameter_declaration * clone_abstract(void);

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ds,tr1);
        TRANSLATE(m_d,tr2);
        return TranslateResult();
    }

    virtual std::list<ii_ptr > get_enclosing_symbols(void) {
        return m_d->get_enclosing_symbols();
    }

    virtual bool is_void(void) {
        return false;
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param) {
        std::stringstream buf;
        buf << "arg" << arg_num;

        assert(!is_var_arg_param);

        specifier_qualifier_list *from_type, *sql;
        from_type = m_ds->gen_specifier_qualifier_list();
        if(m_d->is_pointer()) {
            sql = from_type;
        } else {
            sql = (specifier_qualifier_list*)from_type->param_clone();
            delete from_type;
        }

        return
          new struct_declaration_specifier_qualifier_list_struct_declarator_list(
            sql,
            new struct_declarator_list_struct_declarator(
              m_d->gen_struct_declarator(buf.str())
            )
          );
    }

    expression_type * get_type(void);

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num) {
        specifier_qualifier_list *from_type, *sql;
        from_type = m_ds->gen_specifier_qualifier_list();
        if(m_d->is_pointer()) {
            sql = from_type;
        } else {
            sql = (specifier_qualifier_list*)from_type->param_clone();
            delete from_type;
        }

        return
          new struct_declaration_specifier_qualifier_list_struct_declarator_list(
            sql,
            new struct_declarator_list_struct_declarator(
              m_d->gen_struct_declarator(m_d->get_one_name())
            )
          );
    }

    virtual unsigned get_param_size(void) {
        if(m_d->is_pointer()) {
            return REGISTER_PARAM_SIZE;
        } else {
            return m_ds->get_type_specifier()->get_param_size();
        }
    }

    AST_DEF_CHILDREN_2(m_ds,m_d)
};

class parameter_declaration_declaration_specifiers_abstract_declarator : public parameter_declaration {
protected:
    declaration_specifiers *m_ds;
    abstract_declarator    *m_ad;
public:
    parameter_declaration_declaration_specifiers_abstract_declarator(declaration_specifiers *ds, abstract_declarator *ad);
    virtual ~parameter_declaration_declaration_specifiers_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool is_void(void) {
        return false;
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param);
    virtual struct_declaration * gen_struct_declaration(unsigned arg_num) {
        return gen_struct_declaration(arg_num,false);
    }

    virtual void add_volatile(void) {
        m_ds = m_ds->add_volatile();
    }

    declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual parameter_declaration * clone(void);
    virtual parameter_declaration * clone_abstract(void) {
        return clone();
    }

    expression_type * get_type(void);

    virtual unsigned get_param_size(void);

    AST_DEF_CHILDREN_2(m_ds,m_ad)
};

class parameter_declaration_declaration_specifiers : public parameter_declaration {
protected:
    declaration_specifiers *m_ds;
public:
    parameter_declaration_declaration_specifiers(declaration_specifiers *ds) : m_ds(ds) {
        m_ds->set_parent(this);
    }
    virtual ~parameter_declaration_declaration_specifiers(void) {
        delete m_ds;
    }

    virtual void print(void) const {
        m_ds->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ds,tr);
        return tr;
    }

    virtual bool is_void(void) {
        return m_ds->is_void();
    }

    declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual void add_volatile(void) {
        m_ds = m_ds->add_volatile();
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num, bool is_var_arg_param) {
        std::stringstream buf;
        buf << "arg" << arg_num;

        assert(!is_var_arg_param);

        specifier_qualifier_list *from_type, *sql;
        from_type = m_ds->gen_specifier_qualifier_list();
        sql = (specifier_qualifier_list*)from_type->param_clone();
        delete from_type;

        return
          new struct_declaration_specifier_qualifier_list_struct_declarator_list(
            sql,
            new struct_declarator_list_struct_declarator(
              new struct_declarator_declarator(
                new declarator_direct_declarator(
                  new direct_declarator_IDENTIFIER(
                    g_scope_stack.find_or_add(buf.str()))))));
    }

    virtual struct_declaration * gen_struct_declaration(unsigned arg_num) {
        return gen_struct_declaration(arg_num,false);
    }

    virtual parameter_declaration * clone(void) {
        parameter_declaration *copy = new parameter_declaration_declaration_specifiers(m_ds->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual parameter_declaration * clone_abstract(void) {
        return clone();
    }

    expression_type * get_type(void);

    virtual unsigned get_param_size(void) {
        return m_ds->get_type_specifier()->get_param_size();
    }

    AST_DEF_CHILDREN_1(m_ds)
};

// ====================================================================

#define ID_II

class identifier_list : public AST_node {
public:
    virtual ~identifier_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual identifier_list * clone(void) = 0;
#ifdef ID_II
    virtual void flatten(check_vector<ii_ptr > &flat_vec) = 0;
#else
    virtual void flatten(check_vector<const char *> &flat_vec) = 0;
#endif
};

class identifier_list_identifier : public identifier_list {
protected:
#ifdef ID_II
    ii_ptr m_ii;
#else
    const char *m_id;
#endif
public:
#ifdef ID_II
    identifier_list_identifier(ii_ptr ii) : m_ii(ii) {}

    virtual void print(void) const {
        oprintf("%s ",m_ii->get_name());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual identifier_list * clone(void) {
        identifier_list *copy = new identifier_list_identifier(m_ii);
        copy->clone_copy(this);
        return copy;
    }

    virtual void flatten(check_vector<ii_ptr > &flat_vec) {
        flat_vec.push_back(m_ii);
    }
#else
    identifier_list_identifier(const char *id) : m_id(id) {}

    virtual void print(void) const {
        oprintf("%s ",m_id);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {}

    virtual identifier_list * clone(void) {
        identifier_list *copy = new identifier_list_identifier(m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual void flatten(check_vector<const char *> &flat_vec) {
        flat_vec.push_back(m_id);
    }
#endif
};

class identifier_list_identifier_list_identifier : public identifier_list {
protected:
    identifier_list *m_il;
#ifdef ID_II
    ii_ptr m_ii;
#else
    const char *m_id;
#endif
public:
#ifdef ID_II
    identifier_list_identifier_list_identifier(identifier_list *il,ii_ptr ii) : m_il(il), m_ii(ii) {
        m_il->set_parent(this);
    }
    virtual ~identifier_list_identifier_list_identifier(void) {
        delete m_il;
    }

    virtual void print(void) const {
        m_il->print();
        oprintf(", %s ",m_ii->get_name());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_il,tr);
        return tr;
    }

    virtual identifier_list * clone(void) {
        identifier_list *copy = new identifier_list_identifier_list_identifier(m_il->clone(),m_ii);
        copy->clone_copy(this);
        return copy;
    }

    virtual void flatten(check_vector<ii_ptr > &flat_vec) {
        m_il->flatten(flat_vec);
        flat_vec.push_back(m_ii);
    }
#else
    identifier_list_identifier_list_identifier(identifier_list *il,const char *id) : m_il(il), m_id(id) {
        m_il->set_parent(this);
        m_children.push_back((AST_node**)&m_il);
    }
    virtual ~identifier_list_identifier_list_identifier(void) {
        delete m_il;
    }

    virtual void print(void) const {
        m_il->print();
        oprintf(", %s ",m_id);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TRANSLATE(m_il);
    }

    virtual identifier_list * clone(void) {
        identifier_list *copy = new identifier_list_identifier_list_identifier(m_il->clone(),m_id);
        copy->clone_copy(this);
        return copy;
    }

    virtual void flatten(check_vector<const char *> &flat_vec) {
        m_il->flatten(flat_vec);
        flat_vec.push_back(m_id);
    }
#endif

    AST_DEF_CHILDREN_1(m_il)
};

// ====================================================================

class type_name : public AST_node {
public:
    virtual ~type_name (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual PILLAR2C_CALLCONV get_call_conv_down(void) = 0;
    virtual type_name * clone(void) = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class type_name_specifier_qualifier_list : public type_name {
protected:
    specifier_qualifier_list *m_sql;
public:
    type_name_specifier_qualifier_list(specifier_qualifier_list *sql) : m_sql(sql) {
        m_sql->set_parent(this);
    }
    virtual ~type_name_specifier_qualifier_list(void) {
        delete m_sql;
    }

    virtual void print(void) const {
        m_sql->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_sql,tr);
        return tr;
    }

    virtual expression_type * get_type(void);

    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        return fix_cc_default(ST_NOT_DEFINED);
    }

    virtual type_name * clone(void) {
        type_name *copy = new type_name_specifier_qualifier_list(m_sql->clone());
        copy->clone_copy(this);
        return copy;
    }
    std::ostream & strprint(std::ostream &os) const {
        return m_sql->strprint(os);
    }

    AST_DEF_CHILDREN_1(m_sql)
};

class type_name_specifier_qualifier_list_abstract_declarator : public type_name {
protected:
    specifier_qualifier_list *m_sql;
    abstract_declarator      *m_ad;
public:
    type_name_specifier_qualifier_list_abstract_declarator(specifier_qualifier_list *sql, abstract_declarator *ad);
    virtual ~type_name_specifier_qualifier_list_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual expression_type * get_type(void);
    virtual PILLAR2C_CALLCONV get_call_conv_down(void);
    virtual type_name * clone(void);
    std::ostream & strprint(std::ostream &os) const;

    AST_DEF_CHILDREN_2(m_sql,m_ad)
};

// ====================================================================

class abstract_declarator : public AST_node {
public:
    virtual ~abstract_declarator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual struct_declarator * gen_struct_declarator(std::string arg_name) {
        return new struct_declarator_declarator(gen_declarator(arg_name));
    }

    virtual declarator * gen_declarator(const std::string &name) = 0;
    virtual abstract_declarator * clone(void) = 0;
    virtual abstract_declarator * add_pointer_star(void) {
        aeprintf("abstract_declarator::add_pointer_star not overloaded for %s.\n",typeid(this).name());
    }
    virtual abstract_declarator * remove_pointer_star(void) {
        aeprintf("abstract_declarator::remove_pointer_star not overloaded for %s.\n",typeid(this).name());
    }

    virtual abstract_declarator * add_another(abstract_declarator *ad);

    virtual pointer * get_pointer(void) {
        return NULL;
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("Some class didn't override get_call_conv.\n");
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        aeprintf("Some class didn't override add_explicit_call_conv.\n");
    }

    virtual bool is_pointer(void) const { return false; }
    virtual bool is_function(void) const { return false; }
    virtual abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        if(!is_function()) {
            aeprintf("vectorize_params called on non-function.\n");
        } else {
            aeprintf("vectorize_params not overloaded.\n");
        }
    }

    virtual bool operator==(const abstract_declarator *other) const {
        // FIX FIX FIX... this needs to be checked in each sub-class.
        if(typeid(*this) == typeid(*other)) {
            return true;
        } else {
            return false;
        }
    }
    virtual std::ostream & strprint(std::ostream &os) const = 0;
};

class abstract_declarator_pointer : public abstract_declarator {
protected:
    pointer *m_p;
public:
    abstract_declarator_pointer(pointer *p) : m_p(p) {
        m_p->set_parent(this);
    }
    virtual ~abstract_declarator_pointer(void) {
        delete m_p;
    }

    virtual void print(void) const {
        m_p->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_p,tr);
        return tr;
    }

    virtual declarator * gen_declarator(const std::string &name) {
        return new declarator_pointer_direct_declarator(
                m_p->clone(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(name))
               );
    }

    virtual abstract_declarator * clone(void) {
        abstract_declarator_pointer *copy = new abstract_declarator_pointer(m_p->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual abstract_declarator * add_pointer_star(void) {
        return new abstract_declarator_pointer(
                new pointer_star_pointer(
                 m_p->clone()
                )
               );
    }

    virtual abstract_declarator * remove_pointer_star(void) {
        pointer_star *ps = dynamic_cast<pointer_star*>(m_p);
        pointer_star_type_qualifier_list *pstql = dynamic_cast<pointer_star_type_qualifier_list*>(m_p);
        pointer_star_pointer *psp = dynamic_cast<pointer_star_pointer*>(m_p);
        pointer_star_type_qualifier_list_pointer *pstqlp = dynamic_cast<pointer_star_type_qualifier_list_pointer*>(m_p);
        if(ps || pstql) {
            return NULL;
        } else {
            if(psp) {
                return new abstract_declarator_pointer(
                    psp->get_pointer()->clone()
                   );
            } else {
                return new abstract_declarator_pointer(
                    pstqlp->get_pointer()->clone()
                   );
            }
        }
    }

    virtual pointer * get_pointer(void) {
        return m_p;
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return fix_cc_default(ST_NOT_DEFINED);
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc);

    virtual bool is_pointer(void) const { return true; }
    virtual std::ostream & strprint(std::ostream &os) const {
        return m_p->strprint(os);
    }

    AST_DEF_CHILDREN_1(m_p)
};

class abstract_declarator_direct_abstract_declarator : public abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
public:
    abstract_declarator_direct_abstract_declarator(direct_abstract_declarator *dad);
    virtual ~abstract_declarator_direct_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual PILLAR2C_CALLCONV get_call_conv(void);
    virtual std::ostream & strprint(std::ostream &os) const;
    virtual abstract_declarator * clone(void);
    virtual bool is_pointer(void) const;
    virtual abstract_declarator * remove_pointer_star(void);
    virtual abstract_declarator * add_pointer_star(void);
    virtual declarator * gen_declarator(const std::string &name);
    virtual bool is_function(void) const;
    virtual abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);

    AST_DEF_CHILDREN_1(m_dad)
};

class abstract_declarator_pointer_direct_abstract_declarator : public abstract_declarator {
protected:
    pointer *m_p;
    direct_abstract_declarator *m_dad;
public:
    abstract_declarator_pointer_direct_abstract_declarator(pointer *p,direct_abstract_declarator *dad);
    virtual ~abstract_declarator_pointer_direct_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return fix_cc_default(ST_NOT_DEFINED);
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc);

    virtual bool is_pointer(void) const { return true; }
    virtual bool is_function(void) const;
    virtual abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);
    virtual std::ostream & strprint(std::ostream &os) const;
    virtual abstract_declarator * clone(void);

    virtual abstract_declarator * remove_pointer_star(void);
    virtual declarator * gen_declarator(const std::string &name);

    AST_DEF_CHILDREN_2(m_p,m_dad)
};

class abstract_declarator_call_conv_specifier_pointer : public abstract_declarator {
protected:
    call_conv_specifier *m_ccs;
    pointer *m_p;
public:
    abstract_declarator_call_conv_specifier_pointer(call_conv_specifier *ccs,pointer *p) : m_ccs(ccs), m_p(p) {
        m_ccs->set_parent(this);
    }
    virtual ~abstract_declarator_call_conv_specifier_pointer(void) {
        delete m_ccs;
        delete m_p;
    }

    virtual void print(void) const {
        m_ccs->print();
        oprintf(" ");
        m_p->print();
    }

    virtual std::ostream & strprint(std::ostream &os) const {
        m_ccs->strprint(os);
        os << " ";
        return m_p->strprint(os);
    }

    virtual abstract_declarator * remove_pointer_star(void);

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_ccs,tr1);
        TRANSLATE(m_p,tr2);
        return TranslateResult();
    }

    virtual declarator * gen_declarator(const std::string &name) {
        return new declarator_call_conv_specifier_pointer_direct_declarator(
                m_ccs->clone(),
                m_p->clone(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(name))
               );
    }

    virtual pointer * get_pointer(void) {
        return m_p;
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_ccs->get_call_conv();
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        assert(cc == m_ccs->get_call_conv());
    }

    virtual bool is_pointer(void) const { return true; }

    virtual abstract_declarator * clone(void) {
        abstract_declarator *copy = new abstract_declarator_call_conv_specifier_pointer(m_ccs->clone(),m_p->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_ccs,m_p)
};

class abstract_declarator_call_conv_specifier_direct_abstract_declarator : public abstract_declarator {
protected:
    call_conv_specifier *m_ccs;
    direct_abstract_declarator *m_dad;
public:
    abstract_declarator_call_conv_specifier_direct_abstract_declarator(call_conv_specifier *ccs,direct_abstract_declarator *dad);
    virtual ~abstract_declarator_call_conv_specifier_direct_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_ccs->get_call_conv();
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        assert(cc == m_ccs->get_call_conv());
    }

    virtual abstract_declarator * clone(void);

    virtual std::ostream & strprint(std::ostream &os) const;
    virtual bool is_pointer(void) const;
    virtual bool is_function(void) const;
    virtual abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);
    virtual declarator * gen_declarator(const std::string &name) {
        aeprintf("abstract_declarator::gen_declarator not overloaded for %s.\n",typeid(this).name());
    }

    AST_DEF_CHILDREN_2(m_ccs,m_dad)
};

class abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator : public abstract_declarator {
protected:
    call_conv_specifier *m_ccs;
    pointer *m_p;
    direct_abstract_declarator *m_dad;
public:
    abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(call_conv_specifier *ccs,pointer *p,direct_abstract_declarator *dad);
    virtual ~abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_ccs->get_call_conv();
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        assert(cc == m_ccs->get_call_conv());
    }

    virtual bool is_pointer(void) const { return true; }
    virtual bool is_function(void) const;

    virtual abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis);

    virtual std::ostream & strprint(std::ostream &os) const;
    virtual abstract_declarator * clone(void);

    virtual abstract_declarator * remove_pointer_star(void);
    virtual declarator * gen_declarator(const std::string &name) {
        aeprintf("abstract_declarator::gen_declarator not overloaded for %s.\n",typeid(this).name());
    }

    AST_DEF_CHILDREN_3(m_ccs,m_p,m_dad)
};

// ====================================================================

class direct_abstract_declarator : public AST_node {
public:
    virtual ~direct_abstract_declarator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        aeprintf("Some class didn't override get_call_conv.\n");
    }
    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        print();
        printf("\n");
        get_parent()->print();
        printf("\n");
        get_parent()->get_parent()->print();
        printf("\n");
        aeprintf("Some class didn't override add_explicit_call_conv.\n");
    }
    virtual direct_abstract_declarator * clone(void) = 0;
    virtual std::ostream & strprint(std::ostream &os) const = 0;
    virtual bool is_pointer(void) const {  return false; }
    virtual bool is_function(void) const { return false; }
    virtual direct_abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        if(!is_function()) {
            aeprintf("vectorize_params called on non-function.\n");
        } else {
            aeprintf("vectorize_params not overloaded.\n");
        }
    }

    virtual direct_abstract_declarator * remove_pointer_star(void) {
        aeprintf("Some class didn't override remove_pointer_star.\n");
    }
    virtual direct_declarator * gen_direct_declarator(const std::string &name) {
        aeprintf("Some class didn't override gen_direct_declarator.\n");
    }
};

class direct_abstract_declarator_abstract_declarator : public direct_abstract_declarator {
protected:
    abstract_declarator *m_ad;
public:
    direct_abstract_declarator_abstract_declarator(abstract_declarator *ad) : m_ad(ad) {
        m_ad->set_parent(this);
    }
    virtual ~direct_abstract_declarator_abstract_declarator(void) {
        delete m_ad;
    }

    virtual void print(void) const {
        oprintf(" ( ");
        m_ad->print();
        oprintf(" ) ");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << " ( ";
        m_ad->strprint(os);
        os << " ) ";
        return os;
    }

    virtual bool is_pointer(void) const {
        return m_ad->is_pointer();
    }
    virtual bool is_function(void) const {
        return m_ad->is_function();
    }

    virtual direct_abstract_declarator * remove_pointer_star(void) {
        assert(is_pointer());
        abstract_declarator *ad = m_ad->remove_pointer_star();
        if(ad) {
            return new direct_abstract_declarator_abstract_declarator(ad);
        } else {
            return NULL;
        }
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ad,tr);
        return tr;
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_ad->get_call_conv();
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        m_ad->add_explicit_call_conv(cc);
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_abstract_declarator(m_ad->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual direct_declarator * gen_direct_declarator(const std::string &name) {
        return new direct_declarator_paren_declarator(m_ad->gen_declarator(name));
    }

    AST_DEF_CHILDREN_1(m_ad)
};

class direct_abstract_declarator_empty_braces : public direct_abstract_declarator {
public:
    virtual void print(void) const {
        oprintf(" [ ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        os << " [ ] ";
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_empty_braces();
        copy->clone_copy(this);
        return copy;
    }
};

class direct_abstract_declarator_assignment_expression : public direct_abstract_declarator {
protected:
    assignment_expression *m_ae;
public:
    direct_abstract_declarator_assignment_expression(assignment_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
    }
    virtual ~direct_abstract_declarator_assignment_expression(void) {
        delete m_ae;
    }

    virtual void print(void) const {
        oprintf(" [ ");
        m_ae->print();
        oprintf(" ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ae,tr);
        return tr;
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_assignment_expression(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ae)
};

class direct_abstract_declarator_direct_abstract_declarator_empty_braces : public direct_abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
public:
    direct_abstract_declarator_direct_abstract_declarator_empty_braces(direct_abstract_declarator *dad) : m_dad(dad) {
        m_dad->set_parent(this);
    }
    virtual ~direct_abstract_declarator_direct_abstract_declarator_empty_braces(void) {
        delete m_dad;
    }

    virtual void print(void) const {
        m_dad->print();
        oprintf(" [ ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_dad,tr);
        return tr;
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_direct_abstract_declarator_empty_braces(m_dad->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_pointer(void) const {
        return m_dad->is_pointer();
    }

    virtual direct_abstract_declarator * remove_pointer_star(void) {
        assert(is_pointer());
        direct_abstract_declarator *new_dad = m_dad->remove_pointer_star();
        if(new_dad) {
            return new direct_abstract_declarator_direct_abstract_declarator_empty_braces(new_dad);
        } else {
            aeprintf("Don't think this should ever happen.\n");
            return NULL;
        }
    }

    AST_DEF_CHILDREN_1(m_dad)
};

class direct_abstract_declarator_direct_abstract_declarator_assignment_expression : public direct_abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
    assignment_expression *m_ae;
public:
    direct_abstract_declarator_direct_abstract_declarator_assignment_expression(direct_abstract_declarator *dad,assignment_expression *ae) : m_dad(dad), m_ae(ae) {
        m_dad->set_parent(this);
        m_ae->set_parent(this);
    }
    virtual ~direct_abstract_declarator_direct_abstract_declarator_assignment_expression(void) {
        delete m_dad;
        delete m_ae;
    }

    virtual void print(void) const {
        m_dad->print();
        oprintf(" [ ");
        m_ae->print();
        oprintf(" ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_dad,tr1);
        TRANSLATE(m_ae,tr2);
        aeprintf("type problem\n");
        // FIX FIX FIX combine tr1 and tr2
        return tr1;
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_direct_abstract_declarator_assignment_expression(m_dad->clone(),m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_dad,m_ae)
};

class direct_abstract_declarator_brace_star : public direct_abstract_declarator {
public:
    virtual void print(void) const {
        oprintf(" [ * ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_brace_star();
        copy->clone_copy(this);
        return copy;
    }
};

class direct_abstract_declarator_direct_abstract_declarator_brace_star : public direct_abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
public:
    direct_abstract_declarator_direct_abstract_declarator_brace_star(direct_abstract_declarator *dad) : m_dad(dad) {
        m_dad->set_parent(this);
    }
    virtual ~direct_abstract_declarator_direct_abstract_declarator_brace_star(void) {
        delete m_dad;
    }

    virtual void print(void) const {
        m_dad->print();
        oprintf(" [ * ] ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_dad,tr);
        return tr;
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dad->get_call_conv();
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_direct_abstract_declarator_brace_star(m_dad->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_dad)
};

class direct_abstract_declarator_empty_paren : public direct_abstract_declarator {
public:
    virtual void print(void) const {
        oprintf(" ( ) ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_empty_paren();
        copy->clone_copy(this);
        return copy;
    }
};

class direct_abstract_declarator_paren_parameter_type_list : public direct_abstract_declarator {
protected:
    parameter_type_list *m_ptl;
public:
    direct_abstract_declarator_paren_parameter_type_list(parameter_type_list *ptl) : m_ptl(ptl) {
        m_ptl->set_parent(this);
    }
    virtual ~direct_abstract_declarator_paren_parameter_type_list(void) {
        delete m_ptl;
    }

    virtual void print(void) const {
        oprintf(" ( ");
        m_ptl->print();
        oprintf(" ) ");
    }

    virtual bool is_function(void) const {
        return true;
    }
    virtual direct_abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_ptl->vectorize(params,ellipsis);
        aeprintf("not implemented yet.\n");
    }


    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ptl,tr);
        return tr;
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_paren_parameter_type_list(m_ptl->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ptl)
};

class direct_abstract_declarator_direct_abstract_declarator_empty_parens : public direct_abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
public:
    direct_abstract_declarator_direct_abstract_declarator_empty_parens(direct_abstract_declarator *dad) : m_dad(dad) {
        m_dad->set_parent(this);
    }
    virtual ~direct_abstract_declarator_direct_abstract_declarator_empty_parens(void) {
        delete m_dad;
    }

    virtual void print(void) const {
        m_dad->print();
        oprintf(" ( ) ");
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dad->get_call_conv();
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_direct_abstract_declarator_empty_parens(m_dad->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        m_dad->add_explicit_call_conv(cc);
    }

    AST_DEF_CHILDREN_1(m_dad)
};

class direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list : public direct_abstract_declarator {
protected:
    direct_abstract_declarator *m_dad;
    parameter_type_list *m_ptl;
public:
    direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(direct_abstract_declarator *dad,parameter_type_list *ptl) : m_dad(dad), m_ptl(ptl) {
        m_dad->set_parent(this);
        m_ptl->set_parent(this);
    }
    virtual ~direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(void) {
        delete m_dad;
        delete m_ptl;
    }

    virtual void print(void) const {
        m_dad->print();
        oprintf(" ( ");
        m_ptl->print();
        oprintf(" ) ");
    }

    virtual bool is_function(void) const {
        return true;
    }
    virtual direct_abstract_declarator * vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
        m_ptl->vectorize(params,ellipsis);

        if(dynamic_cast<direct_abstract_declarator_abstract_declarator*>(m_dad) != NULL) {
            return m_dad->clone();
        } else {
            aeprintf("Should not get here.\n");
        }
    }

    virtual void add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
        m_dad->add_explicit_call_conv(cc);
    }

    std::ostream & strprint(std::ostream &os) const {
        aeprintf("Finish.\n");
        return os;
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_dad,tr1);
        TRANSLATE(m_ptl,tr2);

        if(!g_intel64) {
            m_dad->add_explicit_call_conv(m_dad->get_call_conv());
        }

#if 1
        if(get_call_conv() == ST_PDECL) {
//        if(cc_to_man_unman(get_call_conv()) == MU_MANAGED) {
            parameter_list *extra_params = gen_extra_params();
            m_ptl->prepend_params(extra_params);
        }
#endif

        return TranslateResult();
    }

    virtual PILLAR2C_CALLCONV get_call_conv(void) {
        return m_dad->get_call_conv();
    }
    virtual PILLAR2C_CALLCONV get_call_conv_down(void) {
        return get_call_conv();
    }

    virtual direct_abstract_declarator * clone(void) {
        direct_abstract_declarator *copy = new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(m_dad->clone(),m_ptl->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual bool is_pointer(void) const {
        return m_dad->is_pointer();
    }

    virtual direct_abstract_declarator * remove_pointer_star(void) {
        assert(is_pointer());
        direct_abstract_declarator *new_dad = m_dad->remove_pointer_star();
        if(new_dad) {
            return new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(new_dad,m_ptl->clone());
        } else {
            aeprintf("Don't think this should ever happen.\n");
            return NULL;
        }
    }

    virtual direct_declarator * gen_direct_declarator(const std::string &name) {
        return new direct_declarator_direct_declarator_parameter_type_list(
            m_dad->gen_direct_declarator(name),
            m_ptl->clone());
    }


    AST_DEF_CHILDREN_2(m_dad,m_ptl)
};

// ====================================================================

class initializer : public AST_node {
public:
    virtual ~initializer (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) = 0;
    virtual initializer * clone(void) = 0;
};

class initializer_assignment_expression : public initializer {
protected:
    assignment_expression *m_ae;
public:
    initializer_assignment_expression(assignment_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
    }
    virtual ~initializer_assignment_expression(void) {
        delete m_ae;
    }

    virtual void print(void) const {
        m_ae->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ae,tr);
        return tr;
    }

    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw);

    virtual initializer * clone(void) {
        initializer *copy = new initializer_assignment_expression(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual assignment_expression * claim_assignment_expression(void) {
        assignment_expression * temp = m_ae;
        m_ae = NULL;
        return temp;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    AST_DEF_CHILDREN_1(m_ae)
};

class initializer_initializer_list : public initializer {
protected:
    initializer_list *m_il;
public:
    initializer_initializer_list(initializer_list *il);
    virtual ~initializer_initializer_list(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw);
    virtual initializer * clone(void);

    AST_DEF_CHILDREN_1(m_il)
};

class initializer_initializer_list_comma : public initializer {
protected:
    initializer_list *m_il;
public:
    initializer_initializer_list_comma(initializer_list *il);
    virtual ~initializer_initializer_list_comma(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw);
    virtual initializer * clone(void);

    AST_DEF_CHILDREN_1(m_il)
};

// ====================================================================

class initializer_list : public AST_node {
public:
    virtual ~initializer_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) = 0;
    virtual initializer_list * clone(void) = 0;
};

class initializer_list_initializer : public initializer_list {
protected:
    initializer *m_i;
public:
    initializer_list_initializer(initializer *i) : m_i(i) {
        m_i->set_parent(this);
    }
    virtual ~initializer_list_initializer(void) {
        delete m_i;
    }

    virtual void print(void) const {
        m_i->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_i,tr);
        return tr;
    }

    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) {
        return m_i->gen_initializer_block_item(diw);
    }

    virtual initializer_list * clone(void) {
        initializer_list *copy = new initializer_list_initializer(m_i->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_i)
};

class initializer_list_designation_initializer : public initializer_list {
protected:
    designation *m_d;
    initializer *m_i;
public:
    initializer_list_designation_initializer(designation *d,initializer *i);
    virtual ~initializer_list_designation_initializer(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) {
        diw.set_designation(m_d);
        std::list<block_item *> ret_list = m_i->gen_initializer_block_item(diw);
        diw.set_designation(NULL);
        return ret_list;
    }

    virtual initializer_list * clone(void);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    AST_DEF_CHILDREN_2(m_d,m_i)
};

class initializer_list_initializer_list_initializer : public initializer_list {
protected:
    initializer_list *m_il;
    initializer *m_i;
public:
    initializer_list_initializer_list_initializer(initializer_list *il,initializer *i) : m_il(il), m_i(i) {
        m_il->set_parent(this);
        m_i->set_parent(this);
    }
    virtual ~initializer_list_initializer_list_initializer(void) {
        delete m_il;
        delete m_i;
    }

    virtual void print(void) const {
        m_il->print();
        oprintf(" , ");
        m_i->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_il,tr1);
        TRANSLATE(m_i,tr2);
        return TranslateResult();
    }

    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) {
        std::list<block_item *> ret_list = m_il->gen_initializer_block_item(diw);
        diw.next_index();
        std::list<block_item *> splice_list = m_i->gen_initializer_block_item(diw);
        ret_list.splice(ret_list.end(),splice_list);
        return ret_list;
    }

    virtual initializer_list * clone(void) {
        initializer_list *copy = new initializer_list_initializer_list_initializer(m_il->clone(),m_i->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_il,m_i)
};

class initializer_list_initializer_list_designation_initializer : public initializer_list {
protected:
    initializer_list *m_il;
    designation *m_d;
    initializer *m_i;
public:
    initializer_list_initializer_list_designation_initializer(initializer_list *il,designation *d,initializer *i);
    virtual ~initializer_list_initializer_list_designation_initializer(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual std::list<block_item *> gen_initializer_block_item(decl_init_wrapper &diw) {
        std::list<block_item *> ret_list = m_il->gen_initializer_block_item(diw);
        diw.set_designation(m_d);
        std::list<block_item *> splice_list = m_i->gen_initializer_block_item(diw);
        ret_list.splice(ret_list.end(),splice_list);
        diw.set_designation(NULL);
        return ret_list;
    }

    virtual initializer_list * clone(void);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    AST_DEF_CHILDREN_3(m_il,m_d,m_i)
};

// ====================================================================

class designator : public AST_node {
public:
    virtual ~designator (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) = 0;
    virtual designator * clone(void) = 0;
};

class designator_braces_constant_expression : public designator {
protected:
    constant_expression *m_ce;
public:
    designator_braces_constant_expression(constant_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~designator_braces_constant_expression(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        oprintf(" [ ");
        m_ce->print();
        oprintf(" ] ");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ce,tr);
        return tr;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) {
        aeprintf("gen_postfix_expression_for_init\n");
    }

    virtual designator * clone(void) {
        designator *copy = new designator_braces_constant_expression(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

class designator_dot_identifier : public designator {
protected:
    const char *m_id;
public:
    designator_dot_identifier(const char *id) : m_id(id) {}

    virtual void print(void) const {
        oprintf(".%s",m_id);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    const char * get_id(void) const {
        return m_id;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) {
        return new postfix_expression_postfix_expression_dot_identifier(
                   diw.gen_postfix_expression(),
                   m_id
               );
    }

    virtual designator * clone(void) {
        designator *copy = new designator_dot_identifier(m_id);
        copy->clone_copy(this);
        return copy;
    }
};

// ====================================================================

class designator_list : public AST_node {
public:
    virtual ~designator_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) = 0;
    virtual designator_list * clone(void) = 0;
};

class designator_list_designator : public designator_list {
protected:
    designator *m_d;
public:
    designator_list_designator(designator *d) : m_d(d) {
        m_d->set_parent(this);
    }
    virtual ~designator_list_designator(void) {
        delete m_d;
    }

    virtual void print(void) const {
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_d,tr);
        return tr;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) {
        return m_d->gen_postfix_expression_for_init(diw);
    }

    virtual designator_list * clone(void) {
        designator_list *copy = new designator_list_designator(m_d->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_d)
};

class designator_list_designator_list_designator : public designator_list {
protected:
    designator_list *m_dl;
    designator *m_d;
public:
    designator_list_designator_list_designator(designator_list *dl,designator *d) : m_dl(dl), m_d(d) {
        m_dl->set_parent(this);
        m_d->set_parent(this);
    }
    virtual ~designator_list_designator_list_designator(void) {
        delete m_dl;
        delete m_d;
    }

    virtual void print(void) const {
        m_dl->print();
        oprintf(" ");
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_dl,tr1);
        TRANSLATE(m_d,tr2);
        aeprintf("type problem\n");
        // FIX FIX FIX combine tr1 and tr2
        return tr1;
    }


    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) {
        assert(0); // what to do here?
        return m_d->gen_postfix_expression_for_init(diw);
    }

    virtual designator_list * clone(void) {
        designator_list *copy = new designator_list_designator_list_designator(m_dl->clone(),m_d->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_dl,m_d)
};

// ====================================================================

class designation : public AST_node {
public:
    virtual ~designation (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) = 0;
    virtual designation * clone(void) = 0;
};

class designation_designator_list : public designation {
protected:
    designator_list *m_dl;
public:
    designation_designator_list(designator_list *dl) : m_dl(dl) {
        m_dl->set_parent(this);
    }
    virtual ~designation_designator_list(void) {
        delete m_dl;
    }

    virtual void print(void) const {
        m_dl->print();
        oprintf(" = ");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_dl,tr);
        return tr;
    }

    virtual postfix_expression * gen_postfix_expression_for_init(decl_init_wrapper &diw) {
        return m_dl->gen_postfix_expression_for_init(diw);
    }

    virtual designation * clone(void) {
        designation *copy = new designation_designator_list(m_dl->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_dl)
};

// ====================================================================

#ifdef VERIFY_STMT_LIVE
std::set<void*> g_stmts;
#endif // VERIFY_STMT_LIVE

class statement : public AST_node {
protected:
    check_vector<ii_ptr > m_cuts_to;

    virtual void base_translate(function_definition *fd);

    basic_block *m_bb;
public:
    void set_bb(basic_block *bb) {
#ifdef VERIFY_STMT_LIVE
        if(g_stmts.find((void*)this) == g_stmts.end()) {
            aeprintf("Accessing a non-existent check_vector.\n");
        }
#endif // VERIFY_STMT_LIVE
        m_bb = bb;
    }

    statement(void) : m_bb(NULL) {
#ifdef VERIFY_STMT_LIVE
        g_stmts.insert(this);
#endif // VERIFY_STMT_LIVE
    }
    statement(const statement &other) {
        aeprintf("Copy constructor called for statement.\n");
    }

    virtual ~statement (void);
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual statement * append(block_item_list *bil);
    virtual bool is_label(const char *label_name) {
        return false;
    }
    virtual statement * clone(void) = 0;
    virtual statement * prepend_bil(block_item_list *bil);
    virtual void add_to_statement_cut(const check_vector<ii_ptr > &cuts) {
        size_t i;
        for(i = 0; i< cuts.size(); ++i) {
            m_cuts_to.push_back(cuts[i]);
        }
    }

    virtual bool value_used(AST_node *node) {
        return false;
    }

    void cut_print(const AST_node *statement) const {
        if(g_use_try_except && m_cuts_to.size()) {
            oprintf("{\n");
            oprintf("__try {\n");
        }

        statement->print();

        if(g_use_try_except && m_cuts_to.size()) {
            oprintf("}\n");
            oprintf("__except(_pillar2c_filter_%d(_exception_code(),_exception_info(),&_pillar2c_except_var",m_cuts_to.size());
            size_t cut_index;
            for(cut_index = 0; cut_index < m_cuts_to.size(); ++cut_index) {
                oprintf(",");
                oprintf("&%s",m_cuts_to[cut_index]->get_continuation_var_string().c_str());
            }
            oprintf(")) {\n");
            for(cut_index = 0; cut_index < m_cuts_to.size(); ++cut_index) {
                oprintf("if (&%s == _pillar2c_except_var) {\n",m_cuts_to[cut_index]->get_continuation_var_string().c_str());
                oprintf("goto %s;\n",m_cuts_to[cut_index]->get_continuation_label_string().c_str());
                oprintf("}\n");
            }
            oprintf("}\n");
            oprintf("}\n");
        }
    }

    void generate_filters(function_definition *fd);

    virtual unsigned count_cases(void) {
        return 0;
    }
};

// basic_block - everything done
class statement_labeled_statement : public statement {
protected:
    labeled_statement *m_s;
public:
    statement_labeled_statement(labeled_statement *s);
    virtual ~statement_labeled_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual bool is_label(const char *label_name);
    virtual statement * clone(void);
    virtual unsigned count_cases(void);

    AST_DEF_CHILDREN_1(m_s)
};


// basic_block - nothing to do
class statement_compound_statement : public statement {
protected:
    compound_statement *m_s;
public:
    statement_compound_statement(compound_statement *s);
    virtual ~statement_compound_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual statement * append(block_item_list *bil);
    virtual statement * clone(void);
    virtual statement_compound_statement * prepend_bil(block_item_list *bil);
    virtual compound_statement * get_compound_statement(void) const { return m_s; }
    virtual unsigned count_cases(void);

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - nothing to do
class statement_PRT_NOYIELD_compound_statement : public statement {
protected:
    compound_statement *m_s;
    bool m_post_translate;
public:
    statement_PRT_NOYIELD_compound_statement(compound_statement *s);
    virtual ~statement_PRT_NOYIELD_compound_statement(void);

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool in_no_yield_block(void) {
        return true;
    }
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_s)
};

class statement_PRT_VSE_compound_statement : public statement {
protected:
    ii_ptr m_ii;
    compound_statement *m_s;
    bool m_post_translate;
public:
    statement_PRT_VSE_compound_statement(ii_ptr ii, compound_statement *s);
    virtual ~statement_PRT_VSE_compound_statement(void);

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual statement * clone(void);

    ii_ptr  get_continuation_id(void) const {
        return m_ii;
    }

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - nothing to do
class statement_expression_statement : public statement {
protected:
    expression_statement *m_s;
    bool m_inactive;
public:
    statement_expression_statement(expression_statement *s);
    virtual ~statement_expression_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void sub_destroyed(AST_node *node);
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - everything done
class statement_selection_statement : public statement {
protected:
    selection_statement *m_s;
public:
    statement_selection_statement(selection_statement *s);
    virtual ~statement_selection_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - nothing to do
class statement_pcall_call_expression : public statement {
protected:
    call_expression *m_ce;
public:
    statement_pcall_call_expression(call_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    ~statement_pcall_call_expression(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        oprintf("pcall ");
        m_ce->print();
        oprintf(";\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_ce)
};

// basic_block - everything done
class statement_iteration_statement : public statement {
protected:
    iteration_statement *m_s;
public:
    statement_iteration_statement(iteration_statement *s);
    virtual ~statement_iteration_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - need to implement continue and figure what to do for the cut-to variants
class statement_jump_statement : public statement {
protected:
    jump_statement *m_s;
public:
    statement_jump_statement(jump_statement *s);
    virtual ~statement_jump_statement(void);

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual statement * clone(void);

    AST_DEF_CHILDREN_1(m_s)
};

// basic_block - can't analyze so disable optimizations?
// FIX FIX FIX
class statement_UUASM : public statement {
protected:
    std::string m_asm;
public:
    statement_UUASM(const std::string &uuasm) : m_asm(uuasm) {}

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);
    virtual statement * clone(void);
};

// basic_block - can't analyze so disable optimizations?
// FIX FIX FIX
class statement_UUASMUU : public statement {
protected:
    std::string m_asm;
public:
    statement_UUASMUU(const std::string &uuasm) : m_asm(uuasm) {}

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);
    virtual statement * clone(void);
};

// basic_block - can't analyze so disable optimizations?
// FIX FIX FIX
class statement_UASM : public statement {
protected:
    std::string m_asm;
public:
    statement_UASM(const std::string &uasm) : m_asm(uasm) {}

    virtual void print(void) const;
    virtual TranslateResult translate_pillar(function_definition *fd);
    virtual void create_call_graph(function_definition *fd);
    virtual statement * clone(void);
};

class statement_prt_tailcall : public statement {
protected:
    call_expression *m_ce;
public:
    statement_prt_tailcall(call_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~statement_prt_tailcall(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        aeprintf("Should never emit a Pillar construct, tailcall.\n");
/*
        printf("return tailcall ");
        m_ce->print();
        printf(" ;");
*/
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return false;
    }
#endif

    virtual void create_call_graph(function_definition *fd);

    virtual statement_prt_tailcall * clone(void) {
        statement_prt_tailcall *copy = new statement_prt_tailcall(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};


// ====================================================================

class statement_list : public AST_node {
public:
    virtual ~statement_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
};

class statement_list_statement : public statement_list {
protected:
    statement *m_s;
public:
    statement_list_statement(statement *s) : m_s(s) {
        m_s->set_parent(this);
    }
    virtual ~statement_list_statement(void) {
        delete m_s;
    }

    AST_DEF_CHILDREN_1(m_s)
};

class statement_list_statement_list_statement : public statement_list {
protected:
    statement_list *m_sl;
    statement *m_s;
public:
    statement_list_statement_list_statement(statement_list *sl,statement *s) : m_sl(sl), m_s(s) {
        m_sl->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~statement_list_statement_list_statement(void) {
        delete m_sl;
        delete m_s;
    }

    AST_DEF_CHILDREN_2(m_sl,m_s)
};

// ====================================================================

class labeled_statement : public AST_node {
public:
    virtual ~labeled_statement (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual bool is_label(const char *label_name) {
        return false;
    }
    virtual labeled_statement * clone(void) = 0;
    virtual unsigned count_cases(void) = 0;
};

class labeled_statement_identifier : public labeled_statement {
protected:
    std::string m_id;
    statement *m_s;
    bool m_is_translated_pillar_continuation;
    unsigned m_reference_count;
public:
    labeled_statement_identifier(const std::string &id,statement *s, bool for_pillar_continuation=false) : m_id(id), m_s(s), m_is_translated_pillar_continuation(for_pillar_continuation), m_reference_count(0) {
        m_s->set_parent(this);
    }
    virtual ~labeled_statement_identifier(void) {
        delete m_s;
    }

    virtual void print(void) const;

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool is_label(const char *label_name) {
        return strcmp(label_name,m_id.c_str()) == 0 ? true : false;
    }

    virtual labeled_statement * clone(void) {
        labeled_statement *copy = new labeled_statement_identifier(m_id,m_s->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual unsigned count_cases(void) {
        return 0;
    }

    virtual void add_reference(void) {
        m_reference_count++;
    }

    AST_DEF_CHILDREN_1(m_s)
};

class labeled_statement_continuation : public labeled_statement {
protected:
    continuation_type *m_ct;
    ii_ptr m_ii;
    identifier_list *m_il;
    statement *m_s;
public:
    labeled_statement_continuation(continuation_type *ct,ii_ptr ii,identifier_list *il,statement *s) : m_ct(ct), m_ii(ii), m_il(il), m_s(s) {
        m_ct->set_parent(this);
        m_s->set_parent(this);
        if(m_il) {
            m_il->set_parent(this);
        }
    }

    virtual ~labeled_statement_continuation(void) {
        delete m_ct;
        delete m_s;
        delete m_il;
    }

    virtual void print(void) const {
        aeprintf("FIX\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool is_label(const char *label_name) {
        return false;
    }

    virtual labeled_statement * clone(void) {
        labeled_statement *copy = new labeled_statement_continuation(m_ct,m_ii,m_il ? m_il->clone() : NULL,m_s->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual unsigned count_cases(void) {
        return 0;
    }

    virtual unsigned get_num_children(void) const {
        if(m_il) return 3;
        else     return 2;
    }
    virtual AST_node **begin_child_iter(void) const {
        return (AST_node**)&m_ct;
    }
    virtual AST_node **next_child_iter(AST_node **cur) const {
        if(cur == (AST_node**)&m_ct)  {
            return (AST_node**)&m_s;
        } else if(cur == (AST_node**)&m_s) {
            if(m_il) {
                return (AST_node**)&m_il;
            } else {
                return NULL;
            }
        } else if(cur == (AST_node**)&m_il) {
            return NULL;
        } else aeprintf("next_child_iter problem");
    }
};

class labeled_statement_default : public labeled_statement {
protected:
    statement *m_s;
public:
    labeled_statement_default(statement *s) : m_s(s) {
        m_s->set_parent(this);
    }
    virtual ~labeled_statement_default(void) {
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("default : ");
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual labeled_statement * clone(void) {
        labeled_statement *copy = new labeled_statement_default(m_s->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual unsigned count_cases(void) {
        found_default();
        statement_labeled_statement *sls = dynamic_cast<statement_labeled_statement*>(m_s);
        if(sls) {
            return 1 + sls->count_cases();
        } else {
            return 1;
        }
    }

    AST_DEF_CHILDREN_1(m_s)
};

class labeled_statement_case : public labeled_statement {
protected:
    constant_expression *m_ce;
    statement *m_s;
public:
    labeled_statement_case(constant_expression *ce,statement *s) : m_ce(ce), m_s(s) {
        m_ce->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~labeled_statement_case(void) {
        delete m_ce;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("case ");
        m_ce->print();
        oprintf(" : ");
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual labeled_statement * clone(void) {
        labeled_statement *copy = new labeled_statement_case(m_ce->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }
    virtual unsigned count_cases(void) {
        statement_labeled_statement *sls = dynamic_cast<statement_labeled_statement*>(m_s);
        if(sls) {
            return 1 + sls->count_cases();
        } else {
            return 1;
        }
    }

    AST_DEF_CHILDREN_2(m_ce,m_s)
};

// ====================================================================

class block_item : public AST_node {
protected:
    unsigned m_line_number;
public:
    block_item(unsigned line_number) : m_line_number(line_number) {}
    virtual ~block_item (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif
    virtual block_item * get_block_item(void) {
        return this;
    }
    virtual bool is_label(const char *label_name) {
        return false;
    }
    virtual block_item * clone(void) = 0;

    virtual unsigned count_cases(void) {
        return 0;
    }
    virtual unsigned get_line_number(void) const {
        return m_line_number;
    }
};

class block_item_declaration : public block_item {
protected:
    declaration *m_d;
    bool m_should_split;
    check_vector<ii_ptr > m_cuts_to;
public:
    block_item_declaration(declaration *d,unsigned line_number) : block_item(line_number), m_d(d), m_should_split(false) {
        m_d->set_parent(this);
    }
    virtual ~block_item_declaration(void) {
        delete m_d;
    }

    virtual void print(void) const {
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_d) {
            delete m_d;
            m_d = NULL;
            m_parent->sub_destroyed(this);
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual block_item * clone(void) {
        block_item_declaration *copy = new block_item_declaration(m_d->clone(),m_line_number);
        copy->clone_copy(this);
        return copy;
    }

    virtual void add_to_statement_cut(const check_vector<ii_ptr > &cuts) {
        if(cuts.size()) {
            m_should_split = true;
            size_t i;
            for(i = 0; i< cuts.size(); ++i) {
                m_cuts_to.push_back(cuts[i]);
            }
        }
    }

    virtual void split_initializer(void);

    AST_DEF_CHILDREN_1(m_d)
};

class block_item_statement : public block_item {
protected:
    statement *m_s;
public:
    block_item_statement(statement *s,unsigned line_number) : block_item(line_number), m_s(s) {
        m_s->set_parent(this);
    }
    virtual ~block_item_statement(void) {
        delete m_s;
    }

    virtual void print(void) const {
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_s,tr);
        return tr;
    }

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_s) {
            delete m_s;
            m_s = NULL;
            m_parent->sub_destroyed(this);
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual bool is_label(const char *label_name) {
        return m_s->is_label(label_name);
    }

    statement * get_statement(void) {
        return m_s;
    }

    virtual block_item * clone(void) {
        block_item_statement *copy = new block_item_statement(m_s->clone(),m_line_number);
        copy->clone_copy(this);
        return copy;
    }

    virtual unsigned count_cases(void) {
        return m_s->count_cases();
    }

    AST_DEF_CHILDREN_1(m_s)
};

class block_item_text : public block_item {
protected:
    std::string m_text;
public:
    block_item_text(const std::string &et) : block_item(0), m_text(et) {}
   ~block_item_text(void) {}

    virtual void print(void) const {
        oprintf(m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        aeprintf("emit_text should be created but never processed by translate_pillar.\n");
    }

    virtual block_item * clone(void) {
        aeprintf("emit_text should be created but never processed by clone.\n");
    }
};

class block_item_pound_line : public block_item {
protected:
    std::string m_text;
public:
    block_item_pound_line(const std::string &text) : block_item(0), m_text(text) {}

    virtual void print(void) const {
        oprintf("%s\n",m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual block_item * clone(void) {
        block_item_pound_line *copy = new block_item_pound_line(m_text);
        copy->clone_copy(this);
        return copy;
    }
};


// ====================================================================

class block_item_list : public AST_node {
public:
    virtual ~block_item_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual block_item_list * prepend_bil(block_item_list *bil) = 0;
    virtual void insert_post_declarations(block_item_list *bil) = 0;
    virtual void append(block_item_list *bil) = 0;
    virtual void remove_and_delete(void) = 0;
    virtual block_item_list * clone(void) = 0;
    virtual unsigned count_cases(void) = 0;
};

class block_item_list_block_item : public block_item_list {
protected:
    block_item *m_bi;
public:
    block_item_list_block_item(block_item *bi) : m_bi(bi) {
        m_bi->set_parent(this);
    }
    virtual ~block_item_list_block_item(void) {
        delete m_bi;
    }

    virtual block_item_list * clone(void) {
        block_item_list_block_item *copy = new block_item_list_block_item(m_bi->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        m_bi->print();
//        oprintf("\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_bi,tr);
        return tr;
    }

    virtual block_item_list * prepend_bil(block_item_list *bil);
    virtual void sub_destroyed(AST_node *node);
    virtual void insert_post_declarations(block_item_list *bil);
    virtual void append(block_item_list *bil);
    virtual void insert_before_statement(block_item_list *bil) {
        // insert before this is the same as prepend since it is the
        // first block item.
        prepend_bil(bil);
    }

    friend class block_item_list_block_item_list_block_item;

    virtual void replace_block_item(block_item *bi) {
        delete m_bi;
        m_bi = bi;
    }

    virtual void remove_and_delete(void);

    virtual unsigned count_cases(void) {
        return m_bi->count_cases();
    }

    AST_DEF_CHILDREN_1(m_bi)
};

class block_item_list_block_item_list_block_item : public block_item_list {
protected:
    block_item_list *m_bil;
    block_item *m_bi;
public:
    block_item_list_block_item_list_block_item(block_item_list *bil,block_item *bi) : m_bil(bil), m_bi(bi) {
        m_bil->set_parent(this);
        m_bi->set_parent(this);
    }
    virtual ~block_item_list_block_item_list_block_item(void) {
        delete m_bil;
        delete m_bi;
    }

    virtual block_item_list * clone(void) {
        block_item_list_block_item_list_block_item *copy = new block_item_list_block_item_list_block_item(m_bil->clone(),m_bi->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual void print(void) const {
        m_bil->print();
        m_bi->print();
//        oprintf("\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_bil,tr1);
        TRANSLATE(m_bi,tr2);
        return TranslateResult();
    }

    virtual block_item_list * prepend_bil(block_item_list *bil) {
        return m_bil->prepend_bil(bil);
    }

    friend class block_item_list_block_item;

    virtual void sub_destroyed(AST_node *node);
    virtual void insert_post_declarations(block_item_list *bil);
    virtual void append(block_item_list *bil);
    virtual void insert_before_statement(block_item_list *bil);

    virtual void replace_block_item(block_item *bi) {
        delete m_bi;
        m_bi = bi;
        m_bi->set_parent(this);
    }

    virtual void remove_and_delete(void) {
        m_parent->replace(this,m_bil);
        m_bil = NULL;
        delete this;
    }

    virtual block_item_list * get_block_item_list(void) {
        return m_bil;
    }

    virtual block_item_list * claim_block_item_list(void) {
        block_item_list *ret = m_bil;
        m_bil = NULL;
        return ret;
    }

    virtual block_item * get_block_item(void) {
        return m_bi;
    }

    virtual unsigned count_cases(void) {
        return m_bil->count_cases() + m_bi->count_cases();
    }

    AST_DEF_CHILDREN_2(m_bil,m_bi)
};

block_item_list * block_item_list_block_item::prepend_bil(block_item_list *bil) {
    block_item_list_block_item_list_block_item * new_node =
        new block_item_list_block_item_list_block_item(bil,m_bi);

    m_parent->replace(this,new_node);

    m_bi = NULL;
    delete this;
    return new_node;
}

void block_item_list_block_item::append(block_item_list *bil) {
    block_item_list *old_bil = this;
    m_parent->replace(this,bil);

    block_item_list *cur_bil = bil;
    block_item_list_block_item_list_block_item *bilbilbi = NULL;
    do {
        bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(cur_bil);
        if(bilbilbi) {
            cur_bil = bilbilbi->m_bil;
        }
    } while (bilbilbi);

    // cur_bil now points at the block_item_list_block_item
    block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(cur_bil);
    assert(bilbi);

    block_item_list_block_item_list_block_item *new_node = new
      block_item_list_block_item_list_block_item(old_bil,bilbi->m_bi);
    bilbi->m_parent->replace(bilbi,new_node);

    bilbi->m_bi = NULL;
    delete bilbi;
}

void block_item_list_block_item_list_block_item::insert_before_statement(block_item_list *bil) {
    block_item_list *old_bil = m_bil;
    m_bil = bil;
    bil->set_parent(this);

    block_item_list *cur_bil = bil;
    block_item_list_block_item_list_block_item *bilbilbi = NULL;
    do {
        bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(cur_bil);
        if(bilbilbi) {
            cur_bil = bilbilbi->m_bil;
        }
    } while (bilbilbi);

    // cur_bil now points at the block_item_list_block_item
    block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(cur_bil);
    assert(bilbi);

    block_item_list_block_item_list_block_item *new_node = new
      block_item_list_block_item_list_block_item(old_bil,bilbi->m_bi);
    bilbi->m_parent->replace(bilbi,new_node);

    bilbi->m_bi = NULL;
    delete bilbi;
}

void block_item_list_block_item_list_block_item::append(block_item_list *bil) {
    block_item_list *old_bil = this;
    m_parent->replace(this,bil);

    block_item_list *cur_bil = bil;
    block_item_list_block_item_list_block_item *bilbilbi = NULL;
    do {
        bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(cur_bil);
        if(bilbilbi) {
            cur_bil = bilbilbi->m_bil;
        }
    } while (bilbilbi);

    // cur_bil now points at the block_item_list_block_item
    block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(cur_bil);
    assert(bilbi);

    block_item_list_block_item_list_block_item *new_node = new
      block_item_list_block_item_list_block_item(old_bil,bilbi->m_bi);
    bilbi->m_parent->replace(bilbi,new_node);

    bilbi->m_bi = NULL;
    delete bilbi;
}

// ====================================================================

class compound_statement : public AST_node {
public:
    virtual ~compound_statement (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual compound_statement * prepend_bil(block_item_list *bil) = 0;
    virtual compound_statement * insert_post_declarations(block_item_list *bil) = 0;
    virtual compound_statement * append(block_item_list *bil) = 0;
    virtual void add_initializer_block_item(std::list<block_item *> &bi) = 0;
    virtual compound_statement * clone(void) = 0;
    virtual unsigned count_cases(void) {
        return 0;
    }
};

class compound_statement_empty : public compound_statement {
public:
    virtual void print(void) const {
        oprintf("{}\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual compound_statement * prepend_bil(block_item_list *bil);
    virtual compound_statement * insert_post_declarations(block_item_list *bil);

    // Prepend and append the same thing for an empty statement.
    virtual compound_statement * append(block_item_list *bil) {
        return prepend_bil(bil);
    }

    virtual void add_initializer_block_item(std::list<block_item *> &bi) {
        aeprintf("Should not add an initializer block item to an empty block.\n");
    }

    virtual compound_statement * clone(void) {
        compound_statement *copy = new compound_statement_empty();
        copy->clone_copy(this);
        return copy;
    }
};

class compound_statement_block_item_list : public compound_statement {
protected:
    block_item_list *m_bil;
    block_item_list *m_initializer_block_items;
    bool m_post_translate;
public:
    compound_statement_block_item_list(block_item_list *bil) : m_bil(bil), m_initializer_block_items(NULL), m_post_translate(g_translation_started) {
        m_bil->set_parent(this);
    }
    virtual ~compound_statement_block_item_list(void) {
        delete m_bil;
    }

    virtual block_item_list * get_block_item_list(void) const { return m_bil; }

    virtual unsigned count_cases(void) {
        return m_bil->count_cases();
    }

    virtual void print(void) const {
        oprintf("{\n");
        m_bil->print();
        oprintf("}\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_bil,tr);

        m_post_translate = true;

        if(m_initializer_block_items) {
            m_bil->insert_post_declarations(m_initializer_block_items);
        }

        return tr;
    }

    virtual compound_statement * clone(void) {
        compound_statement *copy = new compound_statement_block_item_list(m_bil->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual compound_statement * prepend_bil(block_item_list *bil) {
        m_bil->prepend_bil(bil);
        return this;
    }

    virtual compound_statement * insert_post_declarations(block_item_list *bil) {
        m_bil->insert_post_declarations(bil);
        return this;
    }

    virtual compound_statement * append(block_item_list *bil) {
        m_bil->append(bil);
        return this;
    }

    virtual void sub_destroyed(AST_node *node) {
        if(node == m_bil) {
            delete m_bil;
            m_bil = NULL;

            compound_statement_empty *new_node = new compound_statement_empty();
            m_parent->replace(this,new_node);

            delete this;
        } else {
            aeprintf("sub_destroyed\n");
        }
    }

    virtual void add_initializer_block_item(std::list<block_item *> &bi) {
        assert(!m_post_translate);
        std::list<block_item*>::iterator iter;
        for(iter  = bi.begin();
            iter != bi.end();
          ++iter) {
            if(m_initializer_block_items) {
                m_initializer_block_items =
                   new block_item_list_block_item_list_block_item(
                       m_initializer_block_items,
                       *iter
                   );
            } else {
                m_initializer_block_items = new block_item_list_block_item(*iter);
            }
        }
    }

    AST_DEF_CHILDREN_1(m_bil)
};

// ====================================================================

class expression_statement : public AST_node {
public:
    virtual ~expression_statement (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual expression_statement * clone(void) = 0;
};

class expression_statement_empty : public expression_statement {
public:
    virtual void print(void) const {
        oprintf(";\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual expression_statement * clone(void) {
        expression_statement *copy = new expression_statement_empty();
        copy->clone_copy(this);
        return copy;
    }
};


class expression_statement_expression : public expression_statement {
protected:
    expression *m_e;
public:
    expression_statement_expression(expression *e) : m_e(e) {
        m_e->set_parent(this);
    }
    virtual ~expression_statement_expression(void) {
        delete m_e;
    }

    virtual void print(void) const {
        m_e->print();
        oprintf(";\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual expression_statement * clone(void) {
        expression_statement *copy = new expression_statement_expression(m_e->clone());
        copy->clone_copy(this);
        return copy;
    }

    virtual expression * get_expression(void) {
        return m_e;
    }

    AST_DEF_CHILDREN_1(m_e)
};

// ====================================================================

class selection_statement : public AST_node {
public:
    virtual ~selection_statement(void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual selection_statement * clone(void) = 0;
};

class selection_statement_if : public selection_statement {
protected:
    expression *m_e;
    statement  *m_s;
public:
    selection_statement_if(expression *e,statement *s) : m_e(e), m_s(s) {
        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~selection_statement_if(void) {
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("if ( ");
        m_e->print();
        oprintf(" ) ");
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual selection_statement * clone(void) {
        selection_statement *copy = new selection_statement_if(m_e->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_e,m_s)
};

class selection_statement_if_else : public selection_statement {
protected:
    expression *m_e;
    statement  *m_s1, *m_s2;
public:
    selection_statement_if_else(expression *e,statement *s1,statement *s2) : m_e(e), m_s1(s1), m_s2(s2) {
        m_e->set_parent(this);
        m_s1->set_parent(this);
        m_s2->set_parent(this);
    }
    virtual ~selection_statement_if_else(void) {
        delete m_e;
        delete m_s1;
        delete m_s2;
    }

    virtual void print(void) const {
        oprintf("if ( ");
        m_e->print();
        oprintf(" ) ");
        m_s1->print();
        oprintf("else ");
        m_s2->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual selection_statement * clone(void) {
        selection_statement *copy = new selection_statement_if_else(m_e->clone(),m_s1->clone(),m_s2->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_3(m_e,m_s1,m_s2)
};

class selection_statement_if_builtin : public selection_statement {
protected:
    expression *m_e;
    char       *m_constant;
    statement  *m_s;
    bool        m_expect;
public:
    selection_statement_if_builtin(expression *e,char *constant, statement *s, bool expect) :
        m_e(e),
        m_constant(constant),
        m_s(s),
        m_expect(expect) {

        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~selection_statement_if_builtin(void) {
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("if ( ");
        if(!m_expect) {
            oprintf("!");
        }
        if(g_output_builtin_expect) {
            oprintf("__builtin_expect(");
        }
        m_e->print();
        if(g_output_builtin_expect) {
            oprintf(",");
            oprintf(m_constant);
            oprintf(" ) ");
        }
        oprintf(" ) ");
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual selection_statement * clone(void) {
        selection_statement *copy = new selection_statement_if_builtin(m_e->clone(),m_constant,m_s->clone(),m_expect);
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_e,m_s)
};

class selection_statement_if_else_builtin : public selection_statement {
protected:
    expression *m_e;
    char       *m_constant;
    statement  *m_s1, *m_s2;
    bool        m_expect;
public:
    selection_statement_if_else_builtin(expression *e,char *constant,statement *s1,statement *s2, bool expect) : m_e(e), m_constant(constant), m_s1(s1), m_s2(s2), m_expect(expect) {
        m_e->set_parent(this);
        m_s1->set_parent(this);
        m_s2->set_parent(this);
    }
    virtual ~selection_statement_if_else_builtin(void) {
        delete m_e;
        delete m_s1;
        delete m_s2;
    }

    virtual void print(void) const {
        oprintf("if ( ");
        if(!m_expect) {
            oprintf("!");
        }
        if(g_output_builtin_expect) {
            oprintf("__builtin_expect(");
        }
        m_e->print();
        if(g_output_builtin_expect) {
            oprintf(",");
            oprintf(m_constant);
            oprintf(" ) ");
        }
        oprintf(" ) ");
        m_s1->print();
        oprintf("else ");
        m_s2->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual selection_statement * clone(void) {
        selection_statement *copy = new selection_statement_if_else_builtin(m_e->clone(),m_constant,m_s1->clone(),m_s2->clone(),m_expect);
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_3(m_e,m_s1,m_s2)
};

class selection_statement_switch : public selection_statement {
protected:
    expression *m_e;
    statement  *m_s;

    basic_block *m_break_target;
    basic_block *m_switch_block;
    bool m_has_default;
    unsigned m_num_cases;
public:
    selection_statement_switch(expression *e,statement *s) : m_e(e), m_s(s), m_break_target(NULL), m_switch_block(NULL), m_has_default(false), m_num_cases(0) {
        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~selection_statement_switch(void) {
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("switch ( ");
        m_e->print();
        oprintf(" ) ");
        m_s->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual unsigned get_num_cases(void) {
        return m_num_cases;
    }

    virtual basic_block * get_break_target(void) {
        assert(m_break_target);
        return m_break_target;
    }

    virtual basic_block * get_switch_block(void) {
        assert(m_switch_block);
        return m_switch_block;
    }

    virtual void found_default(void) {
        m_has_default = true;
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual selection_statement * clone(void) {
        selection_statement *copy = new selection_statement_switch(m_e->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_e,m_s)
};

// ====================================================================

class iteration_statement : public AST_node {
protected:
    basic_block * m_loop_body;
    basic_block * m_post_loop;
    basic_block * m_conditional;
    basic_block * m_break_target;
public:
    iteration_statement(void) :
        m_loop_body(NULL),
        m_post_loop(NULL),
        m_conditional(NULL),
        m_break_target(NULL) {}

    virtual ~iteration_statement (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;

    virtual basic_block * get_continue_target(void) {
        assert(m_conditional);
        if(m_post_loop) return m_post_loop;
        else            return m_conditional;
    }

    virtual basic_block * get_break_target(void) {
        assert(m_break_target);
        return m_break_target;
    }
    virtual iteration_statement * clone(void) = 0;
};

class iteration_statement_while : public iteration_statement {
protected:
    expression *m_e;
    statement  *m_s;
public:
    iteration_statement_while(expression *e,statement *s) : m_e(e), m_s(s) {
        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~iteration_statement_while(void) {
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("while ( ");
        m_e->print();
        oprintf(" ) ");
        m_s->print();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_while(m_e->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_e,m_s)
};

class iteration_statement_do : public iteration_statement {
protected:
    statement  *m_s;
    expression *m_e;
public:
    iteration_statement_do(statement *s,expression *e) : m_s(s), m_e(e) {
        m_s->set_parent(this);
        m_e->set_parent(this);
    }
    virtual ~iteration_statement_do(void) {
        delete m_s;
        delete m_e;
    }

    virtual void print(void) const {
        oprintf("do ");
        m_s->print();
        oprintf("while ( ");
        m_e->print();
        oprintf(" ) ;\n");
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_do(m_s->clone(),m_e->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_2(m_s,m_e)
};

class iteration_statement_for_eses : public iteration_statement {
protected:
    expression_statement *m_es1, *m_es2;
    statement  *m_s;
public:
    iteration_statement_for_eses(expression_statement *es1,expression_statement *es2,statement *s) : m_es1(es1), m_es2(es2), m_s(s) {
        m_es1->set_parent(this);
        m_es2->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~iteration_statement_for_eses(void) {
        delete m_es1;
        delete m_es2;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("for ( ");
        m_es1->print();
        oprintf(" ");
        m_es2->print();
        oprintf(" ) ");
        m_s->print();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_for_eses(m_es1->clone(),m_es2->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_3(m_es1,m_es2,m_s)
};

class iteration_statement_for_esese : public iteration_statement {
protected:
    expression_statement *m_es1, *m_es2;
    expression *m_e;
    statement  *m_s;
public:
    iteration_statement_for_esese(expression_statement *es1,expression_statement *es2,expression *e,statement *s) : m_es1(es1), m_es2(es2), m_e(e), m_s(s) {
        m_es1->set_parent(this);
        m_es2->set_parent(this);
        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~iteration_statement_for_esese(void) {
        delete m_es1;
        delete m_es2;
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("for ( ");
        m_es1->print();
        oprintf(" ");
        m_es2->print();
        oprintf(" ");
        m_e->print();
        oprintf(" ) ");
        m_s->print();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_for_esese(m_es1->clone(),m_es2->clone(),m_e->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_4(m_es1,m_es2,m_e,m_s)
};

class iteration_statement_for_des : public iteration_statement {
protected:
    declaration *m_d;
    expression_statement *m_es;
    statement  *m_s;
public:
    iteration_statement_for_des(declaration *d,expression_statement *es,statement *s) : m_d(d), m_es(es), m_s(s) {
        m_d->set_parent(this);
        m_es->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~iteration_statement_for_des(void) {
        delete m_d;
        delete m_es;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("for ( ");
        m_d->print();
        oprintf(" ");
        m_es->print();
        oprintf(" ) ");
        m_s->print();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        if(m_d == child) {
            assert(0);
            return LRB_RVALUE;
        }
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        if(m_d == child) {
            assert(0);
            return false;
        }
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_for_des(m_d->clone(),m_es->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_3(m_d,m_es,m_s)
};

class iteration_statement_for_dese : public iteration_statement {
protected:
    declaration *m_d;
    expression_statement *m_es;
    expression *m_e;
    statement  *m_s;
public:
    iteration_statement_for_dese(declaration *d,expression_statement *es,expression *e,statement *s) : m_d(d), m_es(es), m_e(e), m_s(s) {
        m_d->set_parent(this);
        m_es->set_parent(this);
        m_e->set_parent(this);
        m_s->set_parent(this);
    }
    virtual ~iteration_statement_for_dese(void) {
        delete m_d;
        delete m_es;
        delete m_e;
        delete m_s;
    }

    virtual void print(void) const {
        oprintf("for ( ");
        m_d->print();
        oprintf(" ");
        m_es->print();
        oprintf(" ");
        m_e->print();
        oprintf(" ) ");
        m_s->print();
    }

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        if(m_d == child) {
            assert(0);
            return LRB_RVALUE;
        }
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        if(m_d == child) {
            assert(0);
            return false;
        }
        return false;
    }
#endif

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual iteration_statement * clone(void) {
        iteration_statement *copy = new iteration_statement_for_dese(m_d->clone(),m_es->clone(),m_e->clone(),m_s->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_4(m_d,m_es,m_e,m_s)
};

// ====================================================================

class jump_statement : public AST_node {
public:
    virtual ~jump_statement (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual jump_statement * clone(void) = 0;
};

class jump_statement_goto : public jump_statement {
protected:
    std::string  m_id;
    bool m_is_backwards;
public:
    jump_statement_goto(const std::string &id) : m_id(id), m_is_backwards(false) {}

    virtual void print(void) const {
        oprintf("goto %s ;\n",m_id.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual void set_backward(void) {
        m_is_backwards = true;
    }

    virtual bool is_backward(void) const {
        return m_is_backwards;
    }

    virtual void change_label(const std::string &new_label) {
        m_id = new_label;
    }

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_goto(m_id);
        copy->clone_copy(this);
        return copy;
    }
};

class jump_statement_continue : public jump_statement {
public:
    virtual void print(void) const {
        oprintf("continue;\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool contains_loop_specific(void) {
        return true;
    }

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_continue();
        copy->clone_copy(this);
        return copy;
    }
};

class jump_statement_break : public jump_statement {
public:
    virtual void print(void) const {
        oprintf("break;\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

    virtual bool contains_loop_specific(void) {
        return true;
    }

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_break();
        copy->clone_copy(this);
        return copy;
    }
};

class jump_statement_return : public jump_statement {
public:
    virtual void print(void) const {
        oprintf("return;\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) ;

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_return();
        copy->clone_copy(this);
        return copy;
    }
};

class jump_statement_return_expression : public jump_statement {
protected:
    expression *m_e;
public:
    jump_statement_return_expression(expression *e) : m_e(e) {
        m_e->set_parent(this);
    }
    virtual ~jump_statement_return_expression(void) {
        delete m_e;
    }

    virtual void print(void) const {
        oprintf("return ");
        m_e->print();
        oprintf(";\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_e == child);
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_e == child);
        return false;
    }
#endif

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_return_expression(m_e->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_e)
};

class jump_statement_return_mre : public jump_statement {
protected:
    multiple_ret_expr *m_e;
public:
    jump_statement_return_mre(multiple_ret_expr *e) : m_e(e) {
        m_e->set_parent(this);
    }
    virtual ~jump_statement_return_mre(void) {
        delete m_e;
    }

    virtual void print(void) const {
        aeprintf("Shouldn't  print return_mre.\n");
/*
        oprintf("return ");
        m_e->print();
        oprintf(";\n");
*/
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_e == child);
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_e == child);
        return false;
    }
#endif

    virtual jump_statement * clone(void) {
        aeprintf("Clone not implemented for jump_statement_return_mre.\n");
/*
        jump_statement *copy = new jump_statement_return_mre(m_e->clone());
        copy->clone_copy(this);
        return copy;
*/
    }

    AST_DEF_CHILDREN_1(m_e)
};

class jump_statement_prt_tailcall : public jump_statement {
protected:
    call_expression *m_ce;
public:
    jump_statement_prt_tailcall(call_expression *ce) : m_ce(ce) {
        m_ce->set_parent(this);
    }
    virtual ~jump_statement_prt_tailcall(void) {
        delete m_ce;
    }

    virtual void print(void) const {
        aeprintf("Should never emit a Pillar construct, tailcall.\n");
/*
        printf("return tailcall ");
        m_ce->print();
        printf(" ;");
*/
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_ce == child);
        return false;
    }
#endif

    virtual void create_call_graph(function_definition *fd);

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_prt_tailcall(m_ce->clone());
        copy->clone_copy(this);
        return copy;
    }

    AST_DEF_CHILDREN_1(m_ce)
};

#ifdef USE_JSPCT
class jump_statement_prt_cut_to : public jump_statement {
protected:
    assignment_expression *m_ae;
public:
    jump_statement_prt_cut_to(assignment_expression *ae) : m_ae(ae) {
        m_ae->set_parent(this);
        m_children.push_back((AST_node**)&m_ae);
    }
    virtual ~jump_statement_prt_cut_to(void) {
        delete m_ae;
    }

    virtual void print(void) const {
        aeprintf("Should never emit a Pillar construct, cut to.\n");
/*
        printf("cut to ");
        m_ce->print();
        printf(" ;");
*/
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        assert(m_ae == child);
        return RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        assert(m_ae == child);
        return false;
    }
#endif

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_prt_cut_to(m_ae->clone());
        copy->clone_copy(this);
        return copy;
    }
};
#endif

class jump_statement_prt_cut_to_argument_expression_list : public jump_statement {
protected:
    assignment_expression *m_ae;
    argument_expression_list *m_ael;
    unsigned m_unique;
    check_vector<ii_ptr > m_id_vec;
public:
    jump_statement_prt_cut_to_argument_expression_list(assignment_expression *ae,argument_expression_list *ael, identifier_list *il = NULL) : m_ae(ae), m_ael(ael) {
        m_ae->set_parent(this);
        if(m_ael) {
            m_ael->set_parent(this);
        }
        if(il) {
            il->flatten(m_id_vec);
            delete il;
        }
        m_unique = g_unique_id++;
    }
    virtual ~jump_statement_prt_cut_to_argument_expression_list(void) {
        delete m_ae;
        delete m_ael;
    }

    virtual unsigned get_num_children(void) const {
        if(m_ael) return 2;
        else      return 1;
    }
    virtual AST_node **begin_child_iter(void) const {
        return (AST_node**)&m_ae;
    }
    virtual AST_node **next_child_iter(AST_node **cur) const {
        if(cur == (AST_node**)&m_ae)  {
            if(m_ael) {
                return (AST_node**)&m_ael;
            } else {
                return NULL;
            }
        } else if(cur == (AST_node**)&m_ael) {
            return NULL;
        } else aeprintf("next_child_iter problem");
    }

    virtual void print(void) const {
//        if(g_use_new_continuations) {
            aeprintf("Should never emit a Pillar construct, cut to (argument_expression_list).\n");
//        }
/*
        printf("cut to ");
        m_ce->print();
        printf("( ");
        m_ael->print();
        printf(") ;");
*/
    }

    virtual TranslateResult translate_pillar(function_definition *fd);

#ifndef USE_IS_LVALUE
    virtual LRB_VALUE get_lrb_value(AST_node *child,ii_ptr ii) {
        return LRB_RVALUE;
    }
#else
    virtual bool is_lvalue(AST_node *child,ii_ptr ii) {
        return false;
    }
#endif

    virtual jump_statement * clone(void) {
        jump_statement *copy = new jump_statement_prt_cut_to_argument_expression_list(m_ae->clone(),m_ael ? m_ael->clone() : NULL);
        copy->clone_copy(this);
        return copy;
    }

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }
};

// ====================================================================

class declaration_list : public AST_node {
public:
    virtual ~declaration_list (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
};

class declaration_list_declaration : public declaration_list {
protected:
    declaration *m_d;
public:
    declaration_list_declaration(declaration *d) : m_d(d) {
        m_d->set_parent(this);
    }
    virtual ~declaration_list_declaration(void) {
        delete m_d;
    }

    virtual void print(void) const {
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_d,tr);
        return tr;
    }

    AST_DEF_CHILDREN_1(m_d)
};

class declaration_list_declaration_list_declaration : public declaration_list {
protected:
    declaration_list *m_dl;
    declaration      *m_d;
public:
    declaration_list_declaration_list_declaration(declaration_list *dl,declaration *d) : m_dl(dl), m_d(d) {
        m_dl->set_parent(this);
        m_d->set_parent(this);
    }
    virtual ~declaration_list_declaration_list_declaration(void) {
        delete m_dl;
        delete m_d;
    }

    virtual void print(void) const {
        m_dl->print();
        oprintf(" ");
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_dl,tr1);
        TRANSLATE(m_d,tr2);
        aeprintf("type problem\n");
        // FIX FIX FIX combine tr1 and tr2
        return tr1;
    }

    AST_DEF_CHILDREN_2(m_dl,m_d)
};

// ====================================================================

class ref_info;

class ref_map {
protected:
//    enum LRVALUE *m_refs;
    unsigned char *m_refs;
    unsigned m_len;
public:
    ref_map(void) {
        m_refs = NULL;
        m_len  = 0;
    }

    explicit ref_map(unsigned num_refs) {
        m_refs = new unsigned char[num_refs];
        memset(m_refs,0,sizeof(unsigned char)*num_refs);
        m_len = num_refs;
    }

    ref_map(const ref_map &other) {
        m_len  = other.m_len;
        m_refs = new unsigned char[m_len];
        memcpy(m_refs,other.m_refs,sizeof(unsigned char)*m_len);
    }

    unsigned get_len(void) const {
        return m_len;
    }

    ref_map & operator=(const ref_map &other) {
        if(m_len != other.m_len) {
            if(m_len) {
                delete [] m_refs;
            }
            m_len  = other.m_len;
            m_refs = new unsigned char[m_len];
        }
        if(m_len) {
            assert(m_refs && other.m_refs);
            memcpy(m_refs,other.m_refs,sizeof(unsigned char)*m_len);
        } else {
            m_refs = 0;
        }
        return *this;
    }

    virtual ~ref_map(void) {
        delete [] m_refs;
    }

    unsigned char & operator[](unsigned index) {
        assert(index < m_len);
        return m_refs[index];
    }

    const unsigned char & operator[](unsigned index) const {
        assert(index < m_len);
        return m_refs[index];
    }

    void make_lvalue(unsigned index) {
        assert(index < m_len);
        m_refs[index] = LVALUE;
    }

    void make_rvalue(unsigned index) {
        assert(index < m_len);
        m_refs[index] = RVALUE;
    }

    void set_all_rvalue(void) {
        unsigned index;
        for(index = 0; index < m_len; ++index) {
            m_refs[index] = RVALUE;
        }
    }

    void eliminate_lvalues(void) {
        unsigned index;
        for(index = 0; index < m_len; ++index) {
            if(m_refs[index] == LVALUE) {
                m_refs[index] = LR_NOT_FOUND;
            }
        }
    }

    void merge_rvalues(const ref_map &other) {
        if(other.m_len == 0) return;

        if(m_len == 0) {
            m_len  = other.m_len;
            m_refs = new unsigned char[m_len];
            memset(m_refs,0,sizeof(unsigned char)*m_len);
        }
        assert(m_len == other.m_len);

        unsigned index;
        for(index = 0; index < m_len; ++index) {
            if(other.m_refs[index] == RVALUE) {
                m_refs[index] = RVALUE;
            }
        }
    }

    void merge_rvalue_rare(const ref_map &other, bool rare) {
        if(other.m_len == 0) return;

        if(m_len == 0) {
            m_len  = other.m_len;
            m_refs = new unsigned char[m_len];
            memset(m_refs,0,sizeof(unsigned char)*m_len);
        }
        assert(m_len == other.m_len);

        unsigned index;
        for(index = 0; index < m_len; ++index) {
            if(other.m_refs[index] == RVALUE) {
                if(rare) {
                    if(m_refs[index] != RVALUE) {
                        m_refs[index] = RARE_RVALUE;
                    }
                } else {
                    m_refs[index] = RVALUE;
                }
            }
        }
    }

    bool operator==(const ref_map &other) const {
        if(m_len != other.m_len) return false;
        unsigned index;
        for(index = 0; index < m_len; ++index) {
            if(m_refs[index] != other.m_refs[index]) {
                return false;
            }
        }
        return true;
    }

    bool operator!=(const ref_map &other) const {
        return !operator==(other);
    }

    void print(void) {
        unsigned index;
        for(index = 0; index < m_len; ++index) {
            printf("%d ",m_refs[index]);
        }
        printf("\n");
        fflush(stdout);
    }

    virtual void add_edge_if_conflict(check_vector<ref_info *> &vec_ri);
    virtual void add_edge_if_conflict_range(unsigned start, unsigned end, check_vector<ref_info *> &vec_ri);
};

class freq_ref_info {
public:
    unsigned m_writes;
    unsigned m_reads;

    freq_ref_info(void) : m_writes(0), m_reads(0) {}

    unsigned get_total(void) const {
        return m_writes + m_reads;
    }
};

class map_ref_info : public std::map<unsigned, freq_ref_info> {
public:
    void add_write(unsigned ref_index) {
        std::pair<std::map<unsigned, freq_ref_info>::iterator,bool> result = insert(std::pair<unsigned,freq_ref_info>(ref_index,freq_ref_info()));
        result.first->second.m_writes++;
    }

    void add_read(unsigned ref_index) {
        std::pair<std::map<unsigned, freq_ref_info>::iterator,bool> result = insert(std::pair<unsigned,freq_ref_info>(ref_index,freq_ref_info()));
        result.first->second.m_reads++;
    }

    unsigned get_total(unsigned ref_index) const {
        std::map<unsigned, freq_ref_info>::const_iterator mi = find(ref_index);
        if(mi == end()) return 0;
        else {
            return mi->second.get_total();
        }
    }

    unsigned get_reads(unsigned ref_index) const {
        std::map<unsigned, freq_ref_info>::const_iterator mi = find(ref_index);
        if(mi == end()) return 0;
        else {
            return mi->second.m_reads;
        }
    }

    unsigned get_writes(unsigned ref_index) const {
        std::map<unsigned, freq_ref_info>::const_iterator mi = find(ref_index);
        if(mi == end()) return 0;
        else {
            return mi->second.m_writes;
        }
    }

    bool has_write(unsigned ref_index) const {
        std::map<unsigned, freq_ref_info>::const_iterator mi = find(ref_index);
        if(mi == end()) return false;
        else {
            return mi->second.m_writes ? true : false;
        }
    }
};

class ref_call;

class basic_block_ref_events {
public:
    virtual ~basic_block_ref_events() {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) = 0;
    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) = 0;
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) = 0;
    virtual bool has_call(void) { return false; }
    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) = 0;
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) = 0;
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) = 0;
    virtual void update_ref_freq(map_ref_info &mri) = 0;
};

class ref_lvalue : public basic_block_ref_events {
public:
    ii_ptr m_ii;

    ref_lvalue(ii_ptr ii) : m_ii(ii) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        // If optimizations are disabled for this ref then do nothing here as the call site will always enumerate the root.
        if(disable_opts.find(m_ii) != disable_opts.end()) {
            return;
        }
        rm.make_lvalue(m_ii->get_ref_index());
    }

    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        update_state(rm,vars,disable_opts);
    }

    virtual void update_ref_freq(map_ref_info &mri) {
        mri.add_write(m_ii->get_ref_index());
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {}
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {}
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {}
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) {}
};

class ref_rvalue : public basic_block_ref_events {
public:
    ii_ptr m_ii;

    ref_rvalue(ii_ptr ii) : m_ii(ii) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        rm.make_rvalue(m_ii->get_ref_index());
    }

    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        update_state(rm,vars,disable_opts);
    }

    virtual void update_ref_freq(map_ref_info &mri) {
        mri.add_read(m_ii->get_ref_index());
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {}
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {}
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {}
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) {}
};

class var_lvalue : public basic_block_ref_events {
public:
    ii_ptr m_ii;

    var_lvalue(ii_ptr ii) : m_ii(ii) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        // If optimizations are disabled for this ref then do nothing here as the call site will always enumerate the root.
        if(disable_opts.find(m_ii) != disable_opts.end()) {
            return;
        }
        vars.make_lvalue(m_ii->get_var_index());
    }

    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        update_state(rm,vars,disable_opts);
    }

    virtual void update_ref_freq(map_ref_info &mri) {
        // not a ref so do nothing
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {}
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {}
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {}
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) {}
};

class var_rvalue : public basic_block_ref_events {
public:
    ii_ptr m_ii;

    var_rvalue(ii_ptr ii) : m_ii(ii) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        vars.make_rvalue(m_ii->get_var_index());
    }

    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        update_state(rm,vars,disable_opts);
    }

    virtual void update_ref_freq(map_ref_info &mri) {
        // not a ref so do nothing
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {}
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {}
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {}
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) {}
};

class ref_call : public basic_block_ref_events {
protected:
    ref_map m_ref_indices;
    ref_map m_var_indices;
    bool    m_args_already_added;
    bool    m_call_context;
    virtual void update_state_internal(ref_map &map_for_this_call, ref_map &map_for_var_call, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts);
    virtual void final_backtrace_internal(ref_map &map_for_this_call, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare, const std::map<unsigned,std::string> &hoists,bool ref_params_in_pseudo);
    virtual void mark_callsite_refs_internal(ref_map &map_for_this_call, ref_map &rm, ref_map &vars_for_this_call, ref_map &vars, bool bb_rare);
public:
    call_expression *m_node;

    ref_call(call_expression *node, bool args_already_added, bool call_context) : m_args_already_added(args_already_added), m_call_context(call_context), m_node(node) {}
    virtual ~ref_call(void) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts);
    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo);
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare);
    virtual bool has_call(void) {
        return true;
    }
    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts);
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists);
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, bool bb_rare);

    virtual void update_ref_freq(map_ref_info &mri) {
        //intentionally do nothing
    }
};

class continuation_point : public basic_block_ref_events {
public:
    ref_map m_ref_indices;
    ref_map m_var_indices;
    basic_block *m_bb;

    continuation_point(basic_block *bb) : m_bb(bb) {}

    virtual void update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        m_ref_indices.merge_rvalues(rm);
        m_var_indices.merge_rvalues(vars);
    }

    virtual void update_ref_freq(map_ref_info &mri) {
        //intentionally do nothing
    }

    virtual void update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
        aeprintf("update_state_region\n");
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {}
    virtual void mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {}
    virtual void final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {}
    virtual void mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &ref_rm, ref_map &var_rm, bool bb_rare) {}
};

enum BB_FREQUENCY {
    BB_FREQ_UNKNOWN = 0,
    BB_FREQ_COMMON  = 1,
    BB_FREQ_RARE    = 2
};

enum EDGE_TYPE {
    EDGE_CONDITIONAL,
    EDGE_FALLTHROUGH,
    EDGE_GOTO,
    EDGE_CONTINUE,
    EDGE_BREAK,
    EDGE_RETURN,
    EDGE_LOOP,
    EDGE_CUT
};

const char * edge_to_str(EDGE_TYPE type) {
    switch(type) {
    case EDGE_CONDITIONAL:
        return "EDGE_CONDITIONAL";
    case EDGE_FALLTHROUGH:
        return "EDGE_FALLTHROUGH";
    case EDGE_GOTO:
        return "EDGE_GOTO";
    case EDGE_CONTINUE:
        return "EDGE_CONTINUE";
    case EDGE_BREAK:
        return "EDGE_BREAK";
    case EDGE_RETURN:
        return "EDGE_RETURN";
    case EDGE_LOOP:
        return "EDGE_LOOP";
    case EDGE_CUT:
        return "EDGE_CUT";
    default:
        aeprintf("unknown edge type\n");
    }
}

class edge_info {
public:
    BB_FREQUENCY m_freq;
    basic_block *m_block;
    bool m_in_dft;
    EDGE_TYPE m_type;
    jump_statement_goto *m_goto;

    edge_info(BB_FREQUENCY freq, basic_block *block, EDGE_TYPE type, jump_statement_goto *goto_stmt = NULL) :
        m_freq(freq),
        m_block(block),
        m_in_dft(false),
        m_type(type),
        m_goto(goto_stmt) {}
};

class loop;

#ifdef COUNT_PDR
unsigned g_num_pdr = 0;
#endif

class basic_block {
protected:
    virtual bool has_loop_internal(check_vector<basic_block *> &stack) {
        size_t i;
        for(i=0;i<stack.size();++i) {
            if(stack[i] == this) return true;
        }

        stack.push_back(this);

        unsigned precede_index;
        for(precede_index = 0; precede_index < m_can_precede.size(); ++precede_index) {
            if(m_can_precede[precede_index].m_block->has_loop_internal(stack)) {
                return true;
            }
        }

        stack.pop_back();
        return false;
    }

    virtual void mark_callsite_refs_internal(ref_map &active_refs, std::set<basic_block*> &processed_nodes) {
        std::pair<std::set<basic_block*>::iterator, bool> res = processed_nodes.insert(this);
        if(!res.second) {
            return;
        }

        ref_map active_vars;

        // Walk backwards through the refs and function calls in this basic block and update
        // the state map appropriately and create the call site masks of lives refs.
        size_t this_block_refs;
        for(this_block_refs = m_live_refs_here.size();
            this_block_refs > 0;
          --this_block_refs) {
            m_live_refs_here[this_block_refs - 1]->mark_callsite_refs(active_refs, active_vars, m_freq == BB_FREQ_RARE);
        }
    }

    virtual void mark_callsite_refs_region_internal(const std::set<basic_block*> &region, std::map<void*,ref_map> &map_context, ref_map &active_refs, std::set<basic_block*> &processed_nodes) {
        if(region.find(this) == region.end()) {
            return;
        }

        std::pair<std::set<basic_block*>::iterator, bool> res = processed_nodes.insert(this);
        if(!res.second) {
            return;
        }

        ref_map active_vars;

        // Walk backwards through the refs and function calls in this basic block and update
        // the state map appropriately and create the call site masks of lives refs.
        size_t this_block_refs;
        for(this_block_refs = m_live_refs_here.size();
            this_block_refs > 0;
          --this_block_refs) {
            m_live_refs_here[this_block_refs - 1]->mark_callsite_refs_region(map_context, active_refs, active_vars, m_freq == BB_FREQ_RARE);
        }
    }

    void compute_dfn_internal(int &cur_dfn, std::set<basic_block*> &visited, check_vector<basic_block*> &bbs_df_order) {
        visited.insert(this);

        unsigned precede_index;
        for(precede_index = 0; precede_index < m_can_precede.size(); ++precede_index) {
            if(visited.find(m_can_precede[precede_index].m_block) == visited.end()) {
                m_can_precede[precede_index].m_in_dft = true;
                m_can_precede[precede_index].m_block->compute_dfn_internal(cur_dfn, visited, bbs_df_order);
            }
        }

        m_depth_first_number = --cur_dfn;
        bbs_df_order[m_depth_first_number] = this;
    }

public:
    BB_FREQUENCY m_freq, m_force_freq;
    check_vector<basic_block *> m_can_follow;
    check_vector<edge_info>     m_can_precede;
//    AST_node *m_first_item;
//    std::list<AST_node *> m_items;
    std::list<statement *> m_items;

    statement * add_item(statement *node) {
        if(node) {
            std::list<statement *>::iterator iiter;
            iiter = find(m_items.begin(), m_items.end(), node);
            if(iiter != m_items.end()) {
                return node;
            }

            m_items.push_back(node);
            node->set_bb(this);
        }
        return node;
    }

    void remove_item(statement *node) {
        std::list<statement *>::iterator iter;
        for(iter  = m_items.begin();
            iter != m_items.end();
          ++iter) {
            if(*iter == node) {
                m_items.erase(iter);
                return;
            }
        }
        aeprintf("Should never fail to remove a statement from a basic block.\n");
    }

    statement * get_first_item(void) {
        if(m_items.size() == 0) {
            return NULL;
        } else {
            return m_items.front();
        }
    }

    std::set<loop *> m_in_loops;
    int m_depth_first_number;
    int m_bb_index; // index in the function's basic_block vector
    VarBitmask m_dom_mask;

    check_vector<basic_block_ref_events *> m_live_refs_here;
    bool m_has_call;
    ref_map m_sent_upstream;
    ref_map m_from_downstream;
    ref_map m_sent_upstream_var;
    ref_map m_from_downstream_var;

    bool m_backtrace_complete;
    unsigned m_unique;

    basic_block(statement *first_item) :
        m_freq(BB_FREQ_UNKNOWN),
        m_force_freq(BB_FREQ_UNKNOWN),
//        m_first_item(first_item),
        m_depth_first_number(-1),
        m_bb_index(-1),
        m_has_call(false),
        m_backtrace_complete(false) {
        m_unique = g_unique_id++;
        add_item(first_item);
    }

    virtual ~basic_block(void) {
        unsigned i;
        for(i = 0; i < m_live_refs_here.size(); ++i) {
            delete m_live_refs_here[i];
        }
        std::list<statement *>::iterator iter;
        for(iter  = m_items.begin();
            iter != m_items.end();
          ++iter) {
            (*iter)->set_bb(NULL);
        }
    }

#if 0
    void set_first_item(AST_node *item) {
        m_first_item = item;
    }
#endif

    edge_info get_edge_info(basic_block *bb) {
        unsigned i;
        for(i = 0; i < m_can_precede.size(); ++i) {
            if(m_can_precede[i].m_block == bb) {
                return m_can_precede[i];
            }
        }
        aeprintf("got to end of get_edge_info\n");
    }

    EDGE_TYPE get_edge_type(basic_block *bb) {
        unsigned i;
        for(i = 0; i < m_can_precede.size(); ++i) {
            if(m_can_precede[i].m_block == bb) {
                return m_can_precede[i].m_type;
            }
        }
        aeprintf("got to end of get_edge_type\n");
    }

    bool contains_rare_call(void) {
        if(m_freq != BB_FREQ_RARE) {
            return false;
        }

        unsigned i;
        for(i = 0; i < m_live_refs_here.size(); ++i) {
            if(m_live_refs_here[i]->has_call()) {
                assert(m_has_call);
                return true;
            }
        }
        return false;
    }

    void compute_dfn(unsigned num_basic_blocks, check_vector<basic_block*> &bbs_df_order) {
        std::set<basic_block*> visited;
        int cur_dfn = (int)num_basic_blocks;
        compute_dfn_internal(cur_dfn, visited, bbs_df_order);
    }

    void process_downstream_refs(const ref_map &from_downstream, const ref_map &from_downstream_var, const std::set<ii_ptr > &disable_opts) {
#ifdef COUNT_PDR
        g_num_pdr++;
#endif

        m_from_downstream.merge_rvalues(from_downstream);
        m_from_downstream_var.merge_rvalues(from_downstream_var);

        if(ref_debug) {
            printf("from downstream ");
            m_from_downstream.print();
        }

        ref_map state(m_from_downstream);
        ref_map state_var(m_from_downstream_var);

        // Walk backwards through the refs and function calls in this basic block and update
        // the state map appropriately and create the call site masks of lives refs.
        size_t this_block_refs;
        for(this_block_refs = m_live_refs_here.size();
            this_block_refs > 0;
          --this_block_refs) {
            m_live_refs_here[this_block_refs - 1]->update_state(state, state_var, disable_opts);
        }

        std::set<ii_ptr>::const_iterator diter;
        for(diter  = disable_opts.begin();
            diter != disable_opts.end();
          ++diter) {
            state.make_rvalue((*diter)->get_ref_index());
            state_var.make_rvalue((*diter)->get_var_index());
        }

        // If the new set of upstream refs is different from the last set of upstream refs we sent then send the new set.
        if(state != m_sent_upstream || state_var != m_sent_upstream_var) {
            m_sent_upstream = state;
            m_sent_upstream_var = state_var;

            if(ref_debug) {
                printf("sent upstream   ");
                m_sent_upstream.print();
            }

            unsigned follow_index;
            for(follow_index = 0; follow_index < m_can_follow.size(); ++follow_index) {
                if(m_bb_index <= m_can_follow[follow_index]->m_bb_index) {
#ifdef PRINT_PDR
                    printf("%p => %p\n",this,m_can_follow[follow_index]);
#endif
                    m_can_follow[follow_index]->process_downstream_refs(m_sent_upstream, m_sent_upstream_var, disable_opts);
#ifdef PRINT_PDR
                    printf("%p <= %p\n",this,m_can_follow[follow_index]);
#endif
                }
            }
            for(follow_index = 0; follow_index < m_can_follow.size(); ++follow_index) {
                if(m_bb_index > m_can_follow[follow_index]->m_bb_index) {
#ifdef PRINT_PDR
                    printf("%p => %p\n",this,m_can_follow[follow_index]);
#endif
                    m_can_follow[follow_index]->process_downstream_refs(m_sent_upstream, m_sent_upstream_var, disable_opts);
#ifdef PRINT_PDR
                    printf("%p <= %p\n",this,m_can_follow[follow_index]);
#endif
                }
            }
        }
    }

    virtual void mark_callsite_refs(ref_map &active_refs) {
        std::set<basic_block*> empty_set;
        mark_callsite_refs_internal(active_refs,empty_set);
    }

    virtual void mark_callsite_refs_region(const std::set<basic_block*> &region, std::map<void*,ref_map> &map_context, ref_map &active_refs) {
        std::set<basic_block*> empty_set;
        mark_callsite_refs_region_internal(region, map_context, active_refs, empty_set);
    }

    void process_downstream_refs_region(const std::set<basic_block*> &region,
                                        std::map<void*,ref_map> &map_context,
                                        const ref_map &from_downstream,
                                        const ref_map &from_downstream_var,
                                        const std::set<ii_ptr > &disable_opts) {
        if(region.find(this) == region.end()) {
            return;
        }

        std::pair<std::map<void*,ref_map>::iterator, bool> insert_res_down = map_context.insert(std::pair<void*,ref_map>(&m_from_downstream,ref_map()));
        insert_res_down.first->second.merge_rvalues(from_downstream);
        std::pair<std::map<void*,ref_map>::iterator, bool> insert_res_var  = map_context.insert(std::pair<void*,ref_map>(&m_from_downstream_var,ref_map()));
        insert_res_var.first->second.merge_rvalues(from_downstream_var);

        if(ref_debug) {
            printf("from downstream ");
            insert_res_down.first->second.print();
        }

        ref_map state(insert_res_down.first->second);
        ref_map state_var(insert_res_var.first->second);

        // Walk backwards through the refs and function calls in this basic block and update
        // the state map appropriately and create the call site masks of lives refs.
        size_t this_block_refs;
        for(this_block_refs = m_live_refs_here.size();
            this_block_refs > 0;
          --this_block_refs) {
            m_live_refs_here[this_block_refs - 1]->update_state_region(map_context, state, state_var, disable_opts);
        }

//        state.eliminate_lvalues();
        std::set<ii_ptr >::const_iterator diter;
        for(diter  = disable_opts.begin();
            diter != disable_opts.end();
          ++diter) {
            state.make_rvalue((*diter)->get_ref_index());
            state_var.make_rvalue((*diter)->get_var_index());
        }

        std::pair<std::map<void*,ref_map>::iterator, bool> insert_res_sent = map_context.insert(std::pair<void*,ref_map>(&m_sent_upstream,ref_map()));
        std::pair<std::map<void*,ref_map>::iterator, bool> insert_res_svar = map_context.insert(std::pair<void*,ref_map>(&m_sent_upstream_var,ref_map()));

        // If the new set of upstream refs is different from the last set of upstream refs we sent then send the new set.
        if(state != insert_res_sent.first->second || state_var != insert_res_svar.first->second) {
            insert_res_sent.first->second = state;
            insert_res_svar.first->second = state_var;

            if(ref_debug) {
                printf("sent upstream   ");
                insert_res_sent.first->second.print();
            }

            unsigned follow_index;
            for(follow_index = 0; follow_index < m_can_follow.size(); ++follow_index) {
#ifdef PRINT_PDR
                printf("%p => %p\n",this,m_can_follow[follow_index]);
#endif
                m_can_follow[follow_index]->process_downstream_refs_region(region, map_context, insert_res_sent.first->second, insert_res_svar.first->second, disable_opts);
#ifdef PRINT_PDR
                printf("%p <= %p\n",this,m_can_follow[follow_index]);
#endif
            }
        }
    }

    virtual void final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare, bool ref_params_in_pseudo);

    virtual bool has_loop(void) {
        check_vector<basic_block *> stack;
        return has_loop_internal(stack);
    }

    // Returns true if some change was made.
    virtual bool update_freqs(void) {
        if(m_freq == BB_FREQ_UNKNOWN) return false;

        bool made_a_change = false;

        unsigned precede_index;
        for(precede_index = 0; precede_index < m_can_precede.size(); ++precede_index) {
            if(m_can_precede[precede_index].m_freq == BB_FREQ_COMMON) {
                switch(m_freq) {
                case BB_FREQ_COMMON:
                    if (m_can_precede[precede_index].m_block->m_freq != BB_FREQ_COMMON) {
                        m_can_precede[precede_index].m_block->m_freq  = BB_FREQ_COMMON;
                        m_can_precede[precede_index].m_block->update_freqs();
                        made_a_change = true;
                    }
                    break;
                case BB_FREQ_RARE:
                    if( m_can_precede[precede_index].m_block->m_freq == BB_FREQ_UNKNOWN) {
                        m_can_precede[precede_index].m_block->m_freq  = BB_FREQ_RARE;
                        m_can_precede[precede_index].m_block->update_freqs();
                        made_a_change = true;
                    }
                    break;
                default:
                    aeprintf("Impossible BB frequency in update_freqs.\n");
                }
            } else if (m_can_precede[precede_index].m_freq == BB_FREQ_RARE) {
                switch(m_freq) {
                case BB_FREQ_COMMON:
                    if(m_can_precede[precede_index].m_block->m_freq == BB_FREQ_UNKNOWN) {
                        m_can_precede[precede_index].m_block->m_freq = BB_FREQ_RARE;
                        m_can_precede[precede_index].m_block->update_freqs();
                        made_a_change = true;
                    }
                    break;
                case BB_FREQ_RARE:
                    if(m_can_precede[precede_index].m_block->m_freq == BB_FREQ_UNKNOWN) {
                        m_can_precede[precede_index].m_block->m_freq = BB_FREQ_RARE;
                        m_can_precede[precede_index].m_block->update_freqs();
                        made_a_change = true;
                    }
                    break;
                default:
                    aeprintf("Impossible BB frequency in update_freqs.\n");
                }
            } else {
                aeprintf("Impossible BB frequency in update_freqs.\n");
            }
        }

        return made_a_change;
    }

    void get_ref_freqs(map_ref_info &mri) {
        // Walk backwards through the refs and function calls in this basic block and update
        // the state map appropriately and create the call site masks of lives refs.
        size_t this_block_refs;
        for(this_block_refs = m_live_refs_here.size();
            this_block_refs > 0;
          --this_block_refs) {
            m_live_refs_here[this_block_refs - 1]->update_ref_freq(mri);
        }
    }

    virtual std::string get_unique(void) {
        std::stringstream ss;
        ss << m_unique;
        return ss.str();
    }

    virtual void eliminate_follow(basic_block *bb) {
        unsigned i;
        // find the bb edge to eliminate.
         for(i = 0; i < m_can_follow.size(); ++i) {
            if(m_can_follow[i] == bb) break;
        }
        // assert if you couldn't find it
        if(i == m_can_follow.size()) {
            return;
//            aeprintf("Could not find follow edge to delete.\n");
        }
        unsigned j;
        // copy the following entries down one
        for(j = i+1; j < m_can_follow.size(); ++j) {
            m_can_follow[j-1] = m_can_follow[j];
        }
        // decrease the size of the vector by 1
        m_can_follow.pop_back();
    }

    virtual void eliminate_unreachable_edges(void) {
        // Detected an unreachable block.
        if(m_can_follow.size() == 0) {
            unsigned i;
            for(i = 0; i < m_can_precede.size(); ++i) {
                m_can_precede[i].m_block->eliminate_follow(this);
                m_can_precede[i].m_block->eliminate_unreachable_edges();
            }
        }
    }
};

class switch_scope_on_return {
protected:
    function_definition *m_fd;
    basic_block *m_bb;
public:
    switch_scope_on_return(function_definition *fd) : m_fd(fd) {}

    void set_block(basic_block *bb) {
        m_bb = bb;
    }

    ~switch_scope_on_return(void);
};

void add_flow_graph_edge(basic_block *before, basic_block *after, EDGE_TYPE type, BB_FREQUENCY edge_freq = BB_FREQ_COMMON, jump_statement_goto *the_goto=NULL) {
    assert(edge_freq == BB_FREQ_COMMON || edge_freq == BB_FREQ_RARE);
    if(before == NULL || after == NULL) {
        return;
    }
    before->m_can_precede.push_back(edge_info(edge_freq,after,type,the_goto));
    after->m_can_follow.push_back(before);
}

class function_refs {
public:
    std::list<ii_ptr> m_ref_params, m_ref_vars;
    check_vector<ii_ptr> m_all_vars;
};

typedef enum {
//   GC_UNKNOWN,
   GC_UNSAFE,
   GC_SAFE
} GcSafeState;

class assignment_expression_unary_expression_assignment_operator_assignment_expression;

class ref_assignment_data {
public:
    unsigned m_target_index;
    assignment_expression_unary_expression_assignment_operator_assignment_expression *m_node;

    ref_assignment_data(unsigned index,assignment_expression_unary_expression_assignment_operator_assignment_expression *node) :
        m_target_index(index),
        m_node(node) {}
};

class continuation_point;

class argument_info {
public:
    std::string m_type_name;
    std::string m_var_name;

    argument_info(void) {}

    argument_info(const std::string &type_name, const std::string &var_name) : m_type_name(type_name), m_var_name(var_name) {}
};

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

class TarjanStack : public std::stack<function_definition *, check_vector<function_definition*> > {
public:
    bool contains(function_definition *fd) {
        unsigned i;
        for(i=0;i<c.size();++i) {
            if(c[i] == fd) return true;
        }
        return false;
    }
};

class function_definition : public AST_node {
protected:
    //ii_ptr m_symbol;
    PILLAR2C_CALLCONV m_my_cc;
    basic_block *m_start_block;
    basic_block *m_finish_block;
    basic_block *m_cur_block;
    size_t m_num_total_refs;
    size_t m_num_total_vars;
    check_vector<basic_block *> m_basic_blocks;
    unsigned m_tarjan_index, m_tarjan_lowlink, m_scc_number;

//    unsigned m_num_potential_gc_callsites;
    check_vector<function_definition *> m_called_by;
    check_vector<function_definition *> m_calls;
    GcSafeState m_gc_safe;
    std::map<std::string,std::list<argument_info> > m_prt_arg_list;
//    std::map<call_expression *,std::list<argument_info> > m_prt_arg_list;
//    std::list<std::pair<std::string,std::string> > m_prt_arg_list;
    void do_loop_hoist_optimization(unsigned bb_size,
                                    const check_vector<basic_block*> &bbs_df_order,
                                    std::map<basic_block *, loop *> &function_loops,
                                    ii_ptr * id_orig_index,
                                    const std::set<ii_ptr > &disable_opts,
                                    compound_statement * &cs,
                                    const ref_map &active_refs);

    void insert_if_absent(basic_block *bb) {
        unsigned i;
        size_t bb_size = m_basic_blocks.size();
        for(i = 0; i < bb_size; ++i) {
            if(m_basic_blocks[i] == bb) return;
        }
        m_basic_blocks.push_back(bb);
    }

    unsigned m_unique;

public:
    virtual void forget_body(void) = 0;
    virtual void forget_first_parse(void) = 0;

    void done_translating(void) {
        m_start_block  = NULL;
        m_finish_block = NULL;
        m_cur_block    = NULL;
        unsigned i;
        for(i=0; i < m_basic_blocks.size(); ++i) {
            delete m_basic_blocks[i];
        }
    }

    std::multimap<unsigned,ref_assignment_data> *m_ref_assignments;
    check_vector<continuation_point *> m_continuations;
    check_vector<type_name *> m_mrv_vec;

    void update_freqs(void) {
        unsigned i;
        bool made_a_change;
        do {
            made_a_change = false;

            for(i = 0; i < m_basic_blocks.size(); ++i) {
                if(m_basic_blocks[i]->update_freqs()) {
                    made_a_change = true;
                }
            }
        } while (made_a_change);

        for(i = 0; i < m_basic_blocks.size(); ++i) {
            if( m_basic_blocks[i]->m_force_freq != BB_FREQ_UNKNOWN ) {
                m_basic_blocks[i]->m_freq = m_basic_blocks[i]->m_force_freq;
            }
        }
    }

    function_definition(void) :
        //m_symbol(NULL),
        m_my_cc(ST_NOT_DEFINED),
        m_start_block(NULL),
        m_finish_block(NULL),
        m_cur_block(NULL),
        m_num_total_refs(0),
        m_num_total_vars(0),
        m_tarjan_index(0),
        m_tarjan_lowlink(0),
        m_scc_number(0),
        m_has_except_var(false) {
        m_gc_safe = GC_SAFE;
        m_unique = g_unique_id++;
        m_ref_assignments = new std::multimap<unsigned,ref_assignment_data>;
    }  // the GC safe is assumed to be safe and later phases will set to unsafe if that is detected

    virtual ~function_definition(void) {
        delete m_ref_assignments;
    }

    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) {
        m_start_block  = new basic_block(NULL);
        m_cur_block    = m_start_block;
        m_finish_block = new basic_block(NULL);

        insert_if_absent(m_finish_block);
        insert_if_absent(m_start_block);

        m_start_block->m_freq = BB_FREQ_COMMON;

        return TranslateResult();
    }

    virtual std::string get_unique(const std::string &prepend="") {
        std::stringstream ss;
        ss << prepend << m_unique;
        return ss.str();
    }

    basic_block * get_cur_basic_block(void) {
        return m_cur_block;
    }

    void set_cur_basic_block(basic_block *block) {
        m_cur_block = block;
        if(block) {
            insert_if_absent(block);
        }
    }

    basic_block * get_finish_block(void) {
        return m_finish_block;
    }

    void set_symbol(ii_ptr ii) {
        m_ii = ii;
        m_my_cc  = m_ii->get_function_cc();
        g_func_map.insert(std::pair<std::string,function_definition *>(m_ii->get_string(),this));
#if 0
        if(m_symbol->get_string() == "iFlcSyncEqual") {
            printf("Found function of interest.\n");
        }
#endif
    }

    ii_ptr  get_symbol(void) const {
        return m_ii;
    }

    PILLAR2C_CALLCONV get_function_cc(void) const { return m_my_cc; }

    virtual function_definition * find_enclosing_function(void) const {
        return (function_definition*)this;
    }

    virtual bool in_no_yield_block(void) {
        return false;
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        aeprintf("get_func_metadata\n");
    }

    virtual AST_node * prepend_bil(block_item_list *bil) = 0;

    virtual basic_block * get_return_target(void) {
        assert(m_finish_block);
        return m_finish_block;
    }

    void function_generic_translate_pillar(
        declarator *&decl,
        declaration_specifiers *&ds,
        PILLAR2C_CALLCONV func_cc,
        compound_statement *cs,
        function_refs &refs);

    virtual size_t get_total_refs(void) const {
        return m_num_total_refs;
    }

    virtual size_t get_total_vars(void) const {
        return m_num_total_vars;
    }

    virtual call_expression * is_call_context(void) const {
        return NULL;
    }

    virtual void add_call_by(function_definition *fd) {
        if(this == fd) return; // don't add loop to yourself
        m_called_by.push_back(fd);
        fd->m_calls.push_back(this);
    }

    virtual bool is_gc_safe(void) const {
        return m_gc_safe == GC_SAFE;
    }

    virtual bool get_gc_safe_state(void) const {
        return m_gc_safe == GC_SAFE;
    }

    virtual void set_gc_unsafe(void) {
        if(m_my_cc == ST_PCDECL) {
            printf("pcdecl function %s cannot be flagged as gc unsafe.\n",m_ii->get_name());
        } else {
            m_gc_safe = GC_UNSAFE;
        }
    }

    virtual void propagate_unsafe(void) {
        if(m_gc_safe == GC_UNSAFE) {
            unsigned i;
            for(i = 0; i < m_called_by.size(); ++i) {
                if(m_called_by[i]->is_gc_safe()) {
                    m_called_by[i]->set_gc_unsafe();
                    m_called_by[i]->propagate_unsafe();
                }
            }
        }
    }

    virtual void get_func_metadata(function_metadata &cem) = 0;

    bool is_nested_call(std::string ce) {
        std::map<std::string,std::list<argument_info> >::iterator miter = m_prt_arg_list.find(ce);
        if(miter == m_prt_arg_list.end()) {
            return false;
        }
        return miter->second.size() > 1;
    }

    bool add_prt_arg_list(std::string ce, const std::string &struct_type_name, const std::string &struct_var_name) {
        std::map<std::string,std::list<argument_info> >::iterator miter = m_prt_arg_list.find(ce);
        bool second_entry = true;
        if(miter == m_prt_arg_list.end()) {
            m_prt_arg_list.insert(std::pair<std::string,std::list<argument_info> >(ce,std::list<argument_info>()));
            miter = m_prt_arg_list.find(ce);
            assert(miter != m_prt_arg_list.end());
            second_entry = false;
        }
        miter->second.push_back(argument_info(struct_type_name,struct_var_name));
//        m_prt_arg_list.push_back(std::pair<std::string,std::string>(struct_type_name,struct_var_name));
       return second_entry;
    }

    bool m_has_except_var;

    virtual bool declares_name(const char *name) = 0;
    virtual declaration_specifiers * get_declaration_specifiers(void) = 0;
    virtual declarator * get_declarator(void) = 0;

    virtual bool has_same_scc_number(function_definition *other) {
        assert(other);
        return m_scc_number == other->m_scc_number;
    }

    virtual void tarjan(unsigned &tarjan_index, TarjanStack &tarjan_stack, unsigned &scc_number) {
        if(m_tarjan_index) return; // already ran tarjan for this function

        m_tarjan_index   = tarjan_index;
        m_tarjan_lowlink = tarjan_index;
        ++tarjan_index;

        tarjan_stack.push(this);

        unsigned i;
        for(i = 0; i < m_calls.size(); ++i) {
            if(!m_calls[i]->m_tarjan_index) {
                m_calls[i]->tarjan(tarjan_index,tarjan_stack,scc_number);
                m_tarjan_lowlink = MIN(m_tarjan_lowlink, m_calls[i]->m_tarjan_lowlink);
            } else {
                if(tarjan_stack.contains(m_calls[i])) {
                    m_tarjan_lowlink = MIN(m_tarjan_lowlink, m_calls[i]->m_tarjan_index);
                }
            }
        }

        if (m_tarjan_index == m_tarjan_lowlink) {
            bool first = true;
            function_definition * save_first = NULL;
            m_scc_number = scc_number++;

            while(tarjan_stack.size()) {
                function_definition *the_top = tarjan_stack.top();
                the_top->m_scc_number = m_scc_number;
                tarjan_stack.pop();
                if(g_pillar2c_debug_level) {
                    if(first) {
                        first = false;
                        save_first = the_top;
                    } else {
                        if(save_first) {
                            printf("%d %s\n",m_tarjan_lowlink,save_first->get_symbol()->get_string().c_str());
                            printf("%d %s\n",m_tarjan_lowlink,the_top->get_symbol()->get_string().c_str());
                            save_first = NULL;
                        } else {
                            printf("%d %s\n",m_tarjan_lowlink,the_top->get_symbol()->get_string().c_str());
                        }
                    }
                }
                if(the_top == this) return;
            }
            aeprintf("Problem in the tarjan algorithm.\n");
        }
    }

    std::string get_pseudo_type(void) {
        return std::string("pillar2c_pseudo_entry_") + m_ii->get_name();
    }
};

class function_definition_fake : public function_definition {
public:
    virtual void print(void) const {
        aeprintf("Should not get here.\n");
    }

    virtual AST_node * prepend_bil(block_item_list *bil) {
        aeprintf("Should not get here.\n");
    }

    virtual void get_func_metadata(function_metadata &cem) {
        aeprintf("Should not get here.\n");
    }

    virtual bool declares_name(const char *name) {
        aeprintf("Should not get here.\n");
    }

    virtual declaration_specifiers * get_declaration_specifiers(void) {
        aeprintf("Should not get here.\n");
    }

    virtual declarator * get_declarator(void) {
        aeprintf("Should not get here.\n");
    }
    virtual void forget_body(void) {
        aeprintf("Should not get here.\n");
    }
    virtual void forget_first_parse(void) {
        aeprintf("Should not get here.\n");
    }
};

parameter_list * gen_extra_params(void) {
    parameter_list *latest = NULL;
    if(g_use_th_param) {
        latest =
          new parameter_list_parameter_declaration(
            new parameter_declaration_declaration_specifiers_declarator(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("PrtTaskHandle"))),
              new declarator_direct_declarator(
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("_pillar2c_task_handle")))));
    }

    latest =
      parameter_list::new_recursive(
        latest,
        new parameter_declaration_declaration_specifiers_declarator(
          new declaration_specifiers_type_specifier(
            new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("pillar2c_pseudo_stack_entry"))),
          new declarator_pointer_direct_declarator(
            new pointer_star(),
            new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("_pillar2c_prev_pseudo_stack")))));

    return latest;
}

block_item_list * generate_prt_args_decl(call_expression *ce) {
    std::stringstream type_buf;
    type_buf << "PrtArgs_" << ce->get_unique();

    std::stringstream var_buf;
    var_buf << "prt_args_" << ce->get_unique();

    block_item_list * bil =
        new block_item_list_block_item(
          new block_item_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(type_buf.str()))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_buf.str())))))),0));

    return bil;
}

function_refs function_determine_ref_slots(Scope *func_scope, declarator *d);

class function_definition_no_decl_list : public function_definition {
protected:
    declaration_specifiers *m_ds;
    declarator             *m_d;
    compound_statement     *m_cs;
    std::string             m_s;
public:
    function_definition_no_decl_list(
        declaration_specifiers *ds,
        declarator             *d,
        compound_statement     *cs,
        const std::string &s="") :
        m_ds(ds),
        m_d(d),
        m_cs(cs),
        m_s(s) {
        m_ds->set_parent(this);
        m_d->set_parent(this);
        m_cs->set_parent(this);
    }
    virtual ~function_definition_no_decl_list(void) {
        delete m_ds;
        delete m_d;
        delete m_cs;
    }

    virtual void forget_body(void) {
        delete m_cs;
        m_cs = NULL;
        delete m_scope;
        m_scope = NULL;
        //m_scope->clear();
    }

    virtual void forget_first_parse(void) {
        m_ii = NULL;
        delete m_ds;
        delete m_d;
        m_ds = NULL;
        m_d  = NULL;
    }

    virtual void reset(
        declaration_specifiers *ds,
        declarator             *d,
        compound_statement     *cs) {
        assert(!m_ds);
        assert(!m_d);
        assert(!m_cs);

        m_ds = ds;
        m_d  = d;
        m_cs = cs;
        m_ds->set_parent(this);
        m_d->set_parent(this);
        m_cs->set_parent(this);

        ii_ptr ii = d->add_to_symbol_table(IIT_FUNCTION);
        if(m_ii) {
            printf("This shouldn't happen.\n");
            m_ii->set_scope(NULL);
        }
        m_ii = ii;
        m_ii->set_func_definition(this);
        m_ii->set_function_cc(m_my_cc);
    }

    virtual void print(void) const {
        oprintf("\n");
        if(g_compile_as_cpp) {
            oprintf("extern \"C\" ");
        }
        m_ds->print();
        oprintf(" ");
        m_d->print();
        oprintf(" ");
        if(m_s != "") {
            oprintf("%s ",m_s.c_str());
        }
        m_cs->print();
    }

    virtual void create_call_graph(function_definition *fd) {
        g_scope_stack.reenter_scope(m_scope);

        if(m_my_cc != ST_PCDECL) {
            if(cc_to_man_unman(m_my_cc) == MU_UNMANAGED || !m_ds->is_static()) {
                m_gc_safe = GC_UNSAFE;
            }
            // If a managed function is not static then it could be called from an unknown external function.
            if(!m_ds->is_static() && m_my_cc == ST_PDECL) {
                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find("<UNKNOWN_FUNCS");
                if(fmiter == g_func_map.end()) {
                    aeprintf("Could not find <UNKNOWN_FUNCS in g_func_map.\n");
                } else {
                    add_call_by(fmiter->second);
                }
            }
            CREATE_CALL_GRAPH(m_cs,this);
        } else {
            m_gc_safe = GC_SAFE;
        }

        g_scope_stack.leave_scope();
    }

    virtual void denest(function_definition *fd) {
        g_scope_stack.reenter_scope(m_scope);

        DENEST(m_cs,this);

        g_scope_stack.leave_scope();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        fd = this;

        assert(m_scope);

//        check_consistency();

        function_definition::translate_pillar(this);

        if(g_gc_at_call && !is_gc_safe() && get_function_cc() == ST_PDECL) {
            m_cs->prepend_bil(
              new block_item_list_block_item(
                new block_item_statement(
                  new statement_expression_statement(
                    new expression_statement_expression(
                      new expression_assignment_expression(
                        expr_gen(assignment_expression,postfix_expression,
                          new postfix_expression_call_expression(
                            new call_expression_postfix_expression_empty_paren(
                              new postfix_expression_primary_expression(
                                new primary_expression_identifier(g_scope_stack.find_or_add("pgc_force_gc"))))))))),0)));
        }

#ifdef TODD_DEBUG
        printf("%s\n",m_symbol->get_string().c_str());
#endif
        function_refs refs;
        if(get_function_cc() == ST_PDECL) {
            refs = function_determine_ref_slots(m_scope,m_d);
            size_t num_ref_params = refs.m_ref_params.size();
            size_t num_ref_vars   = refs.m_ref_vars.size();
            m_num_total_refs = num_ref_params + num_ref_vars;
            m_num_total_vars = refs.m_all_vars.size();
        }

        if(g_restrict_limit) {
            if(m_num_total_refs < g_restrict_limit) {
                g_use_restrict_pointer = true;
            } else {
                if(g_verbose) {
                    printf("Use of restrict pointer turned off for function %s due to exceedling ref limit of %d.\n",get_symbol()->get_name(),g_restrict_limit);
                }
                g_use_restrict_pointer = false;
            }
        } else {
            g_use_restrict_pointer = false;
        }

        TranslateResult tr1, tr2, tr3;

        TRANSLATE(m_ds,tr1);
        TRANSLATE(m_d,tr2);

#ifdef _DEBUG
        if(m_ii->get_string() == DEBUG_FUNC) {
            ref_debug = true;
        }
#endif

        g_scope_stack.reenter_scope(m_scope);

        TRANSLATE(m_cs,tr3);

        if(m_cur_block) {
            add_flow_graph_edge(m_cur_block, m_finish_block, EDGE_FALLTHROUGH);
        }

        update_freqs();

        g_scope_stack.leave_scope();

        check_consistency();

        function_generic_translate_pillar(m_d,m_ds,m_my_cc,m_cs,refs);

        done_translating();

        return TranslateResult();
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        m_d->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
        cem.m_ret = get_return_type();
        cem.m_func_metadata.m_noreturn = m_ds->has_noreturn();
    }

    virtual void get_func_metadata(function_metadata &cem) {
        m_d->vectorize_params(cem.m_params,cem.m_ellipsis);
        cem.m_noreturn = m_ds->has_noreturn();
    }

    virtual expression_type * get_return_type(void) {
        expression_type *ret = new expression_type;

        ret->m_sql = m_ds->gen_specifier_qualifier_list();
        ret->m_ad  = m_d->gen_abstract_declarator_for_type();

        return ret;
    }

    virtual expression_type * get_type(void) {
        expression_type *ret = new expression_type;

        ret->m_sql = m_ds->gen_specifier_qualifier_list();
        direct_declarator *dd = m_d->get_direct_declarator();
        ret->m_ad = dd->gen_func_type();

        return ret;
    }

    virtual AST_node * prepend_bil(block_item_list *bil) {
        m_cs = m_cs->prepend_bil(bil);
        return NULL;
    }

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual declarator * get_declarator(void) {
        return m_d;
    }

    AST_DEF_CHILDREN_3(m_ds,m_d,m_cs)
};

class function_definition_with_decl_list : public function_definition {
protected:
    declaration_specifiers *m_ds;
    declarator             *m_d;
    declaration_list       *m_dl;
    compound_statement     *m_cs;
public:
    function_definition_with_decl_list(
        declaration_specifiers *ds,
        declarator             *d,
        declaration_list       *dl,
        compound_statement     *cs) :
        m_ds(ds),
        m_d(d),
        m_dl(dl),
        m_cs(cs) {
        m_ds->set_parent(this);
        m_d->set_parent(this);
        m_dl->set_parent(this);
        m_cs->set_parent(this);
    }

    virtual ~function_definition_with_decl_list(void) {
        delete m_ds;
        delete m_d;
        delete m_dl;
        delete m_cs;
    }

    virtual void forget_body(void) {
        delete m_cs;
        m_cs = NULL;
        delete m_scope;
        m_scope = NULL;
        //m_scope->clear();
}

    virtual void forget_first_parse(void) {
        m_ii = NULL;
        delete m_ds;
        delete m_d;
        delete m_dl;
        m_ds = NULL;
        m_d  = NULL;
        m_dl = NULL;
    }

    virtual void reset(
        declaration_specifiers *ds,
        declarator             *d,
        declaration_list       *dl,
        compound_statement     *cs) {
        assert(!m_ds);
        assert(!m_d);
        assert(!m_dl);
        assert(!m_cs);
        m_ds = ds;
        m_d  = d;
        m_dl = dl;
        m_cs = cs;
        m_ds->set_parent(this);
        m_d->set_parent(this);
        m_dl->set_parent(this);
        m_cs->set_parent(this);

        ii_ptr ii = d->add_to_symbol_table(IIT_FUNCTION);
        if(m_ii) {
            printf("This shouldn't happen.\n");
            m_ii->set_scope(NULL);
        }
        m_ii = ii;
        m_ii->set_func_definition(this);
        m_ii->set_function_cc(m_my_cc);
    }

    virtual void print(void) const {
        oprintf("\n");
        if(g_compile_as_cpp) {
            oprintf("extern \"C\" ");
        }
        m_ds->print();
        oprintf(" ");
        m_d->print();
        oprintf(" ");
        m_dl->print();
        oprintf(" ");
        m_cs->print();
    }

    virtual void create_call_graph(function_definition *fd) {
        g_scope_stack.reenter_scope(m_scope);

        if(m_my_cc != ST_PCDECL) {
            if(cc_to_man_unman(m_my_cc) == MU_UNMANAGED || !m_ds->is_static()) {
                m_gc_safe = GC_UNSAFE;
            }
            // If a managed function is not static then it could be called from an unknown external function.
            if(!m_ds->is_static() && m_my_cc == ST_PDECL) {
                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find("<UNKNOWN_FUNCS");
                if(fmiter == g_func_map.end()) {
                    aeprintf("Could not find <UNKNOWN_FUNCS in g_func_map.\n");
                } else {
                    add_call_by(fmiter->second);
                }
            }
            CREATE_CALL_GRAPH(m_cs,this);
        } else {
            m_gc_safe = GC_SAFE;
        }

        g_scope_stack.leave_scope();
    }

    virtual void denest(function_definition *fd) {
        g_scope_stack.reenter_scope(m_scope);

        DENEST(m_cs,this);

        g_scope_stack.leave_scope();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        fd = this;

        assert(m_scope);

        function_definition::translate_pillar(this);

        if(g_gc_at_call && !is_gc_safe()) {
            m_cs->prepend_bil(
              new block_item_list_block_item(
                new block_item_statement(
                  new statement_expression_statement(
                    new expression_statement_expression(
                      new expression_assignment_expression(
                        expr_gen(assignment_expression,postfix_expression,
                          new postfix_expression_call_expression(
                            new call_expression_postfix_expression_empty_paren(
                              new postfix_expression_primary_expression(
                                new primary_expression_identifier(g_scope_stack.find_or_add("pgc_force_gc"))))))))),0)));
        }

        function_refs refs;
        if(cc_to_man_unman(get_function_cc()) == MU_MANAGED) {
            refs = function_determine_ref_slots(m_scope,m_d);
            size_t num_ref_params = refs.m_ref_params.size();
            size_t num_ref_vars   = refs.m_ref_vars.size();
            m_num_total_refs = num_ref_params + num_ref_vars;
        }

        TranslateResult tr1, tr2, tr3, tr4;

        TRANSLATE(m_ds,tr1);
        TRANSLATE(m_d,tr2);
        TRANSLATE(m_dl,tr3);

        g_scope_stack.reenter_scope(m_scope);

        TRANSLATE(m_cs,tr4);

        if(m_cur_block) {
            add_flow_graph_edge(m_cur_block, m_finish_block, EDGE_FALLTHROUGH);
        }

        update_freqs();

        g_scope_stack.leave_scope();

        check_consistency();

        function_generic_translate_pillar(m_d,m_ds,m_my_cc,m_cs,refs);

        done_translating();

        return TranslateResult();
    }

    virtual void get_func_metadata(call_expression_metadata &cem) {
        m_d->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
        cem.m_ret = get_return_type();
        cem.m_func_metadata.m_noreturn = m_ds->has_noreturn();
    }

    virtual expression_type * get_return_type(void) {
        expression_type *ret = new expression_type;

        ret->m_sql = m_ds->gen_specifier_qualifier_list();
        ret->m_ad  = m_d->gen_abstract_declarator_for_type();

        return ret;
    }

    virtual expression_type * get_type(void) {
        expression_type *ret = new expression_type;

        ret->m_sql = m_ds->gen_specifier_qualifier_list();
        direct_declarator *dd = m_d->get_direct_declarator();
        ret->m_ad = dd->gen_func_type();

        return ret;
    }

    virtual AST_node * prepend_bil(block_item_list *bil) {
        m_cs = m_cs->prepend_bil(bil);
        return NULL;
    }

    virtual void get_func_metadata(function_metadata &cem) {
        m_d->vectorize_params(cem.m_params,cem.m_ellipsis);
        cem.m_noreturn = m_ds->has_noreturn();
    }

    virtual bool declares_name(const char *name) {
        return m_ds->declares_name(name);
    }

    virtual declaration_specifiers * get_declaration_specifiers(void) {
        return m_ds;
    }

    virtual declarator * get_declarator(void) {
        return m_d;
    }

    AST_DEF_CHILDREN_4(m_ds,m_d,m_dl,m_cs)
};

//==========================================================================

class external_declaration : public AST_node {
protected:
    ED_ITER m_iter;
    PILLAR2C_CALLCONV m_default_cc;
public:
    external_declaration(void) {
        m_default_cc = g_cc_stack.top();
    }
    virtual ~external_declaration () {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual bool declares_name(const char *name) = 0;
    void set_iter(const ED_ITER &iter) {
        m_iter = iter;
    }

    void set_default_cc(PILLAR2C_CALLCONV cc) {
        m_default_cc = cc;
    }
    PILLAR2C_CALLCONV get_default_cc(void) const { return m_default_cc; }

    virtual void insert_before_top_level(external_declaration *ed) {
#ifdef MULTITHREAD
        pthread_mutex_lock(&g_ed_mutex);
#endif
        ed->set_iter(g_ed_list.insert(m_iter,ed));
#ifdef MULTITHREAD
        pthread_mutex_unlock(&g_ed_mutex);
#endif
    }

    virtual void insert_after_top_level(external_declaration *ed) {
#ifdef MULTITHREAD
        pthread_mutex_lock(&g_ed_mutex);
#endif
        ED_ITER next = m_iter;
        ++next;
        ed->set_iter(g_ed_list.insert(next,ed));
#ifdef MULTITHREAD
        pthread_mutex_unlock(&g_ed_mutex);
#endif
    }

    virtual void insert_before_top_level(std::list<external_declaration *> &ed) {
#ifdef MULTITHREAD
        pthread_mutex_lock(&g_ed_mutex);
#endif
        std::list<external_declaration *>::iterator ed_iter;
        for(ed_iter  = ed.begin();
            ed_iter != ed.end();
          ++ed_iter) {
            external_declaration *one_ed = *ed_iter;
            one_ed->set_iter(g_ed_list.insert(m_iter,one_ed));
        }
#ifdef MULTITHREAD
        pthread_mutex_unlock(&g_ed_mutex);
#endif
    }
};

class external_declaration_declaration : public external_declaration {
protected:
    declaration *m_d;
public:
    external_declaration_declaration(declaration *d) : m_d(d) {
        m_d->set_parent(this);
    }
    virtual ~external_declaration_declaration(void) {
        delete m_d;
    }

    virtual void print(void) const {
        m_d->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_d,tr);
        return tr;
    }

    virtual bool declares_name(const char *name) {
        return m_d->declares_name(name);
    }

    virtual declaration * get_declaration(void) {
        return m_d;
    }

    AST_DEF_CHILDREN_1(m_d)
};

class external_declaration_emit_text : public external_declaration {
protected:
    std::string m_text;
public:
    external_declaration_emit_text(const std::string &et) : m_text(et) {}

    virtual ~external_declaration_emit_text(void) {
    }

    virtual void print(void) const {
        oprintf(m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_pound_line : public external_declaration {
protected:
    std::string m_text;
public:
    external_declaration_pound_line(const std::string &text) : m_text(text) {}

    virtual ~external_declaration_pound_line(void) {}

    virtual void print(void) const {
        oprintf("%s\n",m_text.c_str());
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_function_definition : public external_declaration {
protected:
    function_definition *m_fd;
public:
    external_declaration_function_definition(function_definition *fd) : m_fd(fd) {
        m_fd->set_parent(this);
    }
    virtual ~external_declaration_function_definition(void) {
        delete m_fd;
    }

    virtual void print(void) const {
        m_fd->print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_fd,tr);
        return tr;
    }

    virtual function_definition * claim(void) {
        function_definition *ret = m_fd;
        m_fd = NULL;
        return ret;
    }

    virtual function_definition * get_function_definition(void) {
        return m_fd;
    }

    virtual bool declares_name(const char *name) {
        return m_fd->declares_name(name);
    }

    AST_DEF_CHILDREN_1(m_fd)
};

class external_declaration_hash : public external_declaration {
protected:
   char *m_hash;
public:
    external_declaration_hash(char *hash) : m_hash(hash) {}

    virtual void print(void) const {
        oprintf("%s\n",m_hash);
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_semicolon : public external_declaration {
public:
    virtual void print(void) const {
        oprintf(";\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_prt_managed_off : public external_declaration {
public:
    external_declaration_prt_managed_off(void) {
//        printf("prt_managed_off\n");
    }
    virtual void print(void) const {
        aeprintf("Should never emit a Pillar construct, pillar_managed_off.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        g_ed_list.erase(m_iter);
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_prt_managed_on : public external_declaration {
public:
    external_declaration_prt_managed_on(void) {
//        printf("prt_managed_on\n");
    }
    virtual void print(void) const {
        aeprintf("Should not attempt to print Pillar construct pillar_managed_on.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        g_ed_list.erase(m_iter);
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

class external_declaration_prt_push_cc : public external_declaration {
protected:
    call_conv_specifier *m_ccs;
public:
    external_declaration_prt_push_cc(call_conv_specifier *ccs) : m_ccs(ccs) {
        m_ccs->set_parent(this);
    }

   ~external_declaration_prt_push_cc(void) {
        delete m_ccs;
    }

    virtual void print(void) const {
        aeprintf("Should never emit a Pillar construct, prt_push_cc.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        g_ed_list.erase(m_iter);
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }

    AST_DEF_CHILDREN_1(m_ccs)
};

class external_declaration_prt_pop_cc : public external_declaration {
public:
    external_declaration_prt_pop_cc(void) {}

    virtual void print(void) const {
        aeprintf("Should not attempt to print Pillar construct prt_pop_cc.\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        g_ed_list.erase(m_iter);
        return TranslateResult();
    }

    virtual bool declares_name(const char *name) {
        return false;
    }
};

//==========================================================================

class translation_unit : public AST_node {
public:
    virtual ~translation_unit (void) {}
    virtual void print(void) const = 0;
    virtual TranslateResult translate_pillar(function_definition *fd) = 0;
    virtual void prepend(translation_unit *tu) = 0;
    virtual compound_statement * get_enclosing_compound_statement(void) {
        return NULL;
    }
    virtual void to_list(std::list<external_declaration *> &output) = 0;
};

class translation_unit_external_declaration : public translation_unit {
protected:
    external_declaration *m_ed;
public:
    translation_unit_external_declaration(external_declaration *ed) : m_ed(ed) {
        m_ed->set_parent(this);
    }
    virtual ~translation_unit_external_declaration(void) {
        delete m_ed;
    }

    virtual void print(void) const {
        m_ed->print();
        oprintf("\n");
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr;
        TRANSLATE(m_ed,tr);
        return tr;
    }

    virtual void prepend(translation_unit *tu);
    virtual external_declaration * remove_decl_by_name(const char *name) {
        // FIX FIX FIX - NEED TO IMPLEMENT
        return NULL;
        aeprintf("remove_decl_by_name\n");
    }

    virtual void insert_before_top_level(external_declaration *ed);

    virtual void to_list(std::list<external_declaration *> &output) {
        m_ed->set_parent(NULL);
        output.push_back(m_ed);
        m_ed = NULL;
        delete this;
    }

    AST_DEF_CHILDREN_1(m_ed)
};

class translation_unit_translation_unit_external_declaration : public translation_unit_external_declaration {
protected:
    translation_unit *m_tu;
public:
    translation_unit_translation_unit_external_declaration(translation_unit *tu,external_declaration *ed) : translation_unit_external_declaration(ed), m_tu(tu) {
        m_tu->set_parent(this);
    }
    virtual ~translation_unit_translation_unit_external_declaration(void) {
        delete m_tu;
    }

    virtual void print(void) const {
        m_tu->print();
        if(g_output_mode) {
            if(g_output_cur_line_number > 50000) {
                if(g_output_file_base != "") {
                    std::stringstream complete_name;
                    complete_name << g_output_file_base << ++g_output_file_postfix << ".c";

                    oprintf("#include \"%s\"\n",complete_name.str().c_str());
                    fclose(g_output_file);
                    g_output_file = fopen(complete_name.str().c_str(),"w");
                    assert(g_output_file);
                }
                g_output_cur_line_number = 0;
            }
        }
        translation_unit_external_declaration::print();
    }

    virtual TranslateResult translate_pillar(function_definition *fd) {
        TranslateResult tr1, tr2;
        TRANSLATE(m_tu,tr1);
        TRANSLATE(m_ed,tr2);
        aeprintf("type problem\n");
        // FIX FIX FIX combine tr1 and tr2
        return tr1;
    }

    friend class translation_unit_external_declaration;

    virtual void prepend(translation_unit *tu) {
        m_tu->prepend(tu);
    }
    virtual external_declaration * remove_decl_by_name(const char *name) {
        if(m_ed->declares_name(name)) {
            external_declaration * ret = m_ed;
            if(!m_parent) {
                aeprintf("remove_decl_by_name has not implemented the case where the decl to be removed is the last one in the AST.\n");
            }
            m_parent->replace(this,m_tu);
            m_ed = NULL;
            m_tu = NULL;
            delete this;
            return ret;
        } else {
            return m_tu->remove_decl_by_name(name);
        }
    }

    virtual void insert_before_top_level(external_declaration *ed) {
        translation_unit_translation_unit_external_declaration *new_node = new
            translation_unit_translation_unit_external_declaration(m_tu,ed);
        m_tu = new_node;
        new_node->set_parent(this);
    }

    virtual void to_list(std::list<external_declaration *> &output) {
        m_tu->to_list(output);
        m_ed->set_parent(NULL);
        output.push_back(m_ed);
        m_ed = NULL;
        m_tu = NULL;
        delete this;
    }

    static translation_unit * new_recursive(translation_unit *tu,external_declaration *ed);

    AST_DEF_CHILDREN_2(m_ed,m_tu)
};

translation_unit * translation_unit_translation_unit_external_declaration::new_recursive(translation_unit *tu,external_declaration *ed) {
    if(tu) {
        return new translation_unit_translation_unit_external_declaration(tu,ed);
    } else {
        return new translation_unit_external_declaration(ed);
    }
}

void translation_unit_external_declaration::prepend(translation_unit *tu) {
    translation_unit_translation_unit_external_declaration *new_node =
        new translation_unit_translation_unit_external_declaration(tu,m_ed);

    if(m_parent) {
        translation_unit_translation_unit_external_declaration *parent;
        parent = dynamic_cast<translation_unit_translation_unit_external_declaration *>(m_parent);
        parent->m_tu = new_node;
    } else {
        aeprintf("Should never prepend to beginning of translation tree when using top level list.\n");
    }
    new_node->set_parent(m_parent);

    m_ed = NULL;
    delete this;
}

//==========================================================================

// ADD_TO_SYMBOL_TABLE Implementations

ii_ptr  declaration_specifiers_type_specifier::add_to_symbol_table(void) const {
    return m_ts->add_to_symbol_table();
}

ii_ptr  type_specifier_struct_or_union_specifier::add_to_symbol_table(void) const {
    return m_sous->add_to_symbol_table();
}

ii_ptr  type_specifier_enum_specifier::add_to_symbol_table(void) const {
    return m_es->add_to_symbol_table();
}

ii_ptr  direct_declarator_paren_declarator::add_to_symbol_table(bool is_typedef) {
    return m_d->add_to_symbol_table(is_typedef);
}

ii_ptr  direct_declarator_direct_declarator_parameter_type_list::add_to_symbol_table(bool is_typedef) {
    ii_ptr ii = m_dd->add_to_symbol_table(is_typedef ? IIT_TYPEDEF_FUNCTION : IIT_FUNCTION);
    declarator *dp = dynamic_cast<declarator*>(m_parent);
    assert(dp);
    ii->set_function_cc(fix_cc_default(dp->get_call_conv()));
    ii->set_func_decl(this);
    return ii;
}

ii_ptr  direct_declarator_direct_declarator_identifier_list::add_to_symbol_table(bool is_typedef) {
    ii_ptr ii = m_dd->add_to_symbol_table(is_typedef ? IIT_TYPEDEF_FUNCTION : IIT_FUNCTION);
    declarator *dp = dynamic_cast<declarator*>(m_parent);
    assert(dp);
    ii->set_function_cc(fix_cc_default(dp->get_call_conv()));
    ii->set_func_decl(this);
    return ii;
}

ii_ptr  direct_declarator_direct_declarator_empty_paren::add_to_symbol_table(bool is_typedef) {
    ii_ptr ii = m_dd->add_to_symbol_table(is_typedef ? IIT_TYPEDEF_FUNCTION : IIT_FUNCTION);
    declarator *dp = dynamic_cast<declarator*>(m_parent);
    ii->set_function_cc(fix_cc_default(dp->get_call_conv()));
    ii->set_func_decl(this);
    return ii;
}

ii_ptr  direct_declarator_paren_declarator::add_to_symbol_table(symbol_type st) {
    return m_d->add_to_symbol_table(st);
}

//==========================================================================

// PRINT Implementations

void primary_expression_expression::print(void) const {
    oprintf("( ");
    m_e->print();
    oprintf(") ");
}

void postfix_expression_postfix_expression_brace_expression::print(void) const {
    m_pe->print();
    oprintf("[");
    m_e->print();
    oprintf("]");
}

void call_expression_postfix_expression_paren_argument_expression_list::print(void) const {
    m_pe->print();
    oprintf("(");
    m_ael->print();
    oprintf(")");
}

void postfix_expression_postfix_expression_paren_argument_expression_list::print(void) const {
    m_pe->print();
    oprintf("(");
    m_ael->print();
    oprintf(")");
}

void postfix_expression_type_name_initializer_list::print(void) const {
    oprintf("(");
    m_tn->print();
    oprintf(") {");
    m_il->print();
    oprintf("} ");
}

void postfix_expression_type_name_initializer_list_comma::print(void) const {
    oprintf("(");
    m_tn->print();
    oprintf(") {");
    m_il->print();
    oprintf(", } ");
}

void argument_expression_list_assignment_expression::print(void) const {
    m_ae->print();
}

void argument_expression_list_argument_expression_list_assignment_expression::print(void) const {
    m_ael->print();
    oprintf(" , ");
    m_ae->print();
}

void unary_expression_unary_operator_cast_expression::print(void) const {
    m_uo->print();
    oprintf(" ");
    m_ce->print();
}

void unary_expression_sizeof_type_name::print(void) const {
    oprintf("sizeof (");
    m_tn->print();
    oprintf(") ");
}

void cast_expression_type_name_cast_expression::print(void) const {
    oprintf("(");
    m_tn->print();
    oprintf(") ");
    m_ce->print();
}

void conditional_expression_logical_or_expression_expression_conditional_expression::print(void) const {
    m_loe->print();
    oprintf(" ? ");
    m_e->print();
    oprintf(" : ");
    m_ce->print();
}

void assignment_expression_unary_expression_assignment_operator_assignment_expression::print(void) const {
    m_ue->print();
    oprintf(" ");
    m_ao->print();
    oprintf(" ");
    m_ae->print();
}

void declaration_declaration_specifiers::print(void) const {
    if(is_function() && g_compile_as_cpp) {
        oprintf("extern \"C\" ");
    }
    m_ds->print();
    oprintf(";\n");
}

void declaration_declaration_specifiers_init_declarator_list::print(void) const {
    if(is_function() && g_compile_as_cpp) {
        oprintf("extern \"C\" ");
    }
    m_ds->print();
    oprintf(" ");
    if(m_before_s != "") {
        oprintf(" %s ",m_before_s.c_str());
    }
    m_idl->print();
#ifndef BLAH
    if(m_au) {
        oprintf(" ");
        m_au->print();
    }
#else
    if(m_after_s != "") {
        oprintf(" %s ",m_after_s.c_str());
    }
#endif
    oprintf(";\n");
}

void declaration_specifiers_type_specifier::print(void) const {
    m_ts->print();
}

void declaration_specifiers_type_specifier_declaration_specifiers::print(void) const {
    m_ts->print();
    oprintf(" ");
    m_ds->print();
}

void declaration_specifiers_type_qualifier::print(void) const {
    m_tq->print();
}

void declaration_specifiers_type_qualifier_declaration_specifiers::print(void) const {
    m_tq->print();
    oprintf(" ");
    m_ds->print();
}

void declaration_specifiers_function_specifier::print(void) const {
    m_fs->print();
}

void declaration_specifiers_function_specifier_declaration_specifiers::print(void) const {
    m_fs->print();
    oprintf(" ");
    m_ds->print();
}

void declaration_specifiers_gcc_attribute_declaration_specifiers::print(void) const {
    oprintf("%s ",m_s.c_str());
    m_ds->print();
}

void init_declarator_declarator_initializer::print(void) const {
    init_declarator_declarator::print();
    oprintf(" = ");
    m_i->print();
}

void type_specifier_struct_or_union_specifier::print(void) const {
    m_sous->print();
}

void type_specifier_enum_specifier::print(void) const {
    m_es->print();
}

void struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list::print(void) const {
    m_sou->print();
    oprintf(" %s {\n",m_id.c_str());
    m_sdl->print();
    oprintf("}");
}

void struct_or_union_specifier_struct_or_union_struct_declaration_list::print(void) const {
    m_sou->print();
    oprintf(" {\n");
    m_sdl->print();
    oprintf("} ");
}

void struct_or_union_specifier_struct_or_union_identifier::print(void) const {
    m_sou->print();
    oprintf(" %s",m_id.c_str());
}

void struct_declaration_list_struct_declaration_list_anonymous_struct_declaration::print(void) const {
    m_sdl->print();
    m_sd->print();
}

void struct_declaration_list_anonymous_struct_declaration::print(void) const {
    m_sd->print();
}

void struct_declaration_list_struct_declaration_list_struct_declaration::print(void) const {
    m_sdl->print();
    m_sd->print();
}

void struct_declaration_list_struct_declaration::print(void) const {
    m_sd->print();
}

void anonymous_struct_declaration_specifier_qualifier_list::print(void) const {
    m_sql->print();
    oprintf(";\n");
}

void struct_declaration_specifier_qualifier_list_struct_declarator_list::print(void) const {
    m_sql->print();
    oprintf(" ");
    m_sdl->print();
    oprintf(";\n");
}

void specifier_qualifier_list_type_qualifier_specifier_qualifier_list::print(void) const {
    m_tq->print();
    oprintf(" ");
    m_ql->print();
}

std::ostream & specifier_qualifier_list_type_qualifier_specifier_qualifier_list::strprint(std::ostream &os) const {
    m_tq->strprint(os);
    os << " ";
    return m_ql->strprint(os);
}

void specifier_qualifier_list_type_qualifier::print(void) const {
    m_tq->print();
}

std::ostream & specifier_qualifier_list_type_qualifier::strprint(std::ostream &os) const {
    return m_tq->strprint(os);
}

void struct_declarator_list_struct_declarator::print(void) const {
    m_sd->print();
}

void struct_declarator_list_struct_declarator_list_struct_declarator::print(void) const {
    m_sdl->print();
    oprintf(" , ");
    m_sd->print();
}

void struct_declarator_declarator::print(void) const {
    m_d->print();
}

void struct_declarator_declarator_constant_expression::print(void) const {
    m_d->print();
    oprintf(" : ");
    m_ce->print();
}

void enum_specifier_enumerator_list::print(void) const {
    oprintf("enum {\n");
    m_el->print();
    oprintf("\n} ");
}

void enum_specifier_enumerator_list_comma::print(void) const {
    oprintf("enum {\n");
    m_el->print();
    oprintf(" ,\n} ");
}

void enum_specifier_identifier_enumerator_list::print(void) const {
    oprintf("enum %s {\n",m_id.c_str());
    m_el->print();
    oprintf("\n} ");
}

void enum_specifier_identifier_enumerator_list_comma::print(void) const {
    oprintf("enum %s { ",m_id.c_str());
    m_el->print();
    oprintf(" ,\n} ");
}

void enumerator_list_enumerator::print(void) const {
    m_e->print();
}

void enumerator_list_enumerator_list_enumerator::print(void) const {
    m_el->print();
    oprintf(" ,\n");
    m_e->print();
}

void declarator_pointer_direct_declarator::print(void) const {
    if(m_s != "") {
        oprintf("%s ",m_s.c_str());
    }
    m_p->print();
    oprintf(" ");
    m_dd->print();
}

void declarator_pointer_call_conv_specifier_direct_declarator::print(void) const {
    if(m_s != "") {
        oprintf("%s ",m_s.c_str());
    }
    m_p->print();
    oprintf(" ");
    if(!m_suppress_explicit_call_conv) {
//    if(!m_post_translate && !m_suppress_explicit_call_conv) {
        m_ccs->print();
        oprintf(" ");
    }
    m_dd->print();
}

void declarator_call_conv_specifier_pointer_direct_declarator::print(void) const {
    if(m_s != "") {
        oprintf("%s ",m_s.c_str());
    }
    if(!m_suppress_explicit_call_conv) {
//    if(!m_post_translate && !m_suppress_explicit_call_conv) {
        m_ccs->print();
        oprintf(" ");
    }
    m_p->print();
    oprintf(" ");
    m_dd->print();
}

void declarator_call_conv_specifier_direct_declarator::print(void) const {
    if(!m_suppress_explicit_call_conv) {
        m_ccs->print();
        oprintf(" ");
    }
    if(m_s != "") {
        oprintf("%s ",m_s.c_str());
    }
    m_dd->print();
}

void direct_declarator_paren_declarator::print(void) const {
    oprintf("( ");
    m_d->print();
    oprintf(" ) ");
}

void direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::print(void) const {
    m_dd->print();
    oprintf(" [ ");
    m_tql->print();
    oprintf(" ");
    m_ae->print();
    oprintf(" ] ");
}

void direct_declarator_direct_declarator_type_qualifier_list::print(void) const {
    m_dd->print();
    oprintf(" [ ");
    m_tql->print();
    oprintf(" ] ");
}

void direct_declarator_direct_declarator_assignment_expression::print(void) const {
    m_dd->print();
    oprintf(" [ ");
    m_ae->print();
    oprintf(" ] ");
}

void direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::print(void) const {
    m_dd->print();
    oprintf(" [ static ");
    m_tql->print();
    oprintf(" ");
    m_ae->print();
    oprintf(" ] ");
}

void direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::print(void) const {
    m_dd->print();
    oprintf(" [ ");
    m_tql->print();
    oprintf(" static ");
    m_ae->print();
    oprintf(" ] ");
}

void direct_declarator_direct_declarator_type_qualifier_list_star::print(void) const {
    m_dd->print();
    oprintf(" [ ");
    m_tql->print();
    oprintf(" * ] ");
}

void direct_declarator_direct_declarator_parameter_type_list::print(void) const {
    m_dd->print();
    oprintf(" ( ");
    m_ptl->print();
    oprintf(" ) ");
}

void direct_declarator_direct_declarator_identifier_list::print(void) const {
    m_dd->print();
    oprintf(" ( ");
    m_il->print();
    oprintf(" ) ");
}

void pointer_star_type_qualifier_list::print(void) const {
    oprintf("* ");
    m_tql->print();
}

void pointer_star_type_qualifier_list_pointer::print(void) const {
    oprintf("* ");
    m_tql->print();
    oprintf(" ");
    m_p->print();
}

void parameter_list_parameter_declaration::print(void) const {
    m_pd->print();
}

void parameter_list_parameter_list_parameter_declaration::print(void) const {
    m_pl->print();
    oprintf(" , ");
    m_pd->print();
}

void parameter_declaration_declaration_specifiers_abstract_declarator::print(void) const {
    m_ds->print();
    oprintf(" ");
    m_ad->print();
}

void type_name_specifier_qualifier_list_abstract_declarator::print(void) const {
    m_sql->print();
    oprintf(" ");
    m_ad->print();
}

void abstract_declarator_direct_abstract_declarator::print(void) const {
    m_dad->print();
}

void abstract_declarator_pointer_direct_abstract_declarator::print(void) const {
    m_p->print();
    oprintf(" ");
    m_dad->print();
}

void abstract_declarator_call_conv_specifier_direct_abstract_declarator::print(void) const {
    m_ccs->print();
    oprintf(" ");
    m_dad->print();
}

void abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::print(void) const {
    m_ccs->print();
    oprintf(" ");
    m_p->print();
    oprintf(" ");
    m_dad->print();
}

void initializer_initializer_list::print(void) const {
    oprintf(" { ");
    m_il->print();
    oprintf(" } ");
}

void initializer_initializer_list_comma::print(void) const {
    oprintf(" { ");
    m_il->print();
    oprintf(" , } ");
}

void initializer_list_designation_initializer::print(void) const {
    m_d->print();
    oprintf(" ");
    m_i->print();
}

void initializer_list_initializer_list_designation_initializer::print(void) const {
    m_il->print();
    oprintf(" , ");
    m_d->print();
    oprintf(" ");
    m_i->print();
}

void statement_labeled_statement::print(void) const {
    cut_print(m_s);
}

void statement_compound_statement::print(void) const {
    m_s->print();
}

void statement_expression_statement::print(void) const {
    if(!m_inactive) {
        cut_print(m_s);
    }
}

void statement_selection_statement::print(void) const {
    cut_print(m_s);
}

void statement_iteration_statement::print(void) const {
    cut_print(m_s);
}

void statement_jump_statement::print(void) const {
    cut_print(m_s);
}

void statement_UUASM::print(void) const {
    oprintf(m_asm.c_str());
}

void statement_UUASMUU::print(void) const {
    std::stringstream expand_percent;
    unsigned len;
    for(len = 0; len < m_asm.length(); ++len) {
        if(m_asm[len] == '%') {
            expand_percent << "%%";
        } else {
            expand_percent << m_asm[len];
        }
    }
    oprintf(expand_percent.str().c_str());
    oprintf(";\n");
}

void statement_UASM::print(void) const {
    oprintf(m_asm.c_str());
}

void postfix_expression_call_expression::print(void) const {
    m_ce->print();
}

//==========================================================================

// CONSTRUCTORS

primary_expression_expression::primary_expression_expression(expression *e) : m_e(e) {
    m_e->set_parent(this);
}

postfix_expression_postfix_expression_brace_expression::postfix_expression_postfix_expression_brace_expression(postfix_expression *pe, expression *e) : m_pe(pe), m_e(e) {
    m_pe->set_parent(this);
    m_e->set_parent(this);
}

postfix_expression_call_expression::postfix_expression_call_expression(call_expression *ce) : m_ce(ce) {
    m_ce->set_parent(this);
}

postfix_expression_postfix_expression_paren_argument_expression_list::postfix_expression_postfix_expression_paren_argument_expression_list(postfix_expression *pe,argument_expression_list *ael) : m_pe(pe), m_ael(ael) {
    m_pe->set_parent(this);
    m_ael->set_parent(this);
}

postfix_expression_type_name_initializer_list::postfix_expression_type_name_initializer_list(type_name *tn,initializer_list *il) : m_tn(tn), m_il(il) {
    m_tn->set_parent(this);
    m_il->set_parent(this);
}

postfix_expression_type_name_initializer_list_comma::postfix_expression_type_name_initializer_list_comma(type_name *tn,initializer_list *il) : m_tn(tn), m_il(il) {
    m_tn->set_parent(this);
    m_il->set_parent(this);
}

statement_labeled_statement::statement_labeled_statement(labeled_statement *s) : m_s(s) {
    m_s->set_parent(this);
}

statement_compound_statement::statement_compound_statement(compound_statement *s) : m_s(s) {
    m_s->set_parent(this);
}

statement_PRT_NOYIELD_compound_statement::statement_PRT_NOYIELD_compound_statement(compound_statement *s) : m_s(s), m_post_translate(g_translation_started) {
    m_s->set_parent(this);
}

statement_PRT_VSE_compound_statement::statement_PRT_VSE_compound_statement(ii_ptr ii, compound_statement *s) : m_ii(ii), m_s(s), m_post_translate(g_translation_started) {
    m_s->set_parent(this);
}

statement_expression_statement::statement_expression_statement(expression_statement *s) : m_s(s), m_inactive(false) {
    m_s->set_parent(this);
}

statement_selection_statement::statement_selection_statement(selection_statement *s) : m_s(s) {
    m_s->set_parent(this);
}

statement_iteration_statement::statement_iteration_statement(iteration_statement *s) : m_s(s) {
    m_s->set_parent(this);
}

statement_jump_statement::statement_jump_statement(jump_statement *s) : m_s(s) {
    m_s->set_parent(this);
}

initializer_initializer_list::initializer_initializer_list(initializer_list *il) : m_il(il) {
    m_il->set_parent(this);
}

initializer_initializer_list_comma::initializer_initializer_list_comma(initializer_list *il) : m_il(il) {
    m_il->set_parent(this);
}

initializer_list_designation_initializer::initializer_list_designation_initializer(designation *d,initializer *i) : m_d(d), m_i(i) {
    m_d->set_parent(this);
    m_i->set_parent(this);
}

initializer_list_initializer_list_designation_initializer::initializer_list_initializer_list_designation_initializer(initializer_list *il,designation *d,initializer *i) : m_il(il), m_d(d), m_i(i) {
    m_il->set_parent(this);
    m_d->set_parent(this);
    m_i->set_parent(this);
}

abstract_declarator_direct_abstract_declarator::abstract_declarator_direct_abstract_declarator(direct_abstract_declarator *dad) : m_dad(dad) {
    m_dad->set_parent(this);
}

abstract_declarator_pointer_direct_abstract_declarator::abstract_declarator_pointer_direct_abstract_declarator(pointer *p,direct_abstract_declarator *dad) : m_p(p), m_dad(dad) {
    m_p->set_parent(this);
    m_dad->set_parent(this);
}

abstract_declarator_call_conv_specifier_direct_abstract_declarator::abstract_declarator_call_conv_specifier_direct_abstract_declarator(call_conv_specifier *ccs,direct_abstract_declarator *dad) : m_ccs(ccs), m_dad(dad) {
    m_ccs->set_parent(this);
    m_dad->set_parent(this);
}

abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(call_conv_specifier *ccs,pointer *p,direct_abstract_declarator *dad) : m_ccs(ccs), m_p(p), m_dad(dad) {
    m_ccs->set_parent(this);
    m_p->set_parent(this);
    m_dad->set_parent(this);
}

type_name_specifier_qualifier_list_abstract_declarator::type_name_specifier_qualifier_list_abstract_declarator(specifier_qualifier_list *sql, abstract_declarator *ad) : m_sql(sql), m_ad(ad) {
    m_sql->set_parent(this);
    m_ad->set_parent(this);
}

parameter_declaration_declaration_specifiers_abstract_declarator::parameter_declaration_declaration_specifiers_abstract_declarator(declaration_specifiers *ds, abstract_declarator *ad) : m_ds(ds), m_ad(ad) {
    m_ds->set_parent(this);
    m_ad->set_parent(this);
}

parameter_list_parameter_list_parameter_declaration::parameter_list_parameter_list_parameter_declaration(parameter_list *pl,parameter_declaration *pd) : m_pl(pl), m_pd(pd) {
    m_pl->set_parent(this);
    m_pd->set_parent(this);
}

parameter_list_parameter_declaration::parameter_list_parameter_declaration(parameter_declaration *pd) : m_pd(pd) {
    m_pd->set_parent(this);
}

pointer_star_type_qualifier_list::pointer_star_type_qualifier_list(type_qualifier_list *tql) : m_tql(tql) {
    m_tql->set_parent(this);
}

pointer_star_type_qualifier_list_pointer::pointer_star_type_qualifier_list_pointer(type_qualifier_list *tql,pointer *p) : m_tql(tql), m_p(p) {
    m_tql->set_parent(this);
    m_p->set_parent(this);
}

enumerator_list_enumerator_list_enumerator::enumerator_list_enumerator_list_enumerator(enumerator_list *el,enumerator *e) : m_el(el), m_e(e) {
    m_el->set_parent(this);
    m_e->set_parent(this);
}

enumerator_list_enumerator::enumerator_list_enumerator(enumerator *e) : m_e(e) {
    m_e->set_parent(this);
}

enum_specifier_identifier_enumerator_list_comma::enum_specifier_identifier_enumerator_list_comma(const std::string &id,enumerator_list *el) : m_id(id), m_el(el) {
    m_el->set_parent(this);
}

enum_specifier_enumerator_list_comma::enum_specifier_enumerator_list_comma(enumerator_list *el) : m_el(el) {
    m_el->set_parent(this);
}

enum_specifier_identifier_enumerator_list::enum_specifier_identifier_enumerator_list(const std::string &id,enumerator_list *el) : m_id(id), m_el(el) {
    m_el->set_parent(this);
}

enum_specifier_enumerator_list::enum_specifier_enumerator_list(enumerator_list *el) : m_el(el) {
    m_el->set_parent(this);
}

struct_declarator_list_struct_declarator::struct_declarator_list_struct_declarator(struct_declarator *sd) : m_sd(sd) {
    m_sd->set_parent(this);
}

struct_declarator_list_struct_declarator_list_struct_declarator::struct_declarator_list_struct_declarator_list_struct_declarator(struct_declarator_list *sdl,struct_declarator *sd) : m_sdl(sdl), m_sd(sd) {
    m_sdl->set_parent(this);
    m_sd->set_parent(this);
}

specifier_qualifier_list_type_qualifier_specifier_qualifier_list::specifier_qualifier_list_type_qualifier_specifier_qualifier_list(type_qualifier *tq,specifier_qualifier_list *ql) : m_tq(tq), m_ql(ql) {
    m_tq->set_parent(this);
    m_ql->set_parent(this);
}

specifier_qualifier_list_type_qualifier::specifier_qualifier_list_type_qualifier(type_qualifier *tq) : m_tq(tq) {
    m_tq->set_parent(this);
}

anonymous_struct_declaration_specifier_qualifier_list::anonymous_struct_declaration_specifier_qualifier_list(specifier_qualifier_list *sql) : m_sql(sql) {
    m_sql->set_parent(this);
}

struct_declaration_specifier_qualifier_list_struct_declarator_list::struct_declaration_specifier_qualifier_list_struct_declarator_list(specifier_qualifier_list *sql,struct_declarator_list *sdl) : m_sql(sql), m_sdl(sdl) {
    m_sql->set_parent(this);
    m_sdl->set_parent(this);
}

struct_declaration_list_struct_declaration::struct_declaration_list_struct_declaration(struct_declaration *sd) : m_sd(sd) {
    m_sd->set_parent(this);
}

struct_declaration_list_struct_declaration_list_anonymous_struct_declaration::struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(struct_declaration_list *sdl,anonymous_struct_declaration *sd) : m_sdl(sdl), m_sd(sd) {
    m_sdl->set_parent(this);
    m_sd->set_parent(this);
}

struct_declaration_list_anonymous_struct_declaration::struct_declaration_list_anonymous_struct_declaration(anonymous_struct_declaration *sd) : m_sd(sd) {
    m_sd->set_parent(this);
}

struct_declaration_list_struct_declaration_list_struct_declaration::struct_declaration_list_struct_declaration_list_struct_declaration(struct_declaration_list *sdl,struct_declaration *sd) : m_sdl(sdl), m_sd(sd) {
    m_sdl->set_parent(this);
    m_sd->set_parent(this);
}

struct_or_union_specifier_struct_or_union_struct_declaration_list::struct_or_union_specifier_struct_or_union_struct_declaration_list(struct_or_union *sou,struct_declaration_list *sdl) : m_sou(sou), m_sdl(sdl) {
    m_sou->set_parent(this);
    m_sdl->set_parent(this);
}

struct_or_union_specifier_struct_or_union_identifier::struct_or_union_specifier_struct_or_union_identifier(struct_or_union *sou,const std::string &id) : m_sou(sou), m_id(id) {
    add_to_symbol_table();
    m_sou->set_parent(this);
}

struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list::struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(struct_or_union *sou,const std::string &id,struct_declaration_list *sdl,bool add_symbol) : m_sou(sou), m_id(id), m_sdl(sdl) {
    if(add_symbol) {
        add_to_symbol_table();
    }
    m_sou->set_parent(this);
    m_sdl->set_parent(this);
}

type_specifier_struct_or_union_specifier::type_specifier_struct_or_union_specifier(struct_or_union_specifier *sous) : m_sous(sous) {
    m_sous->set_parent(this);
}

type_specifier_enum_specifier::type_specifier_enum_specifier(enum_specifier *es) : m_es(es) {
    m_es->set_parent(this);
}

init_declarator_declarator_initializer::init_declarator_declarator_initializer(declarator *d,initializer *i) :
    init_declarator_declarator(d),
    m_i(i) {
    m_i->set_parent(this);
}

declarator_call_conv_specifier_direct_declarator::declarator_call_conv_specifier_direct_declarator(call_conv_specifier *ccs,direct_declarator *dd,const std::string &s) :
    m_ccs(ccs),
    m_dd(dd),
    m_s(s) {
    m_ccs->set_parent(this);
    m_dd->set_parent(this);
}

declarator_call_conv_specifier_pointer_direct_declarator::declarator_call_conv_specifier_pointer_direct_declarator(call_conv_specifier *ccs,pointer *p,direct_declarator *dd,const std::string &s) :
    m_ccs(ccs),
    m_p(p),
    m_dd(dd),
    m_post_translate(g_translation_started),
    m_s(s) {
    m_ccs->set_parent(this);
    m_p->set_parent(this);
    m_dd->set_parent(this);
}

declarator_pointer_call_conv_specifier_direct_declarator::declarator_pointer_call_conv_specifier_direct_declarator(pointer *p,call_conv_specifier *ccs,direct_declarator *dd,const std::string &s) :
    m_p(p),
    m_ccs(ccs),
    m_dd(dd),
    m_s(s),
    m_post_translate(g_translation_started) {
    m_p->set_parent(this);
    m_ccs->set_parent(this);
    m_dd->set_parent(this);
}

declarator_pointer_direct_declarator::declarator_pointer_direct_declarator(pointer *p,direct_declarator *dd,const std::string &s) :
    m_p(p),
    m_dd(dd),
    m_s(s) {
    m_p->set_parent(this);
    m_dd->set_parent(this);
}

direct_declarator_paren_declarator::direct_declarator_paren_declarator(declarator *d) : m_d(d) {
    m_d->set_parent(this);

    ii_ptr ii = m_d->add_to_symbol_table(IIT_FUNCTION_VAR);
    if(!g_gcc_compatible) {
        ii->set_function_cc(fix_cc_default(m_d->get_call_conv()));
    } else {
//        print();
//        printf("\n");
//        ii->set_function_cc(fix_cc_default(m_d->get_call_conv()));
//        printf("skip this.\n");
    }
    ii->set_func_decl(this);
}

direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::direct_declarator_direct_declarator_type_qualifier_list_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae) : m_dd(dd), m_tql(tql), m_ae(ae) {
    m_dd->set_parent(this);
    m_tql->set_parent(this);
    m_ae->set_parent(this);
}

direct_declarator_direct_declarator_type_qualifier_list::direct_declarator_direct_declarator_type_qualifier_list(direct_declarator *dd,type_qualifier_list *tql) : m_dd(dd), m_tql(tql) {
    m_dd->set_parent(this);
    m_tql->set_parent(this);
}

direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae) : m_dd(dd), m_tql(tql), m_ae(ae) {
    m_dd->set_parent(this);
    m_tql->set_parent(this);
    m_ae->set_parent(this);
}

direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression(direct_declarator *dd,type_qualifier_list *tql,assignment_expression *ae) : m_dd(dd), m_tql(tql), m_ae(ae) {
    m_dd->set_parent(this);
    m_tql->set_parent(this);
    m_ae->set_parent(this);
}

direct_declarator_direct_declarator_type_qualifier_list_star::direct_declarator_direct_declarator_type_qualifier_list_star(direct_declarator *dd,type_qualifier_list *tql) : m_dd(dd), m_tql(tql) {
    m_dd->set_parent(this);
    m_tql->set_parent(this);
}

direct_declarator_direct_declarator_parameter_type_list::direct_declarator_direct_declarator_parameter_type_list(direct_declarator *dd,parameter_type_list *ptl) : m_dd(dd), m_ptl(ptl) {
    m_dd->set_parent(this);
    m_ptl->set_parent(this);
}

direct_declarator_direct_declarator_identifier_list::direct_declarator_direct_declarator_identifier_list(direct_declarator *dd,identifier_list *il) : m_dd(dd), m_il(il) {
    m_dd->set_parent(this);
    m_il->set_parent(this);
}

call_expression_postfix_expression_paren_argument_expression_list::call_expression_postfix_expression_paren_argument_expression_list(postfix_expression *pe,argument_expression_list *ael, identifier_list *il) : call_expression(il), m_pe(pe), m_ael(ael) {
    m_pe->set_parent(this);
    m_ael->set_parent(this);
}

argument_expression_list_assignment_expression::argument_expression_list_assignment_expression(assignment_expression *ae) : m_ae(ae) {
    m_ae->set_parent(this);
}

argument_expression_list_argument_expression_list_assignment_expression::argument_expression_list_argument_expression_list_assignment_expression(argument_expression_list *ael,assignment_expression *ae) : m_ael(ael), m_ae(ae) {
    m_ael->set_parent(this);
    m_ae->set_parent(this);
}

unary_expression_unary_operator_cast_expression::unary_expression_unary_operator_cast_expression(unary_operator *uo,cast_expression *ce) : m_uo(uo), m_ce(ce) {
    m_uo->set_parent(this);
    m_ce->set_parent(this);
}

unary_expression_sizeof_type_name::unary_expression_sizeof_type_name(type_name *tn) : m_tn(tn) {
    m_tn->set_parent(this);
}

cast_expression_type_name_cast_expression::cast_expression_type_name_cast_expression(type_name *tn,cast_expression *ce) : m_tn(tn), m_ce(ce) {
    m_tn->set_parent(this);
    m_ce->set_parent(this);
}

conditional_expression_logical_or_expression_expression_conditional_expression::conditional_expression_logical_or_expression_expression_conditional_expression(logical_or_expression *loe,expression *e,conditional_expression *ce) : m_loe(loe), m_e(e), m_ce(ce) {
    m_loe->set_parent(this);
    m_e->set_parent(this);
    m_ce->set_parent(this);
}

assignment_expression_unary_expression_assignment_operator_assignment_expression::assignment_expression_unary_expression_assignment_operator_assignment_expression(unary_expression *ue,assignment_operator *ao,assignment_expression *ae) : m_ue(ue), m_ao(ao), m_ae(ae) {
    m_ue->set_parent(this);
    m_ao->set_parent(this);
    m_ae->set_parent(this);
}

declaration_declaration_specifiers::declaration_declaration_specifiers(declaration_specifiers *ds) : m_ds(ds) {
    m_ds->set_parent(this);
}

declaration_declaration_specifiers_init_declarator_list::declaration_declaration_specifiers_init_declarator_list(
    declaration_specifiers *ds,
    init_declarator_list   *idl,
    const std::string &before,
#ifndef BLAH
    attr_or_uuasmuu *au
#else
    const std::string &after
#endif
) :
    m_ds(ds),
    m_idl(idl),
    m_before_s(before),
#ifndef BLAH
    m_au(au)
#else
    m_after_s(after)
#endif
{
    m_ds->set_parent(this);
    m_idl->set_parent(this);
}

declaration_specifiers_type_specifier::declaration_specifiers_type_specifier(type_specifier *ts) : m_ts(ts) {
    m_ts->set_parent(this);
}

declaration_specifiers_type_specifier_declaration_specifiers::declaration_specifiers_type_specifier_declaration_specifiers(type_specifier *ts,declaration_specifiers *ds) : m_ts(ts), m_ds(ds) {
    m_ts->set_parent(this);
    m_ds->set_parent(this);
}

declaration_specifiers_mrv::declaration_specifiers_mrv(multiple_ret_value *ts) : m_ts(ts) {
    m_ts->set_parent(this);
}

declaration_specifiers_mrv_declaration_specifiers::declaration_specifiers_mrv_declaration_specifiers(multiple_ret_value *ts,declaration_specifiers *ds) : m_ts(ts), m_ds(ds) {
    m_ts->set_parent(this);
    m_ds->set_parent(this);
}

declaration_specifiers_type_qualifier::declaration_specifiers_type_qualifier(type_qualifier *tq) : m_tq(tq) {
    m_tq->set_parent(this);
}

declaration_specifiers_type_qualifier_declaration_specifiers::declaration_specifiers_type_qualifier_declaration_specifiers(type_qualifier *tq,declaration_specifiers *ds) : m_tq(tq), m_ds(ds) {
    m_tq->set_parent(this);
    m_ds->set_parent(this);
}

declaration_specifiers_function_specifier::declaration_specifiers_function_specifier(function_specifier *fs) : m_fs(fs) {
    m_fs->set_parent(this);
}

declaration_specifiers_function_specifier_declaration_specifiers::declaration_specifiers_function_specifier_declaration_specifiers(function_specifier *fs,declaration_specifiers *ds) : m_fs(fs), m_ds(ds) {
    m_fs->set_parent(this);
    m_ds->set_parent(this);
}

declaration_specifiers_gcc_attribute_declaration_specifiers::declaration_specifiers_gcc_attribute_declaration_specifiers(const char *s,declaration_specifiers *ds) : m_s(s), m_ds(ds) {
    m_ds->set_parent(this);
}

uudeclspec_list_uudeclspec::uudeclspec_list_uudeclspec(declspec_specifier *ds) : m_ds(ds) {
    m_ds->set_parent(this);
}

//==========================================================================

// GET_CALL_CONV Implementations

PILLAR2C_CALLCONV declarator_pointer_call_conv_specifier_direct_declarator::get_call_conv(void) {
    return m_ccs->get_call_conv();
}

PILLAR2C_CALLCONV declarator_call_conv_specifier_pointer_direct_declarator::get_call_conv(void) {
    return m_ccs->get_call_conv();
}

PILLAR2C_CALLCONV declarator_call_conv_specifier_direct_declarator::get_call_conv(void) {
    return m_ccs->get_call_conv();
}

//==========================================================================

// TRANSLATE_PILLAR Implementations

TranslateResult conditional_expression_logical_or_expression_expression_conditional_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_loe,tr1);
    TRANSLATE(m_e,tr2);
    TRANSLATE(m_ce,tr3);

    if(g_expression_type) {
        primary_expression_constant_int peci("");
        return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
    } else {
        return TranslateResult();
    }
}

TranslateResult unary_expression_unary_operator_cast_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr, new_tr;
    TRANSLATE(m_ce,tr);

    if(dynamic_cast<unary_operator_star*>(m_uo)) {
        if(g_expression_type) {
            if(!tr.m_et->m_ad) {
                aeprintf("type problem.\n");
            }

            if(tr.m_once_ref && g_collect_read_stats) {
#ifndef USE_IS_LVALUE
                LRB_VALUE lrb_res = get_parent()->get_lrb_value(this,NULL);
                bool res_lvalue;
                if(lrb_res == LRB_LVALUE || lrb_res == LRB_LRVALUE) {
                    res_lvalue = true;
                } else {
                    res_lvalue = false;
                }
#else
                bool res_lvalue = get_parent()->is_lvalue(this,NULL);
#endif
                if(!res_lvalue) {
                    type_name *the_cast;
                    the_cast = new type_name_specifier_qualifier_list_abstract_declarator(tr.m_et->m_sql->clone(),tr.m_et->m_ad->clone());

                    cast_expression *new_ce =
                      new cast_expression_type_name_cast_expression(
                        the_cast,
                        expr_gen(cast_expression,postfix_expression,
                          new postfix_expression_read_stats(
                            new call_expression_postfix_expression_paren_argument_expression_list(
                              new postfix_expression_primary_expression(
                                new primary_expression_identifier(g_scope_stack.find_or_add("gc_heap_object_read_stats"))),
                              new argument_expression_list_assignment_expression(
                                expr_gen(assignment_expression,cast_expression,m_ce))))));

                    replace(m_ce,new_ce);
                }
            }

            expression_type *ret = new expression_type;

            ret->m_sql = tr.m_et->m_sql->clone();
            ret->m_ad  = tr.m_et->m_ad->remove_pointer_star();

            new_tr = TranslateResult(auto_ptr<expression_type>(ret));
        } else {
            new_tr = TranslateResult();
        }
    } else if(dynamic_cast<unary_operator_and*>(m_uo)) {
        if(g_expression_type) {
            expression_type *ret = new expression_type;

            ret->m_sql = tr.m_et->m_sql->clone();

            if(tr.m_et->m_ad) {
                ret->m_ad = tr.m_et->m_ad->add_pointer_star();
            } else {
                ret->m_ad = new abstract_declarator_pointer(new pointer_star());
            }

            new_tr = TranslateResult(auto_ptr<expression_type>(ret));
        } else {
            new_tr = TranslateResult();
        }
    } else {
        new_tr = tr;
    }
    return new_tr;
}

TranslateResult statement_expression_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    basic_block *cur_bb = fd->get_cur_basic_block();

    if(cur_bb) {
        TranslateResult tr;
        TRANSLATE(m_s,tr);

        generate_filters(fd);
        return tr;
    } else {
        m_inactive = true;
        return TranslateResult();
    }
}

PILLAR2C_CALLCONV direct_declarator_paren_declarator::get_call_conv(void) {
    return m_d->get_call_conv();
}

call_expression_metadata * call_expression_postfix_expression_paren_argument_expression_list::get_call_metadata(void) {
    call_expression_metadata *cem = new call_expression_metadata;
    cem->m_pe_function = m_pe->clone();
    cem->m_pe_function->get_func_metadata(*cem);
    m_ael->vectorize(cem->m_args);
    return cem;
}

unsigned call_expression_postfix_expression_paren_argument_expression_list::get_num_args(void) const {
    call_expression_metadata cem;
    m_ael->vectorize(cem.m_args);
    return cem.m_args.size();
}

check_vector<assignment_expression *> call_expression_postfix_expression_paren_argument_expression_list::claim_args(void) {
    check_vector<assignment_expression *> temp;
    m_ael->claim_vectorize(temp);
    return temp;
}

TranslateResult primary_expression_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_e,tr);

    if(g_prettify_code) {
        primary_expression *simple_pe = NULL;
        simple_pe = m_e->is_simple_pe();
        if(simple_pe) {
            simple_pe->get_parent()->replace(simple_pe,NULL);
            m_parent->replace(this,simple_pe);
            delete this;
        }
    }

    return tr;
}

assignment_expression * create_expression_for_arg(expression_type *et,
                                                  assignment_expression *unowned_ae,
                                                  unsigned arg_num,
                                                  call_expression *ce,
                                                  const char *field_base,
                                                  const char *struct_base,
                                                  bool claimed,
                                                  bool use_ptr_op = false,
                                                  bool use_cpf = true) {
    std::stringstream field_name;
    field_name << field_base << arg_num;

    ii_ptr prt_args_symbol = NULL;
    std::stringstream struct_name;
    struct_name << struct_base << ce->get_unique();
    prt_args_symbol = g_scope_stack.find_or_add(struct_name.str(),IIT_VAR);

#ifdef __x86_64__
    bool is_type_float = et->is_float();
//    et->m_sql->print();
//    printf("\n");
#endif  // __x86_64__

    postfix_expression *left = NULL;
    if(use_ptr_op) {
       left = new postfix_expression_postfix_expression_ptr_op_identifier(
               new postfix_expression_primary_expression(
                new primary_expression_identifier(prt_args_symbol)),
               field_name.str());
#ifdef __x86_64__
        if(is_type_float) {
            type_name *the_cast;
            the_cast = new type_name_specifier_qualifier_list_abstract_declarator(
                            new specifier_qualifier_list_type_specifier(new type_specifier_FLOAT()),
                            new abstract_declarator_pointer(new pointer_star()));

            cast_expression *new_ce =
                new cast_expression_unary_expression(
                new unary_expression_unary_operator_cast_expression(
                    new unary_operator_star(),
                    new cast_expression_type_name_cast_expression(
                    the_cast,
                    new cast_expression_unary_expression(
                        new unary_expression_unary_operator_cast_expression(
                        new unary_operator_and(),
                        expr_gen(cast_expression,postfix_expression,left))))));

            left = new postfix_expression_primary_expression(
                        new primary_expression_expression(
                        new expression_assignment_expression(
                            expr_gen(assignment_expression,cast_expression,new_ce))));
        }
#endif  // __x86_64__
    } else {
        if(g_prt_args_in_pseudo && use_cpf) {
            left = new postfix_expression_postfix_expression_dot_identifier(
                     gen_pseudo_pe(struct_name.str(),ce),
                     field_name.str());
#ifdef __x86_64__
            if(is_type_float) {
                    type_name *the_cast;
                    the_cast = new type_name_specifier_qualifier_list_abstract_declarator(
                                 new specifier_qualifier_list_type_specifier(new type_specifier_FLOAT()),
                                 new abstract_declarator_pointer(new pointer_star()));

                    cast_expression *new_ce =
                      new cast_expression_unary_expression(
                        new unary_expression_unary_operator_cast_expression(
                          new unary_operator_star(),
                          new cast_expression_type_name_cast_expression(
                            the_cast,
                            new cast_expression_unary_expression(
                              new unary_expression_unary_operator_cast_expression(
                                new unary_operator_and(),
                                expr_gen(cast_expression,postfix_expression,left))))));

                    left = new postfix_expression_primary_expression(
                             new primary_expression_expression(
                               new expression_assignment_expression(
                                 expr_gen(assignment_expression,cast_expression,new_ce))));
            }
#endif  // __x86_64__
        } else {
            left = new postfix_expression_postfix_expression_dot_identifier(
                    new postfix_expression_primary_expression(
                     new primary_expression_identifier(prt_args_symbol)),
                    field_name.str());
#ifdef __x86_64__
            if(is_type_float) {
                aeprintf("Float type not handled in create_expression_for_arg non-prt-args-in-pseudo mode.\n");
            }
#endif  // __x86_64__
        }
    }

    return new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(left),
            new assignment_operator_equal(),
            new assignment_expression_conditional_expression(
             new conditional_expression_logical_or_expression(
              new logical_or_expression_logical_and_expression(
               new logical_and_expression_inclusive_or_expression(
                new inclusive_or_expression_exclusive_or_expression(
                 new exclusive_or_expression_and_expression(
                  new and_expression_equality_expression(
                   new equality_expression_relational_expression(
                    new relational_expression_shift_expression(
                     new shift_expression_additive_expression(
                      new additive_expression_multiplicative_expression(
                       new multiplicative_expression_cast_expression(
                        new cast_expression_unary_expression(
                         new unary_expression_postfix_expression(
                          new postfix_expression_primary_expression(
                           new primary_expression_expression(
                            new expression_assignment_expression(claimed ? unowned_ae : unowned_ae->clone()))))))))))))))))));
}

argument_expression_list * gen_extra_args(bool for_tailcall = false) {
    argument_expression_list *latest = NULL;

    if(g_use_th_param) {
        latest =
          new argument_expression_list_assignment_expression(
           expr_gen(assignment_expression,primary_expression,
            new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle"))));
    }

    if(for_tailcall) {
        latest =
          argument_expression_list_argument_expression_list_assignment_expression::new_recursive(
           latest,
           expr_gen(assignment_expression,primary_expression,
            new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_prev_pseudo_stack"))));
    } else {
        latest =
          argument_expression_list_argument_expression_list_assignment_expression::new_recursive(
           latest,
           expr_gen(assignment_expression,cast_expression,
               new cast_expression_type_name_cast_expression(
                new type_name_specifier_qualifier_list_abstract_declarator(
                 new specifier_qualifier_list_type_specifier(
                  new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("pillar2c_pseudo_stack_entry"))),
                 new abstract_declarator_pointer(
                  new pointer_star())),
                new cast_expression_unary_expression(
                 new unary_expression_unary_operator_cast_expression(
                  new unary_operator_and(),
                  expr_gen(cast_expression,primary_expression,
                     new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME))))))));
    }

    return latest;
}

argument_expression_list * gen_extra_args_for_u2m(void) {
    argument_expression_list *latest =
      new argument_expression_list_assignment_expression(
       expr_gen(assignment_expression,call_expression,
        new call_expression_postfix_expression_empty_paren(
          new postfix_expression_primary_expression(
            new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle"))))));

#ifdef USE_GET_LAST_PSEUDO
    latest =
      new argument_expression_list_argument_expression_list_assignment_expression(
       latest,
       expr_gen(assignment_expression,call_expression,
         new call_expression_postfix_expression_empty_paren(
           new postfix_expression_primary_expression(
             new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_get_last_pseudo"))))));
#else
    latest =
      new argument_expression_list_argument_expression_list_assignment_expression(
       latest,
       expr_gen(assignment_expression,cast_expression,
         new cast_expression_type_name_cast_expression(
           new type_name_specifier_qualifier_list_abstract_declarator(
             new specifier_qualifier_list_type_specifier(
               new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("pillar2c_pseudo_stack_entry"))
             ),
             new abstract_declarator_pointer(
               new pointer_star()
             )
           ),
         expr_gen(cast_expression,postfix_expression,
           new postfix_expression_primary_expression(
             new primary_expression_constant("1"))))));
#endif

    return latest;
}


#define DC_DECL(type,var,prev) type *var = dynamic_cast<type *>(prev->get_parent()); \
    if(!var) { \
        aeprintf("DC_DECL cast to %s from %s failed. Real type was %s.\n",typeid(type).name(),typeid(prev).name(),typeid(prev->get_parent()).name()); \
    }

#define CHECK_DECL(type,var,prev) type *var = prev ? dynamic_cast<type *>(prev->get_parent()) : NULL;

std::list<external_declaration *> gen_specific_callsite_prt_args(unsigned location,
                                                                 const std::string &context,
                                                                 const std::string &type_name,
                                                                 call_expression_metadata &cem,
                                                                 bool gen_for_tailcall=false,
                                                                 bool gen_for_topo_tailcall=false) {
//external_declaration * gen_specific_callsite_prt_args(std::string &type_name, call_expression_metadata &cem, bool gen_for_tailcall=false) {
    if(cem.m_func_metadata.m_params.size() == 0) {
        aeprintf("cem.m_func_metadata.m_params.size == 0 in gen_specific_callsite_prt_args\n");
    }

    if(cem.m_func_metadata.m_params.size() != cem.m_args.size()) {
        if(cem.m_func_metadata.m_params.size() > cem.m_args.size()) {
            aeprintf("Function argument mismatch in function: %s\n",context.c_str());
            //printf("\nParams = %d, args = %d\n",cem.m_func_metadata.m_params.size(),cem.m_args.size());
            //aeprintf("cem.m_params.size > cem.m_args.size in gen_specific_callsite_prt_args\n");
        } else {
            if(gen_for_tailcall) {
                aeprintf("Tailcall does not work with varargs.\n");
            }
            if(!cem.m_func_metadata.m_ellipsis) {
                aeprintf("Function argument mismatch in function: %s\n",context.c_str());
                //aeprintf("cem.m_params.size < cem.m_args.size in gen_specific_callsite_prt_args with ellipsis\n");
            }
        }
    }

    if(gen_for_topo_tailcall) {
        if(!gen_for_tailcall) {
            aeprintf("gen_specific_callsite_prt_args has topo tailcall but not regular tailcall.\n");
        }
    }

    struct_declaration_list *sdl = NULL;
    unsigned arg_num = 0;

    if(gen_for_tailcall) {
        if(!gen_for_topo_tailcall) {
#ifdef __x86_64__
        assert(arg_num < cem.m_func_metadata.m_params.size());
        sdl = new struct_declaration_list_struct_declaration(
               cem.m_func_metadata.m_params[arg_num]->gen_struct_declaration(arg_num,false));
        ++arg_num;
#if 0
        // Add real_return spot in tailcall struct.
        sdl = struct_declaration_list::new_recursive(sdl,
               new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                 new type_specifier_LONG()),
                new struct_declarator_list_struct_declarator(
                 new struct_declarator_declarator(
                  new declarator_direct_declarator(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("argQwords")))))));
#endif // 0
#else  // __x86_64__
        // Add real_return spot in tailcall struct.
        sdl = struct_declaration_list::new_recursive(sdl,
               new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                 new type_specifier_UNSIGNED()),
                new struct_declarator_list_struct_declarator(
                 new struct_declarator_declarator(
                  new declarator_direct_declarator(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("argDwords")))))));
#endif // __x86_64__
        }
    } else {
        assert(arg_num < cem.m_func_metadata.m_params.size());
        sdl = struct_declaration_list_struct_declaration::new_recursive(sdl,
               cem.m_func_metadata.m_params[arg_num]->gen_struct_declaration(arg_num,false));
        ++arg_num;
    }

    if(!gen_for_topo_tailcall) {
        for(; arg_num < cem.m_func_metadata.m_params.size(); ++arg_num) {
           sdl =
             struct_declaration_list::new_recursive(
               sdl,
               cem.m_func_metadata.m_params[arg_num]->gen_struct_declaration(arg_num,false));
        }

        // handle the ellipsis case, derive type from the arg passed
        for(; arg_num < cem.m_args.size(); ++arg_num) {
           sdl =
             struct_declaration_list::new_recursive(
               sdl,
               cem.m_args[arg_num]->gen_struct_declaration(arg_num,true,context));
        }
    }

    if(gen_for_tailcall) {
        // Add real_return spot in tailcall struct.
        sdl = struct_declaration_list::new_recursive(
               sdl,
               new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                 new type_specifier_VOID()),
                new struct_declarator_list_struct_declarator(
                 new struct_declarator_declarator(
                  new declarator_pointer_direct_declarator(
                   new pointer_star(),
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("real_return")))))));
        // Add func to be invoked in tailcall struct.
        sdl = struct_declaration_list::new_recursive(
               sdl,
               new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                 new type_specifier_VOID()),
                new struct_declarator_list_struct_declarator(
                 new struct_declarator_declarator(
                  new declarator_pointer_direct_declarator(
                   new pointer_star(),
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("func")))))));
    }

#ifdef __x86_64__
    external_declaration *pack = new external_declaration_emit_text("#pragma pack(push,8)\n");
#else  // __x86_64__
    external_declaration *pack = new external_declaration_emit_text("#pragma pack(push,4)\n");
#endif // __x86_64__

    external_declaration *this_decl = NULL;
    if(g_gcc_compatible) {
        this_decl =
          new external_declaration_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_storage_class_specifier_declaration_specifiers(
                new storage_class_specifier_TYPEDEF(),
                new declaration_specifiers_type_specifier(
                  new type_specifier_struct_or_union_specifier(
                    new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                      new struct_or_union_STRUCT(),
                      sdl)))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(type_name))))),"",
#ifndef BLAH
#ifdef __x86_64__
                 new attr_or_uuasmuu_attribute(" __attribute__((aligned(8)))")
#else  // __x86_64__
                 new attr_or_uuasmuu_attribute(" __attribute__((aligned(4)))")
#endif // __x86_64__
#else
#ifdef __x86_64__
                "__attribute__((aligned(8)))"
#else  // __x86_64__
                "__attribute__((aligned(4)))"
#endif // __x86_64__
#endif
            )
          );
    } else {
        this_decl =
          new external_declaration_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_storage_class_specifier_declaration_specifiers(
                new storage_class_specifier_TYPEDEF(),
                new declaration_specifiers_function_specifier_declaration_specifiers(
                  new function_specifier_uudeclspec_specifier(
                    new declspec_specifier_ALIGN4()),
                  new declaration_specifiers_type_specifier(
                    new type_specifier_struct_or_union_specifier(
                      new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                        new struct_or_union_STRUCT(),
                        sdl))))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(type_name)))))));
    }

    external_declaration *unpack = new external_declaration_emit_text("#pragma pack(pop)\n");

    std::list<external_declaration *> ret_list;
    ret_list.push_back(pack);
    ret_list.push_back(this_decl);
    ret_list.push_back(unpack);

    return ret_list;
}

std::list<external_declaration *> gen_specific_callsite_prt_args(const std::string &type_name, function_metadata &cem) {
    if(cem.m_params.size() == 0) {
        aeprintf("cem.m_params.size == 0 in gen_specific_callsite_prt_args\n");
    }

    struct_declaration_list *sdl = NULL;
    unsigned arg_num = 0;

    assert(arg_num < cem.m_params.size());
    sdl = new struct_declaration_list_struct_declaration(
           cem.m_params[arg_num]->gen_struct_declaration(arg_num));
    ++arg_num;

    for(; arg_num < cem.m_params.size(); ++arg_num) {
       sdl =
         new struct_declaration_list_struct_declaration_list_struct_declaration(
           sdl,
           cem.m_params[arg_num]->gen_struct_declaration(arg_num));
    }

    external_declaration *pack = new external_declaration_emit_text("#pragma pack(push,4)\n");

    external_declaration *this_decl = NULL;
    this_decl =
      new external_declaration_declaration(
        new declaration_declaration_specifiers_init_declarator_list(
          new declaration_specifiers_storage_class_specifier_declaration_specifiers(
            new storage_class_specifier_TYPEDEF(),
            new declaration_specifiers_function_specifier_declaration_specifiers(
              new function_specifier_uudeclspec_specifier(
                new declspec_specifier_ALIGN4()),
              new declaration_specifiers_type_specifier(
                new type_specifier_struct_or_union_specifier(
                  new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                    new struct_or_union_STRUCT(),
                    sdl))))),
          new init_declarator_list_init_declarator(
            new init_declarator_declarator(
              new declarator_direct_declarator(
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(type_name)))))));

    external_declaration *unpack = new external_declaration_emit_text("#pragma pack(pop)\n");

    std::list<external_declaration *> ret_list;
    ret_list.push_back(pack);
    ret_list.push_back(this_decl);
    ret_list.push_back(unpack);

    return ret_list;
}

check_vector<expression_type> g_p2cm2u_stub_types;
bool g_minimize_p2cm2u_stubs = true;
check_vector<expression_type> g_p2cu2m_stub_types;
bool g_minimize_p2cu2m_stubs = true;

declaration_specifiers * gen_declaration_specifiers(const std::list<type_specifier *> &the_types) {
    declaration_specifiers *ret = NULL;

    std::list<type_specifier *>::const_reverse_iterator iter;
    for(iter  = the_types.rbegin();
        iter != the_types.rend();
        ++iter) {
        if(ret) {
            ret = new declaration_specifiers_type_specifier_declaration_specifiers((*iter)->clone(),ret);
        } else {
            ret = new declaration_specifiers_type_specifier((*iter)->clone());
        }
    }
    return ret;
}

type_specifier * forget_unsigned(const std::list<type_specifier *> &the_types) {
    if(the_types.size() == 1) {
        return *(the_types.begin());
    }

    if(the_types.size() != 2) {
        aeprintf("Unrecoverable error in forget_unsigned.\n");
    }

    std::list<type_specifier *>::const_iterator iter = the_types.begin();
    if(!dynamic_cast<type_specifier_UNSIGNED*>(*iter)) {
        aeprintf("In forget_unsigned, there are two type_specifiers but the first isn't unsigned.\n");
    }
    ++iter;
    return *iter;
}

std::string gen_and_insert_m2u_with_ret(call_expression *ce,
                                 function_definition *fd,
                                 const expression_type &return_type) {
    std::stringstream call_name;

    if(g_minimize_p2cm2u_stubs) {
        unsigned i;
        for(i=0;i<g_p2cm2u_stub_types.size();++i) {
            if(g_p2cm2u_stub_types[i] == return_type) {
                call_name << "pillar2cInvokeUnmanagedFunc_" << i;
                return call_name.str();
            }
        }
        call_name << "pillar2cInvokeUnmanagedFunc_" << g_p2cm2u_stub_types.size();
        g_p2cm2u_stub_types.push_back(return_type);
        ii_ptr new_p2cm2u_stub_ii = g_scope_stack.find_or_add_top_level(call_name.str());
        new_p2cm2u_stub_ii->add(IIT_FUNCTION_VAR);
        new_p2cm2u_stub_ii->set_function_cc(ST_PDECL);

        declarator *new_d_ii = NULL;
        if(return_type.m_ad) {
            new_d_ii = return_type.m_ad->gen_declarator(call_name.str());
        } else {
            new_d_ii = new declarator_direct_declarator(new direct_declarator_IDENTIFIER(new_p2cm2u_stub_ii));
        }

        declaration *d =
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                return_type.m_sql->get_type_specifier()->clone()),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(new_d_ii)));

        new_p2cm2u_stub_ii->set_func_decl(new_d_ii->get_direct_declarator());
        // FIX FIX FIX ... save new declaration in g_p2cm2u_stub_types and free at end...avoid memory leak
    } else {
        call_name << "pillar2cInvokeUnmanagedFunc_" << ce;
    }

    type_specifier *cloned  = (type_specifier*)return_type.m_sql->get_type_specifier()->clone();
    type_specifier *cloned2 = (type_specifier*)return_type.m_sql->get_type_specifier()->clone();

    ii_ptr new_p2cm2u_stub_ii = g_scope_stack.find_or_add_top_level(call_name.str());
    ScopeStackTarget sst(new_p2cm2u_stub_ii);
    direct_declarator *sub_dd =
        new direct_declarator_paren_declarator(
          new declarator_call_conv_specifier_pointer_direct_declarator(
            new call_conv_specifier_PRT_PDECL(),
            new pointer_star(),
            new direct_declarator_IDENTIFIER(new_p2cm2u_stub_ii)
          )
        );
    new_p2cm2u_stub_ii->set_function_cc(ST_PDECL);

    parameter_type_list *rem_ptl = NULL;

    parameter_list *th_param_list = NULL;

    if(g_use_th_param) {
        th_param_list =
               new parameter_list_parameter_declaration(
                new parameter_declaration_declaration_specifiers_declarator(
                 new declaration_specifiers_type_specifier( new type_specifier_VOID()),
                 new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("task_handle")))));
    }

    direct_declarator *new_fd_dd =
        new direct_declarator_direct_declarator_parameter_type_list(
         sub_dd,
         rem_ptl = new parameter_type_list_parameter_list(
          // 6th param decl
          new parameter_list_parameter_list_parameter_declaration(
           // 5th param decl
           new parameter_list_parameter_list_parameter_declaration(
            // 4th param decl
            new parameter_list_parameter_list_parameter_declaration(
             // 3rd param decl
             new parameter_list_parameter_list_parameter_declaration(
              // 2nd param decl
              parameter_list::new_recursive(
               th_param_list,
               new parameter_declaration_declaration_specifiers_declarator(
                new declaration_specifiers_type_specifier( new type_specifier_VOID()),
                new declarator_pointer_direct_declarator(
                 new pointer_star(),
                 new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prev_frame"))))),
              new parameter_declaration_declaration_specifiers_declarator(
               new declaration_specifiers_type_specifier( new type_specifier_VOID()),
               new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("func"))))),
             new parameter_declaration_declaration_specifiers_declarator(
              new declaration_specifiers_type_specifier( new type_specifier_VOID()),
              new declarator_pointer_direct_declarator(
               new pointer_star(),
               new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("start"))))),
            new parameter_declaration_declaration_specifiers_declarator(
             new declaration_specifiers_type_specifier(
              new type_specifier_UNSIGNED()),
             new declarator_direct_declarator(
              new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("size"))))),
           new parameter_declaration_declaration_specifiers_declarator(
            new declaration_specifiers_type_specifier(
             new type_specifier_UNSIGNED()),
            new declarator_direct_declarator(
             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("cc")))))));

    pointer *ret_type_pointer = NULL;
    if(return_type.m_ad) {
        ret_type_pointer = return_type.m_ad->get_pointer();
    }

    declarator *new_fd_decl = NULL;
    type_name  *new_tp_name = NULL;
    if(ret_type_pointer) {
        new_fd_decl =
          new declarator_pointer_direct_declarator(
           (pointer*)ret_type_pointer->clone(),
           new_fd_dd);
        new_tp_name = new type_name_specifier_qualifier_list_abstract_declarator(
          new specifier_qualifier_list_type_specifier(cloned2),
            new abstract_declarator_pointer_direct_abstract_declarator(
              (pointer*)ret_type_pointer->clone(),
              new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                new direct_abstract_declarator_abstract_declarator(
                  new abstract_declarator_call_conv_specifier_pointer(
                    new call_conv_specifier_PRT_PDECL(),
                    new pointer_star())),
                  (parameter_type_list*)rem_ptl->clone())));
    } else {
        new_fd_decl = new declarator_direct_declarator(new_fd_dd);
        new_tp_name = new type_name_specifier_qualifier_list_abstract_declarator(
              new specifier_qualifier_list_type_specifier(cloned2),
              new abstract_declarator_direct_abstract_declarator(
                new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                  new direct_abstract_declarator_abstract_declarator(
                    new abstract_declarator_call_conv_specifier_pointer(
                      new call_conv_specifier_PRT_PDECL(),
                      new pointer_star())),
                  (parameter_type_list*)rem_ptl->clone())));
    }

    external_declaration *new_fd =
        new external_declaration_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_storage_class_specifier_declaration_specifiers(
              new storage_class_specifier_STATIC(),
              new declaration_specifiers_type_specifier(cloned)),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator_initializer(
                new_fd_decl,
                new initializer_assignment_expression(
                  expr_gen(assignment_expression,cast_expression,
                    new cast_expression_type_name_cast_expression(
                      new_tp_name,
                      new cast_expression_unary_expression(
                        new unary_expression_unary_operator_cast_expression(
                          new unary_operator_and(),
                          expr_gen(cast_expression,primary_expression,
                            new primary_expression_identifier(g_scope_stack.find_or_add("pillar2cInvokeUnmanagedFunc"))))))))))));
//    g_m2u_structs.push_back(new_fd);
    fd->insert_before_top_level(new_fd);


    return call_name.str();
}

std::string gen_and_insert_u2m_with_ret(call_expression *ce,
                                 function_definition *fd,
                                 const expression_type &return_type) {
    std::stringstream call_name;

    if(g_minimize_p2cu2m_stubs) {
        unsigned i;
        for(i=0;i<g_p2cu2m_stub_types.size();++i) {
            if(g_p2cu2m_stub_types[i] == return_type) {
                call_name << "pillar2cInvokeManagedFunc_" << i;
                return call_name.str();
            }
        }
        call_name << "pillar2cInvokeManagedFunc_" << g_p2cu2m_stub_types.size();
        g_p2cu2m_stub_types.push_back(return_type);
        ii_ptr new_p2cu2m_stub_ii = g_scope_stack.find_or_add_top_level(call_name.str());
        new_p2cu2m_stub_ii->add(IIT_FUNCTION_VAR);
        new_p2cu2m_stub_ii->set_function_cc(ST_STDCALL);

        declarator *new_d_ii = NULL;
        if(return_type.m_ad) {
            new_d_ii = return_type.m_ad->gen_declarator(call_name.str());
        } else {
            new_d_ii = new declarator_direct_declarator(new direct_declarator_IDENTIFIER(new_p2cu2m_stub_ii));
        }

        declaration *d =
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                return_type.m_sql->get_type_specifier()->clone()),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(new_d_ii)));

        new_p2cu2m_stub_ii->set_func_decl(new_d_ii->get_direct_declarator());
        // FIX FIX FIX ... save new declaration in g_p2cu2m_stub_types and free at end...avoid memory leak
    } else {
        call_name << "pillar2cInvokeManagedFunc_" << ce;
    }

    type_specifier *cloned  = (type_specifier*)return_type.m_sql->get_type_specifier()->clone();
    type_specifier *cloned2 = (type_specifier*)return_type.m_sql->get_type_specifier()->clone();

    ii_ptr new_p2cu2m_stub_ii = g_scope_stack.find_or_add_top_level(call_name.str());
    ScopeStackTarget sst(new_p2cu2m_stub_ii);
    direct_declarator *sub_dd =
        new direct_declarator_paren_declarator(
          new declarator_call_conv_specifier_pointer_direct_declarator(
            new call_conv_specifier_STDCALL(),
            new pointer_star(),
            new direct_declarator_IDENTIFIER(new_p2cu2m_stub_ii)
          )
        );
    new_p2cu2m_stub_ii->set_function_cc(ST_STDCALL);

    parameter_type_list *rem_ptl = NULL;

    direct_declarator *new_fd_dd =
        new direct_declarator_direct_declarator_parameter_type_list(
         sub_dd,
         rem_ptl = new parameter_type_list_parameter_list(
             // 3rd param decl
             new parameter_list_parameter_list_parameter_declaration(
              // 2nd param decl
              new parameter_list_parameter_list_parameter_declaration(
               new parameter_list_parameter_declaration(
                 new parameter_declaration_declaration_specifiers_declarator(
                   new declaration_specifiers_type_specifier( new type_specifier_VOID()),
                   new declarator_pointer_direct_declarator(
                     new pointer_star(),
                     new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("func"))))),
               new parameter_declaration_declaration_specifiers_declarator(
                 new declaration_specifiers_type_specifier( new type_specifier_VOID()),
                 new declarator_pointer_direct_declarator(
                   new pointer_star(),
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("start"))))),
             new parameter_declaration_declaration_specifiers_declarator(
               new declaration_specifiers_type_specifier(
                 new type_specifier_UNSIGNED()),
                 new declarator_direct_declarator(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("size")))))));

    pointer *ret_type_pointer = NULL;
    if(return_type.m_ad) {
        ret_type_pointer = return_type.m_ad->get_pointer();
    }

    declarator *new_fd_decl = NULL;
    type_name  *new_tp_name = NULL;
    if(ret_type_pointer) {
        new_fd_decl =
          new declarator_pointer_direct_declarator(
           (pointer*)ret_type_pointer->clone(),
           new_fd_dd);
        new_tp_name = new type_name_specifier_qualifier_list_abstract_declarator(
              new specifier_qualifier_list_type_specifier(cloned2),
              new abstract_declarator_pointer_direct_abstract_declarator(
                (pointer*)ret_type_pointer->clone(),
                new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                  new direct_abstract_declarator_abstract_declarator(
                    new abstract_declarator_call_conv_specifier_pointer(
                      new call_conv_specifier_STDCALL(),
                      new pointer_star())),
                  (parameter_type_list*)rem_ptl->clone())));
    } else {
        new_fd_decl = new declarator_direct_declarator(new_fd_dd);
        new_tp_name = new type_name_specifier_qualifier_list_abstract_declarator(
              new specifier_qualifier_list_type_specifier(cloned2),
              new abstract_declarator_direct_abstract_declarator(
                new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                  new direct_abstract_declarator_abstract_declarator(
                    new abstract_declarator_call_conv_specifier_pointer(
                      new call_conv_specifier_STDCALL(),
                      new pointer_star())),
                  (parameter_type_list*)rem_ptl->clone())));
    }

    external_declaration *new_fd =
        new external_declaration_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_storage_class_specifier_declaration_specifiers(
              new storage_class_specifier_STATIC(),
              new declaration_specifiers_type_specifier(cloned)),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator_initializer(
                new_fd_decl,
                new initializer_assignment_expression(
                  expr_gen(assignment_expression,cast_expression,
                    new cast_expression_type_name_cast_expression(
                      new_tp_name,
                      new cast_expression_unary_expression(
                        new unary_expression_unary_operator_cast_expression(
                          new unary_operator_and(),
                          expr_gen(cast_expression,primary_expression,
                            new primary_expression_identifier(g_scope_stack.find_or_add("prtInvokeManagedFunc"))))))))))));
    fd->insert_before_top_level(new_fd);

    return call_name.str();
}

//#define ce_outer_debug 1

void call_expression::denest(function_definition *fd) {
#ifdef TODD_DEBUG
    print();
    printf("\n");
#endif
    call_expression *outer_call = m_parent->is_call_context();
    if(outer_call) {
#ifdef ce_outer_debug
        outer_call->print();
        printf("\n");
#endif
        // Find the argument_expression_list node containing this call.
        argument_expression_list *aelae = search_up_for_type<argument_expression_list>(this);
        if(!aelae) {
            aeprintf("Could not find argument_expression_list_assignment_expression for a nested call.\n");
        }
//        aelae->print();
//        printf("\n");

#ifdef ce_outer_debug
        aelae->print();
        printf("\n");
#endif
        // Get the assignment expression for this argument.
        assignment_expression *arg_ae = aelae->get_ae();
#ifdef ce_outer_debug
        arg_ae->print();
        printf("\n");
#endif
        // Get the type of this argument so as to create a temporary variable.
//        arg_ae->print();
//        printf("\n");
        auto_ptr<expression_type> apet(arg_ae->get_type());
        if(apet->is_void()) {
            outer_call->print();
            printf("\n");
        }
        assert(!apet->is_void());

        // Find the enclosing expression we will insert before.
        expression *inclusive_expr = search_up_for_type<expression>(aelae);
        initializer_assignment_expression *iae = NULL;
        if(!inclusive_expr) {
            iae = search_up_for_type<initializer_assignment_expression>(aelae);
            if(!iae) {
                aeprintf("Couldn't find inclusive statement to add set of ref_mask_ptr.\n");
            }
        }
#ifdef ce_outer_debug
        if(inclusive_expr) {
            inclusive_expr->print();
        } else {
            iae->print();
        }
        printf("\n");
#endif
        // Save the parent of the expression node for the replace call below.
        AST_node *inc_expr_parent = NULL;
        if(inclusive_expr) {
            inc_expr_parent = inclusive_expr->get_parent();
        } else {
            inc_expr_parent = iae->get_parent();
        }
#ifdef ce_outer_debug
        inc_expr_parent->print();
        printf("\n");
#endif

//        inc_expr_parent->print();
//        printf("\n");

        // The name of the new variable to store the result of the original argument expression.
        std::stringstream arg_save_str;
        arg_save_str << "_pillar2c_arg_with_call_temp_" << get_unique();
        ii_ptr arg_save_ii;

        assignment_expression *new_arg_expr =
            expr_gen(assignment_expression,postfix_expression,
                new postfix_expression_primary_expression(
                  new primary_expression_identifier(arg_save_ii = g_scope_stack.find_or_add(arg_save_str.str()))));
        aelae->replace(arg_ae,new_arg_expr);
#ifdef ce_outer_debug
        inc_expr_parent->print();
        printf("\n");
        aelae->print();
        printf("\n");
#endif

        arg_save_ii->add(IIT_VAR); // this is a new variable

        declarator *var_decl = NULL;
        if(apet->m_ad) {
            var_decl = apet->m_ad->gen_declarator(arg_save_str.str());
        } else {
            var_decl = new declarator_direct_declarator(
                            new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(arg_save_str.str()))
                        );
        }

        arg_save_ii->set_declarator(var_decl);

        type_specifier *temp_ts;

        block_item_list *arg_save_decl =
            new block_item_list_block_item(
              new block_item_declaration(
                new declaration_declaration_specifiers_init_declarator_list(
                  new declaration_specifiers_type_specifier(
                    temp_ts = (type_specifier*)apet->m_sql->get_type_specifier()->clone()),
                  new init_declarator_list_init_declarator(
                    new init_declarator_declarator(var_decl))),0));

        arg_save_ii->set_type(temp_ts);

        inc_expr_parent->prepend_bil(arg_save_decl);
#ifdef ce_outer_debug
        fd->print();
        printf("\n");
#endif

        assignment_expression *new_expr = NULL;

        new_expr = new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                       expr_gen(unary_expression,postfix_expression,
                           new postfix_expression_primary_expression(
                             new primary_expression_identifier(g_scope_stack.find_or_add(arg_save_str.str())))),
                       new assignment_operator_equal(),
                       arg_ae);

#ifdef ce_outer_debug
        new_expr->print();
        printf("\n");
#endif

        if(inclusive_expr) {
            expression *replacement_expr = new expression_expression_assignment_expression(
                new expression_assignment_expression(new_expr),
                expr_gen(assignment_expression,primary_expression,new primary_expression_expression(inclusive_expr)));

#ifdef ce_outer_debug
            inclusive_expr->print();
            printf("\n");
            inc_expr_parent->print();
            printf("\n");
            replacement_expr->print();
            printf("\n");
#endif

            inc_expr_parent->replace(inclusive_expr,replacement_expr);
        } else {
            assignment_expression *iae_ae = iae->claim_assignment_expression();

            inc_expr_parent->replace(iae,
                new initializer_assignment_expression(
                  expr_gen(assignment_expression,primary_expression,
                    new primary_expression_expression(
                      new expression_expression_assignment_expression(
                        new expression_assignment_expression(new_expr),
                        iae_ae)))));

            delete iae;
        }
#ifdef ce_outer_debug
        inc_expr_parent->print();
        printf("\n");
        fd->print();
        printf("\n");
#endif
        throw redo(inc_expr_parent);
    }
}

void call_expression::create_call_graph(function_definition *fd) {
    // First process the children of this node.
    AST_node **child = begin_child_iter();
    while(child) {
        CREATE_CALL_GRAPH((*child),fd);
        child = next_child_iter(child);
    }
    denest(fd);
}

void postfix_expression_call_expression::create_call_graph(function_definition *fd) {
    // Get the function that this function call takes place in.
    if(!fd) {
        // This can legitimately happen at least with gcc when the offsetof builtin appears to be
        // called when defining the PrtStackIteratorRegister enum.
        return;
    }

    if(cc_to_man_unman(fd->get_function_cc()) == MU_UNMANAGED) {
        // call graph only created for managed functions
        return;
    }

    if(m_ce->get_func_name() == "prtYield") {
        fd->set_gc_unsafe();
        return;
    }
    if(m_ce->get_func_name() == "sizeof") {
        // sizeof is not a real function so ignore it.
        return;
    }
    if(m_ce->get_func_name() == "prtGetTaskHandle" && fd->get_function_cc() == ST_PDECL) {
        return;
    }

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();

    // use of an undefined function
    if(callee_cc == ST_NOT_DEFINED) {
        // FIX FIX FIX ... what to do here?
        return;
    }

    // See if that target is managed or not.
    MAN_UNMAN callee_managed = cc_to_man_unman(callee_cc);
    if(fd->get_function_cc() == ST_PCDECL) {
        if(callee_cc != ST_PCDECL) {
            printf("In");
            m_ce->print();
            printf(", found call from pcdecl (%s) to non-pcdecl.\n",fd->get_symbol()->get_name());
        }
    }
    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(callee_managed == MU_UNMANAGED) {
        fd->set_gc_unsafe();
    } else if(callee_cc == ST_PDECL) {      // call graph ignores pcdecl
        std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(m_ce->get_func_name());
        if(fmiter == g_func_map.end()) {
            fd->set_gc_unsafe();

            fmiter = g_func_map.find("<UNKNOWN_FUNCS");
            if(fmiter == g_func_map.end()) {
                aeprintf("Could not find <UNKNOWN_FUNCS in g_func_map.\n");
            } else {
                fmiter->second->add_call_by(fd);
            }
        } else {
            fmiter->second->add_call_by(fd);
        }
    }

    CREATE_CALL_GRAPH(m_ce,fd);
}

std::string get_identifier(postfix_expression *pe) {
    postfix_expression_primary_expression *prim = dynamic_cast<postfix_expression_primary_expression *>(pe);
    if(prim) {
        primary_expression *pexp = prim->get_primary_expression();
        primary_expression_identifier *pei = dynamic_cast<primary_expression_identifier *>(pexp);
        if(pei) {
            return pei->get_symbol()->get_string();
        } else {
            return std::string();
        }
    } else {
        return std::string();
    }
}

std::string get_call_name(call_expression *ce) {
    call_expression_postfix_expression_empty_paren *empty = dynamic_cast<call_expression_postfix_expression_empty_paren *>(ce);
    call_expression_postfix_expression_paren_argument_expression_list *args = dynamic_cast<call_expression_postfix_expression_paren_argument_expression_list *>(ce);

    if(empty) {
        postfix_expression *pe = empty->get_postfix_expression();
        return get_identifier(pe);
    } else if(args) {
        postfix_expression *pe = args->get_postfix_expression();
        return get_identifier(pe);
    } else {
        return std::string();
    }
}

TranslateResult postfix_expression_call_expression::translate_pillar(function_definition *fd) {
    if(!fd) {
        // This can happen, e.g., in the case of __builtin_offset called in an enum declaration.
        return TranslateResult();
    }

    TranslateResult tr;
    TRANSLATE(m_ce,tr);

    translate_call(fd);

    return tr;
}

void restore_rares(call_expression *m_node,
                   assignment_expression *call_expr,
                   const std::map<unsigned,unsigned> &rare_map,
                   expression * &main_parent_list,
                   ii_ptr *orig_id_index,
                   const std::map<unsigned,std::string> &hoists,
                   function_definition *fd);

expression * gen_gc_at_call(expression *expr,function_definition *fd) {
    postfix_expression_primary_expression *force_pe =
        new postfix_expression_primary_expression(
            new primary_expression_identifier(g_scope_stack.find_or_add("pgc_force_gc")));
    call_expression *force_call = new call_expression_postfix_expression_empty_paren(force_pe);

#ifdef __x86_64__
    aeprintf("GC at every call is not yet supported in Intel64 mode.\n");
#endif // __x86_64__

    expression_type void_et;
    void_et.m_sql = new specifier_qualifier_list_type_specifier(new type_specifier_VOID());

    std::string stub_name = gen_and_insert_m2u_with_ret(force_call,fd,void_et);
    ii_ptr stub_symbol = NULL;
    stub_symbol = g_scope_stack.find_symbol(stub_name);
    if(!stub_symbol) {
        aeprintf("Pillar stub %s not found in symbol table.\n",stub_name.c_str());
    }

    // The 4th parameter to the transition stub is a Pillar call type.
    ii_ptr prt_call_type = NULL;
    prt_call_type = g_scope_stack.find_symbol("PrtCcCdecl");
    if(!prt_call_type) {
        aeprintf("Pillar stub PrtCcCdecl not found in symbol table.\n");
    }

    assignment_expression * arg_start_assignment_expression = NULL;
    assignment_expression * arg_size_expression = NULL;
    assignment_expression * cc_expression = NULL;
    assignment_expression * task_handle_arg = NULL;
    assignment_expression * pseudo_frame_arg = NULL;
    assignment_expression * function_expression = NULL;

    force_pe->claim();
    function_expression = expr_gen(assignment_expression,postfix_expression,force_pe);

    arg_start_assignment_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));

    cc_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(prt_call_type));

    if(g_use_th_param) {
        task_handle_arg = expr_gen(assignment_expression,primary_expression,
                                   new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle")));
    }

    pseudo_frame_arg = expr_gen(assignment_expression,unary_expression,
                                new unary_expression_unary_operator_cast_expression(
                                    new unary_operator_and(),
                                    expr_gen(cast_expression,primary_expression,
                                    new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME)))));

    arg_size_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));

    argument_expression_list *func_arg = NULL;

    if(g_use_th_param) {
        func_arg = argument_expression_list::new_recursive(func_arg,task_handle_arg);
    }
    func_arg = argument_expression_list::new_recursive(func_arg,pseudo_frame_arg);
    func_arg = argument_expression_list::new_recursive(func_arg,function_expression);
    func_arg = argument_expression_list::new_recursive(func_arg,arg_start_assignment_expression);
    func_arg = argument_expression_list::new_recursive(func_arg,arg_size_expression);
    func_arg = argument_expression_list::new_recursive(func_arg,cc_expression);

    assignment_expression *stub_call = NULL;
    stub_call = expr_gen(assignment_expression,postfix_expression,
                              new postfix_expression_call_expression(
                               new call_expression_postfix_expression_paren_argument_expression_list(
                                // Postfix arg to call_expression.
                                new postfix_expression_primary_expression(
                                 new primary_expression_identifier(stub_symbol)),
                                // Argument expression list arg to call_expression.
                                func_arg)));

    expression *ret = expression_expression_assignment_expression::new_recursive(expr,stub_call);

    delete force_call;

    return ret;
}

block_item_list * gen_pillar2c_pcall_target_args_decl(call_expression *ce);

void postfix_expression_call_expression::translate_call(function_definition *fd) {
#if 0
    if(fd->get_symbol()->get_string() == "isWorkAvailable") {
        printf("isWorkAvailable = %d, %d\n",fd->get_function_cc(),m_ce->get_call_cc());
    }
#endif

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(!cur_bb) {
        // No point translating if not in an active block.
        return;
    }

    if(get_call_name(m_ce) == "__noop") {
        // __noop is not a real function so ignore it.
        return;
    }

#ifdef TODD_DEBUG
    m_ce->print();
    printf("\n");
#endif

//    postfix_expression *final_this = this;
    call_expression *in_call_context = m_ce->get_parent()->is_call_context();
    std::string known_func = m_ce->get_func_name();
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();
    PILLAR2C_CALLCONV  caller_cc = fd->get_function_cc();
    bool set_ref_mask = true;
    if(caller_cc == ST_PDECL) {
    //    bool set_ref_mask = (in_call_context==NULL);
        if(known_func == "") {
            set_ref_mask = set_ref_mask && !fd->is_gc_safe();
        } else {
            std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(known_func);
            if(fmiter != g_func_map.end()) {
                set_ref_mask = set_ref_mask && !fmiter->second->is_gc_safe();
            } else {
                if(callee_cc == ST_PCDECL) {
                    set_ref_mask = false;
                } else {
                    set_ref_mask = set_ref_mask && !fd->is_gc_safe();
                }
            }
        }
    } else {
        set_ref_mask = false;
    }

    if(known_func == "prtYield" && cur_bb) {
        cur_bb->m_force_freq = BB_FREQ_RARE;
    }

    if(known_func == "prtGetTaskHandle" && fd->get_function_cc() == ST_PDECL && g_convert_prtGetTaskHandle) {
        if(!fd->is_gc_safe()) {
            postfix_expression_primary_expression *pepe =
              new postfix_expression_primary_expression(
                new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle"))
              );
            m_parent->replace(this,pepe);
            delete this;
        }
        return;
    }

    if(known_func == "sizeof") {
        // sizeof is not a real function so ignore it.
        return;
    }

    if(g_pillar2c_debug_level > 2) {
        printf("//postfix_expression_call_expression::translate_pillar\n");
    }

    if(ref_debug && set_ref_mask) {
        printf("%p\n",cur_bb);
        m_ce->print();
        printf("\n");
    }

    if(g_pillar2c_debug_level > 2) {
        printf("// fd = %p, name = %s\n",fd,fd->get_symbol()->get_name());
        printf("// Parent CC = %s, Callee CC = %s\n",cc_to_str(fd->get_function_cc()),cc_to_str(m_ce->get_call_cc()));
    }

    // Get the calling convention of the target.
    if(callee_cc == ST_NOT_DEFINED) {
        if(g_verbose) {
            printf("Skipping possible conversion of undeclared function %s\n",get_call_name(m_ce).c_str());
        }
        return;
    }

    if(known_func == "prtPcall") {
        AST_node *this_parent = m_parent;

        auto_ptr<call_expression_metadata> cem(m_ce->get_call_metadata());
        if(cem->m_args.size() != 5) {
            aeprintf("prtPcall encountered with more or less than 5 argumets.\n");
        }
#if 0
        assignment_expression *pillar2c_pcall_function_expression =
          expr_gen(assignment_expression,cast_expression,
            new cast_expression_type_name_cast_expression(
              new type_name_specifier_qualifier_list(
                new specifier_qualifier_list_type_specifier(
                  new type_specifier_TYPE_NAME(g_scope_stack.find_symbol("PrtCodeAddress")))),
              expr_gen(cast_expression,primary_expression,
                new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_pcall_target")))));
#endif

        std::stringstream stub_args_name;
        stub_args_name << "pillar2c_pcall_target_args_" << m_ce->get_unique();

        fd->prepend_bil(gen_pillar2c_pcall_target_args_decl(m_ce));

        assignment_expression * func_to_call_list    = NULL;
        assignment_expression * arg_start_alloc_list = NULL;
        assignment_expression * arg_start_copy_list  = NULL;
        assignment_expression * arg_size_expr_list   = NULL;
        assignment_expression * substitute_arg_size  = NULL;
        assignment_expression * enumerator_expr_list   = NULL;

        substitute_arg_size = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("4"));

        func_to_call_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "func")),
            new assignment_operator_equal(),
            cem->m_args[0]->clone());

        arg_start_alloc_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argStart")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression ,postfix_expression,
               new postfix_expression_call_expression(
                 new call_expression_postfix_expression_paren_argument_expression_list(
                   new postfix_expression_primary_expression(
                     new primary_expression_identifier(g_scope_stack.find_symbol("malloc_pillar2c_register"))),
                   new argument_expression_list_assignment_expression(cem->m_args[2]->clone())))));

        arg_start_copy_list =
           expr_gen(assignment_expression,postfix_expression,
             new postfix_expression_call_expression(
               new call_expression_postfix_expression_paren_argument_expression_list(
                 new postfix_expression_primary_expression(
                   new primary_expression_identifier(g_scope_stack.find_symbol("memcpy_pillar2c_register"))
                 ),
                 new argument_expression_list_argument_expression_list_assignment_expression(
                   new argument_expression_list_argument_expression_list_assignment_expression(
                     new argument_expression_list_assignment_expression(
                       expr_gen(assignment_expression,postfix_expression,
                         new postfix_expression_postfix_expression_dot_identifier(
                           new postfix_expression_primary_expression(
                             new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
                               "argStart"))  // arg 1
                     ),
                     cem->m_args[1]->clone() // arg 2
                   ),
                   cem->m_args[2]->clone() // arg 3
                 ))));

        arg_size_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argSize")),
            new assignment_operator_equal(),
            cem->m_args[2]->clone());

        enumerator_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "enumerator")),
            new assignment_operator_equal(),
            cem->m_args[4]->clone());

        expression *main_parent_list = NULL;

        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,func_to_call_list);
        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,arg_start_alloc_list);
        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,arg_start_copy_list);
        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,arg_size_expr_list);
        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,enumerator_expr_list);

        std::string stub_name = "prtPcall";
        ii_ptr stub_symbol  = g_scope_stack.find_symbol(stub_name);
        if(!stub_symbol) {
            aeprintf("Pillar stub %s not found in symbol table.\n",stub_name.c_str());
        }

        assignment_expression *pillar2c_pcall_function_expression =
          expr_gen(assignment_expression,cast_expression,
            new cast_expression_type_name_cast_expression(
              new type_name_specifier_qualifier_list(
                new specifier_qualifier_list_type_specifier(
                  new type_specifier_TYPE_NAME(g_scope_stack.find_symbol("PrtCodeAddress")))),
              expr_gen(cast_expression,primary_expression,
                new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_pcall_target")))));

        argument_expression_list *pillar2c_pcall_func_arg = new argument_expression_list_assignment_expression(pillar2c_pcall_function_expression);

        assignment_expression * pillar2c_pcall_arg_start_assignment_expression = NULL;
        pillar2c_pcall_arg_start_assignment_expression =
                expr_gen(assignment_expression,unary_expression,
                   new unary_expression_unary_operator_cast_expression (
                    new unary_operator_and(),
                    new cast_expression_unary_expression(
                     new unary_expression_postfix_expression(
                      new postfix_expression_primary_expression(
                       new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))))));

        argument_expression_list *pillar2c_pcall_arg_start =
            new argument_expression_list_argument_expression_list_assignment_expression(pillar2c_pcall_func_arg,pillar2c_pcall_arg_start_assignment_expression);

        assignment_expression *stub_call =
          expr_gen(assignment_expression,postfix_expression,
               new postfix_expression_call_expression(
                new call_expression_postfix_expression_paren_argument_expression_list(
                 // Postfix arg to call_expression.
                 new postfix_expression_primary_expression(
                  new primary_expression_identifier(stub_symbol)),
                   // Argument expression list arg to call_expression.
                   new argument_expression_list_argument_expression_list_assignment_expression(
                    new argument_expression_list_argument_expression_list_assignment_expression(
                     new argument_expression_list_argument_expression_list_assignment_expression(
                      pillar2c_pcall_arg_start,
                      // The third arg to the stub.
                      substitute_arg_size),
                     // The last arg to the stub.
                     cem->m_args[3]->clone()),
                    expr_gen(assignment_expression, cast_expression,
                     new cast_expression_type_name_cast_expression(
                      new type_name_specifier_qualifier_list(
                       new specifier_qualifier_list_type_specifier(
                        new type_specifier_TYPE_NAME(g_scope_stack.find_symbol("PrtPcallArgEnumerator")))),
                      expr_gen(cast_expression, primary_expression, new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_pcall_arg_enumerator")))))))));

        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,stub_call);

        postfix_expression_primary_expression *pepe = NULL;
        pepe = new postfix_expression_primary_expression(new primary_expression_expression(main_parent_list));

#if 0
        this_parent->print();
        printf("\n");
        pepe->print();
        printf("\n");
#endif

        this_parent->replace(this,pepe);

#if 0
        this_parent->print();
        printf("\n");
#endif

        delete this;
        return;
    }

    // Get the function expression and a vector of function arguments.
    auto_ptr<call_expression_metadata> cem(m_ce->get_call_metadata());
    check_vector<ii_ptr > flat_vec = m_ce->get_also_cuts_to_vec();

    switch_scope_on_return ssor(fd);

    if(cem->m_func_metadata.m_noreturn) {
        basic_block *ret_bb = get_return_target();
        assert(ret_bb);

        add_flow_graph_edge(cur_bb,ret_bb,EDGE_RETURN);
        ssor.set_block(NULL);
    } else if(flat_vec.size()) {
        basic_block *new_bb = NULL;
        new_bb = new basic_block(NULL);
        if(cur_bb) {
            add_flow_graph_edge(cur_bb, new_bb, EDGE_FALLTHROUGH);
        }

        unsigned cut_index;
        for(cut_index = 0; cut_index < flat_vec.size(); ++cut_index) {
            basic_block *cont_block = flat_vec[cut_index]->get_block_for_continuation();
            if(!cont_block) {
                cont_block = new basic_block(NULL);
                flat_vec[cut_index]->set_block_for_continuation(cont_block);
            } else {
//                cont_block->set_first_item(NULL);
            }
            if(cur_bb) {
                add_flow_graph_edge(cur_bb, cont_block, EDGE_CUT);
            }
        }

        ssor.set_block(new_bb);
    } else {
        ssor.set_block(cur_bb);
    }

    if(callee_cc == ST_NOT_DEFINED) {
        aeprintf("callee_cc undefined %s\n",known_func.c_str());
    }

    if(caller_cc == ST_PCDECL) {
        if(callee_cc != ST_PCDECL) {
            aeprintf("Non-pcdecl function %s called from pcdecl function %s.\n",known_func.c_str(),fd->get_symbol()->get_name());
        }
    }

    if(callee_cc == ST_PCDECL) {
        if(set_ref_mask) {
            aeprintf("set_ref_mask should never be set for a pcdecl callee in translate_call.\n");
        }
        return;
    }

    // See if that target is managed or not.
    MAN_UNMAN callee_managed = cc_to_man_unman(callee_cc);
    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(cc_to_man_unman(caller_cc) != callee_managed) {
        if(set_ref_mask && fd->get_total_refs()) {
            assert(set_ref_mask);
            cur_bb->m_live_refs_here.push_back(new ref_call(m_ce,false,in_call_context!=NULL));
            m_ce->push_read_write(cur_bb->m_live_refs_here);
            cur_bb->m_has_call = true;
        } else {
            assert(!fd->is_gc_safe());
            ++g_unsafe_calls;

            AST_node *this_parent = m_parent;

#ifdef __x86_64__

            unsigned callee_num_args = cem->m_args.size();

            if(callee_managed == MU_UNMANAGED) {
//              aeprintf("Can this happen?\n");

                expression *main_expr = NULL;
                main_expr = new expression_assignment_expression(
                             expr_gen(assignment_expression,postfix_expression,this));

                postfix_expression_primary_expression *pepe = NULL;
                pepe = new postfix_expression_primary_expression(new primary_expression_expression(main_expr));

                if(g_pillar2c_debug_level > 2) {
                    printf("// CALL to be inserted.\n#if 0\n");
                    pepe->print();
                    printf("\n#endif\n// Insert CALL\n");
                }

                this_parent->replace(this,pepe);

    //            final_this = pepe;

                if(set_ref_mask) {
                    // Any basic block with a M2U call in it is presumed to be rare.
                    cur_bb->m_freq = BB_FREQ_RARE;
                    cur_bb->m_live_refs_here.push_back(new ref_call(m_ce,true,in_call_context!=NULL));
                    m_ce->push_read_write(cur_bb->m_live_refs_here);
                    cur_bb->m_has_call = true;
                }
            } else {
                assert(!set_ref_mask);

                std::string node_unique = m_ce->get_unique();

                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(known_func);
                if(fmiter == g_func_map.end() || !fmiter->second->is_gc_safe()) {
                    argument_expression_list *ael = gen_extra_args_for_u2m();
                    m_ce = m_ce->prepend_arg_list(ael);
                    cem.reset(m_ce->get_call_metadata());
                    callee_num_args = cem->m_args.size();
                }

                // callee is managed
                expression *inclusive_stmt = search_up_for_type<expression>(this);
                initializer_assignment_expression *iae = NULL;
                if(!inclusive_stmt) {
                    iae = search_up_for_type<initializer_assignment_expression>(this);
                    if(!iae) {
                        aeprintf("Couldn't find inclusive statement.\n");
                    }
                }

                AST_node *inc_stmt_parent = NULL;
                if(inclusive_stmt) {
                    inc_stmt_parent = inclusive_stmt->get_parent();
                } else {
                    inc_stmt_parent = iae->get_parent();
                }

                auto_ptr<expression_type> ret_type(get_return_type());
                bool ret_needed = !ret_type->is_void();

                expression *new_expr = NULL;

                ii_ptr to_managed_symbol = NULL;
                to_managed_symbol = g_scope_stack.find_symbol("enterManagedCode");
                if(!to_managed_symbol) {
                    aeprintf("Pillar function enterManagedCode not found in symbol table.\n");
                }
                ii_ptr reenter_unmanaged_symbol = NULL;
                reenter_unmanaged_symbol = g_scope_stack.find_symbol("reenterUnmanagedCode");
                if(!reenter_unmanaged_symbol) {
                    aeprintf("Pillar function reenterUnmanagedCode not found in symbol table.\n");
                }

                argument_expression_list *enter_managed_arg = NULL;

                enter_managed_arg = argument_expression_list::new_recursive(enter_managed_arg,
                                        expr_gen(assignment_expression,postfix_expression,
                                            new postfix_expression_call_expression(
                                                new call_expression_postfix_expression_empty_paren(
                                                new postfix_expression_primary_expression(
                                                    new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));

                if(g_log_m2u) {
                    char *string_lit;
                    if(known_func == "") {
                        string_lit = strdup("\"function_pointer\"");
                    } else {
                        std::string with_quotes = "\"" + known_func + "\"";
                        string_lit = strdup(with_quotes.c_str());
                    }

                    new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                      expr_gen(assignment_expression,postfix_expression,
                        new postfix_expression_call_expression(
                          new call_expression_postfix_expression_paren_argument_expression_list (
                            new postfix_expression_primary_expression(
                              new primary_expression_identifier(g_scope_stack.find_or_add("__pillar2c_log_m2u"))),
                            new argument_expression_list_assignment_expression(
                              expr_gen(assignment_expression,primary_expression,
                                new primary_expression_string(string_lit)))))));
                }

                new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                       expr_gen(assignment_expression,postfix_expression,
                         new postfix_expression_call_expression(
                           new call_expression_postfix_expression_paren_argument_expression_list(
                             new postfix_expression_primary_expression(
                               new primary_expression_identifier(to_managed_symbol)),
                             enter_managed_arg))));

                std::stringstream var_str;

                if(inclusive_stmt) {
                    if (ret_needed) {
                        var_str << "_pillar2c_temp_" << node_unique;

                        declarator *var_decl = NULL;
                        if(ret_type->m_ad) {
                            var_decl = ret_type->m_ad->gen_declarator(var_str.str());
                        } else {
                            var_decl = new declarator_direct_declarator(
                                         new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str())));
                        }

                        block_item_list * bil =
                            new block_item_list_block_item(
                              new block_item_declaration(
                                new declaration_declaration_specifiers_init_declarator_list(
                                  new declaration_specifiers_type_specifier(
                                    (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                                  new init_declarator_list_init_declarator(
                                    new init_declarator_declarator(
                                      var_decl))),0));

                        inc_stmt_parent->prepend_bil(bil);

                        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                                     new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                       expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                                       new assignment_operator_equal(),
                                       expr_gen(assignment_expression,primary_expression,
                                         new primary_expression_expression(inclusive_stmt))));
                    } else {
                        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                                       expr_gen(assignment_expression,primary_expression,
                                         new primary_expression_expression(inclusive_stmt)));
                    }

                    argument_expression_list *reenter_unmanaged_arg = NULL;

                    reenter_unmanaged_arg = argument_expression_list::new_recursive(reenter_unmanaged_arg,
                                            expr_gen(assignment_expression,postfix_expression,
                                                new postfix_expression_call_expression(
                                                    new call_expression_postfix_expression_empty_paren(
                                                    new postfix_expression_primary_expression(
                                                        new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));

                    new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                           expr_gen(assignment_expression,postfix_expression,
                             new postfix_expression_call_expression(
                               new call_expression_postfix_expression_paren_argument_expression_list(
                                 new postfix_expression_primary_expression(
                                   new primary_expression_identifier(reenter_unmanaged_symbol)),
                                 reenter_unmanaged_arg))));

                    if (ret_needed) {
                        new_expr = expression_expression_assignment_expression::new_recursive(
                             new_expr,
                             expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))));
                    }

                    inc_stmt_parent->replace(inclusive_stmt,new_expr);
                } else {
                    assignment_expression *iae_ae = iae->claim_assignment_expression();
                    assert(ret_needed);

                    var_str << "_pillar2c_temp_" << node_unique;

                    declarator *var_decl = NULL;
                    if(ret_type->m_ad) {
                        var_decl = ret_type->m_ad->gen_declarator(var_str.str());
                    } else {
                        var_decl = new declarator_direct_declarator(
                                        new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str())));
                    }

                    block_item_list * bil =
                        new block_item_list_block_item(
                            new block_item_declaration(
                            new declaration_declaration_specifiers_init_declarator_list(
                                new declaration_specifiers_type_specifier(
                                (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                                new init_declarator_list_init_declarator(
                                new init_declarator_declarator(
                                    var_decl))),0));

                    inc_stmt_parent->prepend_bil(bil);

                    new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                    expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                                    new assignment_operator_equal(),
                                    expr_gen(assignment_expression,primary_expression,
                                        new primary_expression_expression(
                                          new expression_assignment_expression(
                                            iae_ae)))));

                    argument_expression_list *reenter_unmanaged_arg = NULL;

                    reenter_unmanaged_arg = argument_expression_list::new_recursive(reenter_unmanaged_arg,
                                            expr_gen(assignment_expression,postfix_expression,
                                                new postfix_expression_call_expression(
                                                    new call_expression_postfix_expression_empty_paren(
                                                    new postfix_expression_primary_expression(
                                                        new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));

                    new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                           expr_gen(assignment_expression,postfix_expression,
                             new postfix_expression_call_expression(
                               new call_expression_postfix_expression_paren_argument_expression_list(
                                 new postfix_expression_primary_expression(
                                   new primary_expression_identifier(reenter_unmanaged_symbol)),
                                 reenter_unmanaged_arg))));

                    new_expr = expression_expression_assignment_expression::new_recursive(
                            new_expr,
                            expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))));

                    inc_stmt_parent->replace(iae,
                        new initializer_assignment_expression(
                          expr_gen(assignment_expression,primary_expression,
                            new primary_expression_expression(new_expr))));

                    delete iae;
                }
            }
#else  // __x86_64__

            size_t callee_num_args = cem->m_args.size();

            ii_ptr stub_symbol = NULL;
            std::string stub_name;
            // Determine the name of the Pillar stub to invoke.
            if(callee_managed == MU_MANAGED) {
                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(known_func);
                if(fmiter == g_func_map.end() || !fmiter->second->is_gc_safe()) {
                    argument_expression_list *ael = gen_extra_args_for_u2m();
                    m_ce = m_ce->prepend_arg_list(ael);
                    cem.reset(m_ce->get_call_metadata());
                    callee_num_args = cem->m_args.size();
                }

//                stub_name = "prtInvokeManagedFunc";
                stub_name = gen_and_insert_u2m_with_ret(m_ce,fd,*(cem->m_ret));
            } else {
                stub_name = gen_and_insert_m2u_with_ret(m_ce,fd,*(cem->m_ret));
            }

            stub_symbol = g_scope_stack.find_symbol(stub_name);
            if(!stub_symbol) {
                aeprintf("Pillar stub %s not found in symbol table.\n",stub_name.c_str());
            }

            // The 4th parameter to the transition stub is a Pillar call type.
            ii_ptr prt_call_type = NULL;
            if(callee_cc == ST_PDECL || callee_cc == ST_STDCALL) {
                prt_call_type = g_scope_stack.find_symbol("PrtCcStdcall");
                if(!prt_call_type) {
                    aeprintf("Pillar stub PrtCcStdcall not found in symbol table.\n");
                }
            } else if (callee_cc == ST_PCDECL || callee_cc == ST_CDECL) {
                prt_call_type = g_scope_stack.find_symbol("PrtCcCdecl");
                if(!prt_call_type) {
                    aeprintf("Pillar stub PrtCcCdecl not found in symbol table.\n");
                }
            } else assert(0);

            assignment_expression * arg_start_assignment_expression = NULL;
            assignment_expression * arg_size_expression = NULL;
            assignment_expression * cc_expression = NULL;
            assignment_expression * task_handle_arg = NULL;
            assignment_expression * pseudo_frame_arg = NULL;
            assignment_expression * function_expression = NULL;

            function_expression = expr_gen(assignment_expression,postfix_expression,cem->claim_function());

            if(!callee_num_args) {
                arg_start_assignment_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));
            }

            if(callee_managed == MU_UNMANAGED) {
                cc_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(prt_call_type));

                if(g_use_th_param) {
                    task_handle_arg  = expr_gen(assignment_expression,primary_expression,
                                         new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle")));
                }

                pseudo_frame_arg = expr_gen(assignment_expression,unary_expression,
                                            new unary_expression_unary_operator_cast_expression(
                                             new unary_operator_and(),
                                             expr_gen(cast_expression,primary_expression,
                                              new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME)))));
            }

            argument_expression_list *func_arg = NULL;

            if(task_handle_arg) {
                func_arg = argument_expression_list::new_recursive(func_arg,task_handle_arg);
            }
            if(pseudo_frame_arg) {
                func_arg = argument_expression_list::new_recursive(func_arg,pseudo_frame_arg);
            }
            func_arg = argument_expression_list::new_recursive(func_arg,function_expression);

            std::stringstream callsite_str;
            callsite_str << "PrtArgs_" << m_ce->get_unique();

            std::stringstream stub_args_name;
            if(callee_managed == MU_UNMANAGED) {
                stub_args_name << "prt_arguments.";
            }

            if(cem->m_args.size()) {
                std::list<external_declaration *> spec_struct =
                  gen_specific_callsite_prt_args(1,fd->get_symbol()->get_string(),callsite_str.str(),*cem);
    //            external_declaration *spec_struct = gen_specific_callsite_prt_args(callsite_str,cem);
    //            spec_struct->print();
                fd->insert_before_top_level(spec_struct);
                if(g_prt_args_in_pseudo && (callee_managed == MU_UNMANAGED)) {
                    std::stringstream type_buf;
                    type_buf << "PrtArgs_" << m_ce->get_unique();

                    std::stringstream var_buf;
                    var_buf << "prt_args_" << m_ce->get_unique();

//                    if(in_call_context) {
//                        stub_args_name << "prt_args_" << in_call_context->get_unique() << ".";
//                        fd->add_prt_arg_list(in_call_context->get_unique(), type_buf.str(), var_buf.str());
//                    } else {
                        if(fd->add_prt_arg_list(m_ce->get_unique(), type_buf.str(), var_buf.str())) {
                            stub_args_name << "prt_args_" << m_ce->get_unique() << ".";
                        }
//                    }
                } else {
                    fd->prepend_bil(generate_prt_args_decl(m_ce));
                }
            }

            stub_args_name << "prt_args_" << m_ce->get_unique();

            if(callee_num_args) {
                if(g_prt_args_in_pseudo && (callee_managed == MU_UNMANAGED)) {
                    arg_start_assignment_expression = expr_gen(assignment_expression,unary_expression,
                           new unary_expression_unary_operator_cast_expression (
                            new unary_operator_and(),
                            expr_gen(cast_expression,postfix_expression,
                              gen_pseudo_pe(stub_args_name.str(),this))));

                    arg_size_expression = expr_gen(assignment_expression,multiplicative_expression,
                       new multiplicative_expression_multiplicative_expression_div_cast_expression(
                        new multiplicative_expression_cast_expression(
                         new cast_expression_unary_expression(
                          new unary_expression_sizeof_unary_expression(
                           new unary_expression_postfix_expression(
                            new postfix_expression_primary_expression(
                             new primary_expression_expression(
                              new expression_assignment_expression(
                               expr_gen(assignment_expression,primary_expression,
                                gen_pseudo_pe(stub_args_name.str(),this))))))))),
                        expr_gen(cast_expression,primary_expression,new primary_expression_constant(register_size_const))));
                } else {
                    arg_start_assignment_expression = expr_gen(assignment_expression,unary_expression,
                           new unary_expression_unary_operator_cast_expression (
                            new unary_operator_and(),
                            expr_gen(cast_expression,primary_expression,
                              new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))));

                    arg_size_expression = expr_gen(assignment_expression,multiplicative_expression,
                       new multiplicative_expression_multiplicative_expression_div_cast_expression(
                        new multiplicative_expression_cast_expression(
                         new cast_expression_unary_expression(
                          new unary_expression_sizeof_unary_expression(
                           new unary_expression_postfix_expression(
                            new postfix_expression_primary_expression(
                             new primary_expression_expression(
                              new expression_assignment_expression(
                               expr_gen(assignment_expression,primary_expression,
                                new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))))))))),
                        expr_gen(cast_expression,primary_expression,new primary_expression_constant(register_size_const))));
                }
            } else {
                arg_size_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));
            }

            argument_expression_list *arg_start_arg =
                new argument_expression_list_argument_expression_list_assignment_expression(func_arg,arg_start_assignment_expression);

            call_expression *stub_call_expr = NULL;

            argument_expression_list *full_ael = NULL;
            if(cc_expression) {
                full_ael = // Argument expression list arg to call_expression.
                                new argument_expression_list_argument_expression_list_assignment_expression(
                                 new argument_expression_list_argument_expression_list_assignment_expression(
                                  arg_start_arg,
                                  // The third arg to the stub.
                                  arg_size_expression
                                 ),
                                 // The last arg to the stub.
                                 cc_expression);
            } else {
                full_ael = // Argument expression list arg to call_expression.
                                 new argument_expression_list_argument_expression_list_assignment_expression(
                                  arg_start_arg,
                                  // The third arg to the stub.
                                  arg_size_expression);
            }

            assignment_expression *stub_call = NULL;
            stub_call = expr_gen(assignment_expression,postfix_expression,
                              new postfix_expression_call_expression(
                               stub_call_expr = new call_expression_postfix_expression_paren_argument_expression_list(
                                // Postfix arg to call_expression.
                                new postfix_expression_primary_expression(
                                 new primary_expression_identifier(stub_symbol)),
                                full_ael)));

            expression *main_parent_list = NULL;
            if(g_log_m2u) {
                char *string_lit;
                if(known_func == "") {
                    string_lit = strdup("\"function_pointer\"");
                } else {
                    std::string with_quotes = "\"" + known_func + "\"";
                    string_lit = strdup(with_quotes.c_str());
                }

                main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                  expr_gen(assignment_expression,postfix_expression,
                    new postfix_expression_call_expression(
                      new call_expression_postfix_expression_paren_argument_expression_list (
                        new postfix_expression_primary_expression(
                          new primary_expression_identifier(g_scope_stack.find_or_add("__pillar2c_log_m2u"))),
                        new argument_expression_list_assignment_expression(
                          expr_gen(assignment_expression,primary_expression,
                            new primary_expression_string(string_lit)))))));
            }

            if(cem->m_args.size() > 0) {
                std::stringstream arg_prefix;
                if(callee_managed == MU_UNMANAGED) {
                    arg_prefix << "prt_arguments.";
                    if(g_prt_args_in_pseudo) {
                            arg_prefix << "prt_args_" << m_ce->get_unique() << ".";
                    }
                }
                arg_prefix << "prt_args_";
                unsigned index;
                check_vector<assignment_expression*> claimed_aes = m_ce->claim_args();
                // Add args and create an expression assignment AST node.
                for(index=0; index < cem->m_args.size(); ++index) {
                    if(index < cem->m_func_metadata.m_params.size()) {
                      auto_ptr<expression_type> apet(cem->m_func_metadata.m_params[index]->get_type());
                      main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                        create_expression_for_arg(apet.get(),claimed_aes[index],index,m_ce,"arg",arg_prefix.str().c_str(),true,false,callee_managed==MU_UNMANAGED));
                    } else {
                      auto_ptr<expression_type> apet(cem->m_args[index]->get_type());
                      main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                        create_expression_for_arg(apet.get(),claimed_aes[index],index,m_ce,"arg",arg_prefix.str().c_str(),true,false,callee_managed==MU_UNMANAGED));
                    }
                }

                // Add the stub call itself.
                main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,stub_call);
            } else {
                main_parent_list = new expression_assignment_expression(stub_call);
            }

            postfix_expression_primary_expression *pepe = NULL;
            pepe = new postfix_expression_primary_expression(
                     new primary_expression_expression(main_parent_list)
                   );

            if(g_pillar2c_debug_level > 2) {
                printf("// CALL to be inserted.\n#if 0\n");
                pepe->print();
                printf("\n#endif\n// Insert CALL\n");
            }
            m_parent->replace(this,pepe);

//            final_this = pepe;

            delete this;

            if(set_ref_mask) {
                // Any basic block with a M2U call in it is presumed to be rare.
                if(callee_managed == MU_UNMANAGED) {
                    cur_bb->m_freq = BB_FREQ_RARE;
                }
                cur_bb->m_live_refs_here.push_back(new ref_call(stub_call_expr,true,in_call_context!=NULL));
                stub_call_expr->push_read_write(cur_bb->m_live_refs_here);
                cur_bb->m_has_call = true;
            }
#endif // __x86_64__
        }
    } else {
        // calling convention match
        if(callee_managed == MU_MANAGED) {
//            bool rare = false;

            // no translations for pcdecl
            if(callee_cc == ST_PDECL) {
                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(known_func);
                if(fmiter != g_func_map.end()) {
                    if(fmiter->second->is_gc_safe()) {
//                        printf("SAFE_CALL_SKIP %s\n",fmiter->first.c_str());
                        ++g_safe_calls;
                        return;
                    }
                }

                ++g_unsafe_calls;
                assert(!fd->is_gc_safe());
            } else {
                if(known_func == "orp_local_to_gc_local") {
                    return;
                }
            }

            if(callee_cc == ST_PDECL) {
                std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE>::iterator iter;
                iter = g_pillar_runtime_funcs.find(known_func);
                if(iter == g_pillar_runtime_funcs.end()) {
                    // one managed function calling another. add the two extra args
                    argument_expression_list *ael = gen_extra_args();
                    m_ce = m_ce->prepend_arg_list(ael);
                } else {
                    if(iter->second == PILLAR_RUNTIME_FUNC_NO_DIRECT_CALL) {
                        aeprintf("Direct call to %s not allowed.\n",iter->first.c_str());
                    }
                    // Handle write barrier conversion.
                    if(iter->first == "gc_heap_slot_write_barrier_indirect") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_ce = m_ce->append_arg_list(ael);
                        // now just change the function name
                        m_ce->change_func_name(std::string("gc_heap_slot_write_barrier_indirect_prt"));
                    } else if(iter->first == "gc_heap_slot_write_interior_indirect") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_ce = m_ce->append_arg_list(ael);
                        // now just change the function name
                        m_ce->change_func_name(std::string("gc_heap_slot_write_interior_indirect_prt"));
                    } else if(iter->first == "gc_cas_write_barrier_indirect") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_ce = m_ce->append_arg_list(ael);
                        // now just change the function name
                        m_ce->change_func_name(std::string("gc_cas_write_barrier_indirect_prt"));
                    } else if(iter->first == "gc_cas_write_interior_indirect") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_ce = m_ce->append_arg_list(ael);
                        // now just change the function name
                        m_ce->change_func_name(std::string("gc_cas_write_interior_indirect_prt"));
                    } else if(iter->first == "prtYield") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_ce = m_ce->prepend_arg_list(ael);
                        // now just change the function name
                        m_ce->change_func_name(std::string("pillar2cYield"));
                    }
                }
            }

            if(set_ref_mask) {
                cur_bb->m_live_refs_here.push_back(new ref_call(m_ce,true,in_call_context!=NULL));
                m_ce->push_read_write(cur_bb->m_live_refs_here);
                cur_bb->m_has_call = true;
            }
        }
    }
}

TranslateResult postfix_expression_postfix_expression_brace_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_pe,tr1);
    TRANSLATE(m_e,tr2);

    if(g_expression_type) {
        assert(tr1.m_et->m_ad);
        if(!tr1.m_et->m_ad->is_pointer()) {
            print();
            printf("\n");
            assert(tr1.m_et->m_ad->is_pointer());
        }
        abstract_declarator *ad = tr1.m_et->m_ad->remove_pointer_star();
        delete tr1.m_et->m_ad;
        tr1.m_et->m_ad = ad;
    }

    return tr1;
}

TranslateResult postfix_expression_postfix_expression_paren_argument_expression_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_pe,tr1);
    TRANSLATE(m_ael,tr2);
    aeprintf("type problem\n");
    // FIX FIX FIX combine tr1 and tr2
    return tr1;
}

TranslateResult postfix_expression_type_name_initializer_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tn,tr1);
    TRANSLATE(m_il,tr2);
    return tr1;
}

TranslateResult postfix_expression_type_name_initializer_list_comma::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tn,tr1);
    TRANSLATE(m_il,tr2);
    return tr1;
}

TranslateResult type_specifier_struct_or_union_specifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sous,tr);
    return tr;
}

TranslateResult type_specifier_enum_specifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_es,tr);
    return tr;
}

TranslateResult specifier_qualifier_list_type_qualifier_specifier_qualifier_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tq,tr1);
    TRANSLATE(m_ql,tr2);
    return TranslateResult();
}

TranslateResult specifier_qualifier_list_type_qualifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_tq,tr);
    return TranslateResult();
}

TranslateResult pointer_star_type_qualifier_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_tql,tr);
    return TranslateResult();
}

TranslateResult pointer_star_type_qualifier_list_pointer::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tql,tr1);
    TRANSLATE(m_p,tr2);
    return TranslateResult();
}

TranslateResult abstract_declarator_direct_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_dad,tr);
    if(!g_intel64) {
        //direct_abstract_declarator_direct_abstract_declarator_empty_parens *dad_dad_ep = dynamic_cast<direct_abstract_declarator_direct_abstract_declarator_empty_parens>(m_dad);
        direct_abstract_declarator_abstract_declarator *dad_ad = dynamic_cast<direct_abstract_declarator_abstract_declarator*>(m_dad);
        if(!dad_ad) {
            m_dad->add_explicit_call_conv(m_dad->get_call_conv());
        }
    }
    return tr;
}

TranslateResult abstract_declarator_pointer_direct_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_p,tr1);
    TRANSLATE(m_dad,tr2);
    return TranslateResult();
}

TranslateResult abstract_declarator_call_conv_specifier_direct_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ccs,tr1);
    TRANSLATE(m_dad,tr2);
    return TranslateResult();
}

TranslateResult abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_ccs,tr1);
    TRANSLATE(m_p,tr2);
    TRANSLATE(m_dad,tr3);
    return TranslateResult();
}

TranslateResult type_name_specifier_qualifier_list_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sql,tr1);
    TRANSLATE(m_ad,tr2);

    if(g_expression_type) {
        expression_type *ret = new expression_type;

        ret->m_sql = m_sql->clone();
        ret->m_ad  = m_ad->clone();

        return TranslateResult(auto_ptr<expression_type>(ret));
    } else {
        return TranslateResult();
    }
}

TranslateResult argument_expression_list_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ae,tr);
    return tr;
}

TranslateResult argument_expression_list_argument_expression_list_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    // FIX FIX FIX - will not be right for cases when args pushed left to right
    // Since all the cases we care about push args right to left we will process the
    // argument expression list from last to first so that refs are added in the correct
    // order.
    TRANSLATE(m_ae,tr2);
    TRANSLATE(m_ael,tr1);
    return TranslateResult();
}

TranslateResult unary_expression_sizeof_type_name::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_tn,tr);

    if(g_expression_type) {
        primary_expression_constant_int peci("");
        return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
    } else {
        return TranslateResult();
    }
}

TranslateResult declaration_declaration_specifiers::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ds,tr);
    return tr;
}

TranslateResult declaration_declaration_specifiers_init_declarator_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ds,tr1);
    TRANSLATE(m_idl,tr2);
    return TranslateResult();
}

TranslateResult declaration_specifiers_type_specifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ts,tr);
    return tr;
}

TranslateResult declaration_specifiers_type_specifier_declaration_specifiers::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ts,tr1);
    TRANSLATE(m_ds,tr2);
    return TranslateResult();
}

#include <iostream>

ii_ptr  make_ret_type(const check_vector<type_name *> &types, AST_node *function) {
    std::stringstream struct_name;
    struct_name << "ret_type";
    unsigned ts_num;
    for(ts_num = 0; ts_num < types.size(); ++ts_num) {
        struct_name << "_";

        std::stringstream temp_type;
        types[ts_num]->strprint(temp_type);
        std::string temp_str = temp_type.str();
        unsigned str_pos;
        for(str_pos = 0; str_pos < temp_str.length(); ++str_pos) {
            if(temp_str[str_pos] == ' ') {
                // intentionally do nothing
            } else if(temp_str[str_pos] == '_') {
                struct_name << "___";
            } else if(temp_str[str_pos] == '*') {
                struct_name << "__ptr";
            } else {
                struct_name << temp_str[str_pos];
            }
        }
    }

    ii_ptr ret_ii = NULL;
    std::map<std::string, ii_ptr >::iterator ret_type_iter;
#ifdef MULTITHREAD
    pthread_mutex_lock(&g_generic_mutex);
#endif
    ret_type_iter = g_ret_type_structs.find(struct_name.str());
    if(ret_type_iter == g_ret_type_structs.end()) {
        ret_ii = g_scope_stack.find_or_add(struct_name.str(),IIT_STRUCT_ENUM);
        Scope *ret_struct_scope = g_scope_stack.enter_scope();
        ret_ii->set_struct_scope(ret_struct_scope);

        std::stringstream ret_value_struct;
        ret_value_struct << "typedef struct {\n";

        for(ts_num = 0; ts_num < types.size(); ++ts_num) {
            std::stringstream field_name;
            field_name << "part" << ts_num;
            g_scope_stack.find_or_add(field_name.str());

            types[ts_num]->strprint(ret_value_struct);
            ret_value_struct << " " << field_name.str() << ";\n";
        }
        g_scope_stack.leave_scope();

        ret_value_struct << "} " << struct_name.str();
        ret_value_struct << ";\n";

//        std::cout << ret_value_struct.str() << std::endl;

        external_declaration_emit_text *edet = new external_declaration_emit_text(ret_value_struct.str());
        function->insert_before_top_level(edet);

        g_ret_type_structs.insert(std::pair<std::string,ii_ptr>(struct_name.str(),ret_ii));
    } else {
        ret_ii = ret_type_iter->second;
    }
#ifdef MULTITHREAD
    pthread_mutex_unlock(&g_generic_mutex);
#endif

    return ret_ii;
}

TranslateResult declaration_specifiers_mrv::translate_pillar(function_definition *fd) {
    AST_node *this_parent = m_parent;
    declaration_specifiers *ds_temp = dynamic_cast<declaration_specifiers*>(m_parent);
    function_definition *fd_parent  = dynamic_cast<function_definition*>(m_parent);
    declaration_declaration_specifiers_init_declarator_list *ddsidl_parent  = dynamic_cast<declaration_declaration_specifiers_init_declarator_list*>(m_parent);

    if(!ds_temp) {
        aeprintf("Parent of declaration_specifiers_mrv was not of type declaration_specifiers.\n");
    }
    while(1) {
        declaration_specifiers *ds_temp2 = dynamic_cast<declaration_specifiers*>(ds_temp->get_parent());
        if(ds_temp2) {
            ds_temp = ds_temp2;
        } else {
            break;
        }
    }

    fd_parent     = dynamic_cast<function_definition*>(ds_temp->get_parent());
    ddsidl_parent = dynamic_cast<declaration_declaration_specifiers_init_declarator_list*>(m_parent);

    ii_ptr  ret_ii = NULL;
    if(fd_parent) {
        assert(fd_parent == fd);
        m_ts->flatten(fd->m_mrv_vec);
        ret_ii = make_ret_type(fd->m_mrv_vec, fd);
        declaration_specifiers *ds = new declaration_specifiers_type_specifier( new type_specifier_TYPE_NAME(ret_ii) );
        this_parent->replace(this,ds);
    } else if(ddsidl_parent) {
        check_vector<type_name *> type_vec;
        m_ts->flatten(type_vec);
        ret_ii = make_ret_type(type_vec,fd);
        declaration_specifiers *ds = new declaration_specifiers_type_specifier( new type_specifier_TYPE_NAME(ret_ii) );
        ddsidl_parent->replace(this,ds);
    } else {
        aeprintf("Unsupported use of mrv.\n");
    }
/*
    TRANSLATE(m_ts);
*/

    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(new type_specifier_TYPE_NAME(ret_ii));
    ret->m_ad  = NULL;

    return TranslateResult(auto_ptr<expression_type>(ret));
}

TranslateResult declaration_specifiers_mrv_declaration_specifiers::translate_pillar(function_definition *fd) {
    aeprintf("declaration_specifiers_mrv_declaration_specifiers::translate_pillar\n");
/*
    TRANSLATE(m_ts);
    TRANSLATE(m_ds);
*/
    // FIX FIX FIX
    return TranslateResult();
}

TranslateResult declaration_specifiers_type_qualifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_tq,tr);
    return tr;
}

TranslateResult declaration_specifiers_type_qualifier_declaration_specifiers::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tq,tr1);
    TRANSLATE(m_ds,tr2);
    return TranslateResult();
}

TranslateResult declaration_specifiers_function_specifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_fs,tr);
    return TranslateResult();
}

TranslateResult declaration_specifiers_function_specifier_declaration_specifiers::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_fs,tr1);
    TRANSLATE(m_ds,tr2);
    return TranslateResult();
}

TranslateResult declaration_specifiers_gcc_attribute_declaration_specifiers::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ds,tr);
    return tr;
}

TranslateResult init_declarator_declarator_initializer::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_i,tr1);
    TRANSLATE(m_d,tr2);

    std::list<ii_ptr > symbol = m_d->get_enclosing_symbols();
    if(symbol.size() != 1) {
        aeprintf("declarator declared more than one symbol.\n");
    } else {
        ii_ptr ii = symbol.front();
        if(ii->has_ref_index()) {
            if(fd) {
                basic_block *cur_bb = fd->get_cur_basic_block();
                assert(cur_bb);
                cur_bb->m_live_refs_here.push_back(new ref_lvalue(ii));
            }
        }
    }

    return TranslateResult();
}

TranslateResult struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sou,tr1);
    TRANSLATE(m_sdl,tr2);
    return TranslateResult();
}

TranslateResult struct_or_union_specifier_struct_or_union_struct_declaration_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sou,tr1);
    TRANSLATE(m_sdl,tr2);
    return TranslateResult();
}

TranslateResult struct_or_union_specifier_struct_or_union_identifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sou,tr);
    return TranslateResult();
}

TranslateResult struct_declaration_list_struct_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sd,tr);
    return TranslateResult();
}

TranslateResult struct_declaration_list_struct_declaration_list_struct_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sdl,tr1);
    TRANSLATE(m_sd,tr2);
    return TranslateResult();
}

TranslateResult struct_declaration_list_anonymous_struct_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sd,tr);
    return TranslateResult();
}

TranslateResult struct_declaration_list_struct_declaration_list_anonymous_struct_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sdl,tr1);
    TRANSLATE(m_sd,tr2);
    return TranslateResult();
}

TranslateResult anonymous_struct_declaration_specifier_qualifier_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sql,tr);
    return TranslateResult();
}

TranslateResult struct_declaration_specifier_qualifier_list_struct_declarator_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sql,tr1);
    TRANSLATE(m_sdl,tr2);
    return TranslateResult();
}

TranslateResult struct_declarator_list_struct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_sd,tr);
    return TranslateResult();
}

TranslateResult struct_declarator_list_struct_declarator_list_struct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_sdl,tr1);
    TRANSLATE(m_sd,tr2);
    return TranslateResult();
}

TranslateResult struct_declarator_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_d,tr);
    return TranslateResult();
}
TranslateResult struct_declarator_constant_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ce,tr);
    return TranslateResult();
}

TranslateResult struct_declarator_declarator_constant_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_d,tr1);
    TRANSLATE(m_ce,tr2);
    return TranslateResult();
}

TranslateResult parameter_declaration_declaration_specifiers_abstract_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ds,tr1);
    TRANSLATE(m_ad,tr2);
    return TranslateResult();
}

TranslateResult enum_specifier_enumerator_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_el,tr);
    return TranslateResult();
}

TranslateResult enum_specifier_identifier_enumerator_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_el,tr);
    return TranslateResult();
}

TranslateResult enum_specifier_enumerator_list_comma::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_el,tr);
    return TranslateResult();
}

TranslateResult enum_specifier_identifier_enumerator_list_comma::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_el,tr);
    return TranslateResult();
}

TranslateResult enumerator_list_enumerator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_e,tr);
    return TranslateResult();
}

TranslateResult enumerator_list_enumerator_list_enumerator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_el,tr1);
    TRANSLATE(m_e,tr2);
    return TranslateResult();
}

TranslateResult declarator_pointer_direct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_p,tr1);
    TRANSLATE(m_dd,tr2);
    return TranslateResult();
}

TranslateResult declarator_direct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_dd,tr);
    if(g_gcc_compatible) {
        if(m_proxy_explicit_call_conv) {
            add_explicit_call_conv(get_call_conv());
        }
    }
    return TranslateResult();
}

TranslateResult declarator_pointer_call_conv_specifier_direct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_p,tr1);
    TRANSLATE(m_ccs,tr2);
    TRANSLATE(m_dd,tr3);

    m_post_translate = true;

    return TranslateResult();
}

TranslateResult declarator_call_conv_specifier_pointer_direct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_ccs,tr1);
    TRANSLATE(m_p,tr2);
    TRANSLATE(m_dd,tr3);

    m_post_translate = true;

    return TranslateResult();
}

TranslateResult declarator_call_conv_specifier_direct_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ccs,tr1);
    TRANSLATE(m_dd,tr2);

    return TranslateResult();
}

TranslateResult direct_declarator_paren_declarator::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_d,tr);

    if(!g_gcc_compatible) {
        AST_node *parent = get_parent();
        if(dynamic_cast<direct_declarator_direct_declarator_empty_paren*>(parent) ||
           dynamic_cast<direct_declarator_direct_declarator_parameter_type_list*>(parent)) {
            if(!g_intel64) {
                m_d->add_explicit_call_conv(m_d->get_call_conv());
                suppress_declarator_explicit_call_conv();
            }
        }
    } else {
//        print();
//        printf("\n FIX FIX FIX\n");
    }

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_tql,tr2);
    TRANSLATE(m_ae,tr3);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_type_qualifier_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_tql,tr2);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_ae,tr2);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_tql,tr2);
    TRANSLATE(m_ae,tr3);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_tql,tr2);
    TRANSLATE(m_ae,tr3);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_type_qualifier_list_star::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_tql,tr2);

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_parameter_type_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_ptl,tr2);

    PILLAR2C_CALLCONV cc = ST_NOT_DEFINED;
    direct_declarator_paren_declarator *ddpd = dynamic_cast<direct_declarator_paren_declarator *>(m_dd);

    if(g_gcc_compatible) {
        AST_node *this_parent = get_parent();
        declarator *decl = dynamic_cast<declarator*>(this_parent);
        if(decl) {
            decl->proxy_explicit_call_conv();
        } else {
            this_parent->get_parent()->print();
            printf("\n");
            aeprintf("Don't know how to handle non-declarator parent in direct_declarator_direct_declarator_empty_paren\n");
        }

        if(ddpd) {
//            this_parent->print();
//            printf("\n");
            cc = this_parent->get_call_conv_down();
        }
    }
    if(cc == ST_NOT_DEFINED) {
        cc = get_call_conv();
    }
    assert(cc != ST_NOT_DEFINED);
    if(ddpd) {
        if(!g_gcc_compatible) {
            ddpd->add_explicit_call_conv(cc);
        }
    }
    if((cc == ST_PDECL)) {
        std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE>::iterator iter;
        iter = g_pillar_runtime_funcs.find(m_dd->get_name());
        if(iter == g_pillar_runtime_funcs.end()) {
            std::map<std::string,function_definition *>::iterator fmiter;
            fmiter = g_func_map.find(m_dd->get_name());
            if(fmiter == g_func_map.end()) {
                parameter_list *extra_params = gen_extra_params();
                prepend_params(extra_params);
            } else {
                if(!fmiter->second->is_gc_safe()) {
                    parameter_list *extra_params = gen_extra_params();
                    prepend_params(extra_params);
                }
            }
        }
    }

    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_identifier_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_dd,tr1);
    TRANSLATE(m_il,tr2);

    return TranslateResult();
}

TranslateResult parameter_list_parameter_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_pd,tr);
    return TranslateResult();
}

TranslateResult parameter_list_parameter_list_parameter_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_pl,tr1);
    TRANSLATE(m_pd,tr2);
    return TranslateResult();
}

TranslateResult initializer_initializer_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_il,tr);
    return TranslateResult();
}

TranslateResult initializer_initializer_list_comma::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_il,tr);
    return TranslateResult();
}

TranslateResult initializer_list_designation_initializer::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_d,tr1);
    TRANSLATE(m_i,tr2);
    return TranslateResult();
}

TranslateResult initializer_list_initializer_list_designation_initializer::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;
    TRANSLATE(m_il,tr1);
    TRANSLATE(m_d,tr2);
    TRANSLATE(m_i,tr3);
    return TranslateResult();
}

// All labeled statements created new basic blocks so a labeled statement can never be statically determined to be dead code.
TranslateResult statement_labeled_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    TRANSLATE(m_s,tr);

    generate_filters(fd);

    return tr;
}

// Returns true if this code is dead and was eliminated.
bool eliminate_dead_code(statement *s) {
    function_definition *fd = s->find_enclosing_function();
    assert(fd);
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(!cur_bb && g_eliminate_dead_code) {
        // dead code here
        block_item *bi = dynamic_cast<block_item *>(s->get_parent());
        assert(bi);
        block_item_list *bil = dynamic_cast<block_item_list *>(bi->get_parent());
        assert(bil);
        bil->remove_and_delete();
        return true;
    }
    return false;
}

TranslateResult statement_compound_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
//    if(!eliminate_dead_code(this)) {
        TRANSLATE(m_s,tr);
//    }
    assert(m_cuts_to.size() == 0);

    return tr;
}

TranslateResult statement_PRT_NOYIELD_compound_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    if(!eliminate_dead_code(this)) {
        m_post_translate = true;
        TRANSLATE(m_s,tr);
    }
    assert(m_cuts_to.size() == 0);

    return tr;
}

TranslateResult statement_PRT_VSE_compound_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    if(!eliminate_dead_code(this)) {
        m_post_translate = true;
        TRANSLATE(m_s,tr);
    }

    assert(m_cuts_to.size() == 0);

    return tr;
}

TranslateResult statement_selection_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    if(!eliminate_dead_code(this)) {
        TRANSLATE(m_s,tr);
        generate_filters(fd);
    }

    return tr;
}

TranslateResult statement_iteration_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    if(!eliminate_dead_code(this)) {
        TRANSLATE(m_s,tr);
        generate_filters(fd);
    }

    return tr;
}

TranslateResult statement_jump_statement::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;
    if(!eliminate_dead_code(this)) {
        TRANSLATE(m_s,tr);
        // The prt cut to translation code relies on nothing being done here (after the m_s->translate_pillar).
        generate_filters(fd);
    }

    return tr;
}

TranslateResult call_expression_postfix_expression_paren_argument_expression_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    add_vse_continuations_to_cuts(fd);
    if(m_id_vec.size()) {
        add_to_statement_cut(m_id_vec);

        if(!fd->m_has_except_var) {
            fd->m_has_except_var = true;

            block_item_list *bil =
                new block_item_list_block_item(
                    new block_item_text(std::string("void *_pillar2c_except_var;\n"))
                );

            fd->prepend_bil(bil);
        }
    }
    TRANSLATE(m_pe,tr1);
    TRANSLATE(m_ael,tr2);

    if(g_expression_type) {
        expression_type *ret_type = get_return_type();
        return TranslateResult(auto_ptr<expression_type>(ret_type));
    } else {
        return TranslateResult();
    }
}

//==========================================================================

// DESTRUCTORS

primary_expression_expression::~primary_expression_expression(void) {
    delete m_e;
}

postfix_expression_postfix_expression_brace_expression::~postfix_expression_postfix_expression_brace_expression(void) {
    delete m_pe;
    delete m_e;
}

postfix_expression_call_expression::~postfix_expression_call_expression(void) {
    delete m_ce;
}

postfix_expression_postfix_expression_paren_argument_expression_list::~postfix_expression_postfix_expression_paren_argument_expression_list(void) {
    delete m_pe;
    delete m_ael;
}

postfix_expression_type_name_initializer_list::~postfix_expression_type_name_initializer_list(void) {
    delete m_tn;
    delete m_il;
}

postfix_expression_type_name_initializer_list_comma::~postfix_expression_type_name_initializer_list_comma(void) {
    delete m_tn;
    delete m_il;
}

call_expression_postfix_expression_paren_argument_expression_list::~call_expression_postfix_expression_paren_argument_expression_list(void) {
    delete m_pe;
    delete m_ael;
}

argument_expression_list_assignment_expression::~argument_expression_list_assignment_expression(void) {
    delete m_ae;
}

argument_expression_list_argument_expression_list_assignment_expression::~argument_expression_list_argument_expression_list_assignment_expression(void) {
    delete m_ael;
    delete m_ae;
}

unary_expression_unary_operator_cast_expression::~unary_expression_unary_operator_cast_expression(void) {
    delete m_uo;
    delete m_ce;
}

unary_expression_sizeof_type_name::~unary_expression_sizeof_type_name(void) {
    delete m_tn;
}

cast_expression_type_name_cast_expression::~cast_expression_type_name_cast_expression(void) {
    delete m_tn;
    delete m_ce;
}

conditional_expression_logical_or_expression_expression_conditional_expression::~conditional_expression_logical_or_expression_expression_conditional_expression(void) {
    delete m_loe;
    delete m_e;
    delete m_ce;
}

assignment_expression_unary_expression_assignment_operator_assignment_expression::~assignment_expression_unary_expression_assignment_operator_assignment_expression(void) {
    delete m_ue;
    delete m_ao;
    delete m_ae;
}

void assignment_expression_unary_expression_assignment_operator_assignment_expression::add_rhs_cast(type_name *the_cast) {
	replace(m_ae, expr_gen(assignment_expression,cast_expression,
                                new cast_expression_type_name_cast_expression(
                                    the_cast,
                                    expr_gen(cast_expression,postfix_expression,
									new postfix_expression_primary_expression(
                                    new primary_expression_expression(
                                    new expression_assignment_expression(m_ae)))))));
}


void assignment_expression_unary_expression_assignment_operator_assignment_expression::add_volatile_void_rhs_cast() {
	type_name *the_cast = new type_name_specifier_qualifier_list_abstract_declarator(
							new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
                            new type_qualifier_volatile(),
				            new specifier_qualifier_list_type_specifier(new type_specifier_VOID())),
							new abstract_declarator_pointer(new pointer_star()));
    add_rhs_cast(the_cast);
}

TranslateResult assignment_expression_unary_expression_assignment_operator_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;

    // the order here is important so that refs that are encountered are processed in execution order
    TRANSLATE(m_ae,tr1);
    TRANSLATE(m_ao,tr2);
    TRANSLATE(m_ue,tr3);

    primary_expression_identifier *ae_exp = (primary_expression_identifier*)m_ae->is_mainline(typeid(primary_expression_identifier));
    primary_expression_identifier *ue_exp = (primary_expression_identifier*)m_ue->is_mainline(typeid(primary_expression_identifier));
    // Both ae and ue are simple expressions ending with identifier and the operator is "=",
    // so this statement is of the form "a = b;"
    if(ae_exp && ue_exp && dynamic_cast<assignment_operator_equal*>(m_ao)) {
        ii_ptr ae_ii = ae_exp->get_symbol(); // right-hand side
        ii_ptr ue_ii = ue_exp->get_symbol(); // left-hand  side
        if(ae_ii->has_ref_index() && ue_ii->has_ref_index()) {
            // Get the function that this function call takes place in.
            assert(fd);
            fd->m_ref_assignments->insert(std::pair<unsigned,ref_assignment_data>(ue_ii->get_ref_index(),ref_assignment_data(ae_ii->get_ref_index(),this)));
        }
    }

    if(g_check_ref_write_barrier && !fd->is_gc_safe()) {
        auto_ptr<expression_type> apet(m_ue->get_type());
        if(!apet.get()) {
            m_ue->print();
            printf("\n");
            aeprintf("Could not get the expression type in assignment_expression_unary_expression_assignment_operator_assignment_expression\nfor the above expression in file %s at line %d\n",fd->get_symbol()->get_name(),get_line_number());
        }
        if( dynamic_cast<assignment_operator_equal*>(m_ao)) {
            if(!ue_exp || !ue_exp->get_symbol()->has_ref_index()) {
                if(apet->is_ultimate_prt_ref()) {
                    m_ue->print();
                    printf("\n");
                    printf("Warning: write to a ref without a write barrier in %s, line %d\n",fd->get_symbol()->get_name(),get_line_number());
                }
            }
        }
    }

    return tr1;
}

declaration_declaration_specifiers::~declaration_declaration_specifiers(void) {
    delete m_ds;
}

declaration_declaration_specifiers_init_declarator_list::~declaration_declaration_specifiers_init_declarator_list(void) {
    delete m_ds;
    delete m_idl;
}

declaration_specifiers_type_specifier::~declaration_specifiers_type_specifier(void) {
    delete m_ts;
}

declaration_specifiers_type_specifier_declaration_specifiers::~declaration_specifiers_type_specifier_declaration_specifiers(void) {
    delete m_ts;
    delete m_ds;
}

declaration_specifiers_mrv::~declaration_specifiers_mrv(void) {
    delete m_ts;
}

declaration_specifiers_mrv_declaration_specifiers::~declaration_specifiers_mrv_declaration_specifiers(void) {
    delete m_ts;
    delete m_ds;
}

declaration_specifiers_type_qualifier::~declaration_specifiers_type_qualifier(void) {
    delete m_tq;
}

declaration_specifiers_type_qualifier_declaration_specifiers::~declaration_specifiers_type_qualifier_declaration_specifiers(void) {
    delete m_tq;
    delete m_ds;
}

declaration_specifiers_function_specifier::~declaration_specifiers_function_specifier(void) {
    delete m_fs;
}

declaration_specifiers_function_specifier_declaration_specifiers::~declaration_specifiers_function_specifier_declaration_specifiers(void) {
    delete m_fs;
    delete m_ds;
}

declaration_specifiers_gcc_attribute_declaration_specifiers::~declaration_specifiers_gcc_attribute_declaration_specifiers(void) {
    delete m_ds;
}

direct_declarator_paren_declarator::~direct_declarator_paren_declarator(void) {
    delete m_d;
}

direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::~direct_declarator_direct_declarator_type_qualifier_list_assignment_expression(void) {
    delete m_dd;
    delete m_tql;
    delete m_ae;
}

direct_declarator_direct_declarator_type_qualifier_list::~direct_declarator_direct_declarator_type_qualifier_list(void) {
    delete m_dd;
    delete m_tql;
}

direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::~direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression(void) {
    delete m_dd;
    delete m_tql;
    delete m_ae;
}

direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::~direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression(void) {
    delete m_dd;
    delete m_tql;
    delete m_ae;
}

direct_declarator_direct_declarator_parameter_type_list::~direct_declarator_direct_declarator_parameter_type_list(void) {
    delete m_dd;
    delete m_ptl;
}

direct_declarator_direct_declarator_type_qualifier_list_star::~direct_declarator_direct_declarator_type_qualifier_list_star(void) {
    delete m_dd;
    delete m_tql;
}

direct_declarator_direct_declarator_identifier_list::~direct_declarator_direct_declarator_identifier_list(void) {
    delete m_dd;
    delete m_il;
}

declarator_pointer_direct_declarator::~declarator_pointer_direct_declarator(void) {
    delete m_p;
    delete m_dd;
}

declarator_pointer_call_conv_specifier_direct_declarator::~declarator_pointer_call_conv_specifier_direct_declarator(void) {
    delete m_p;
    delete m_ccs;
    delete m_dd;
}

declarator_call_conv_specifier_pointer_direct_declarator::~declarator_call_conv_specifier_pointer_direct_declarator(void) {
    delete m_ccs;
    delete m_p;
    delete m_dd;
}

declarator_call_conv_specifier_direct_declarator::~declarator_call_conv_specifier_direct_declarator(void) {
    delete m_ccs;
    delete m_dd;
}

type_specifier_struct_or_union_specifier::~type_specifier_struct_or_union_specifier(void) {
    delete m_sous;
}

init_declarator_declarator_initializer::~init_declarator_declarator_initializer(void) {
    delete m_i;
}

type_specifier_enum_specifier::~type_specifier_enum_specifier(void) {
    delete m_es;
}

struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list::~struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(void) {
    delete m_sou;
    delete m_sdl;
}

struct_or_union_specifier_struct_or_union_struct_declaration_list::~struct_or_union_specifier_struct_or_union_struct_declaration_list(void) {
    delete m_sou;
    delete m_sdl;
}

struct_or_union_specifier_struct_or_union_identifier::~struct_or_union_specifier_struct_or_union_identifier(void) {
    delete m_sou;
}

struct_declaration_list_struct_declaration::~struct_declaration_list_struct_declaration(void) {
    delete m_sd;
}

struct_declaration_list_struct_declaration_list_struct_declaration::~struct_declaration_list_struct_declaration_list_struct_declaration(void) {
    delete m_sdl;
    delete m_sd;
}

struct_declaration_list_anonymous_struct_declaration::~struct_declaration_list_anonymous_struct_declaration(void) {
    delete m_sd;
}

struct_declaration_list_struct_declaration_list_anonymous_struct_declaration::~struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(void) {
    delete m_sdl;
    delete m_sd;
}

struct_declaration_specifier_qualifier_list_struct_declarator_list::~struct_declaration_specifier_qualifier_list_struct_declarator_list(void) {
    delete m_sql;
    delete m_sdl;
}

anonymous_struct_declaration_specifier_qualifier_list::~anonymous_struct_declaration_specifier_qualifier_list(void) {
    delete m_sql;
}

specifier_qualifier_list_type_qualifier_specifier_qualifier_list::~specifier_qualifier_list_type_qualifier_specifier_qualifier_list(void) {
    delete m_tq;
    delete m_ql;
}

specifier_qualifier_list_type_qualifier::~specifier_qualifier_list_type_qualifier(void) {
    delete m_tq;
}

struct_declarator_list_struct_declarator::~struct_declarator_list_struct_declarator(void) {
    delete m_sd;
}

struct_declarator_list_struct_declarator_list_struct_declarator::~struct_declarator_list_struct_declarator_list_struct_declarator(void) {
    delete m_sdl;
    delete m_sd;
}

enum_specifier_enumerator_list::~enum_specifier_enumerator_list(void) {
    delete m_el;
}

enum_specifier_identifier_enumerator_list::~enum_specifier_identifier_enumerator_list(void) {
    delete m_el;
}

enum_specifier_enumerator_list_comma::~enum_specifier_enumerator_list_comma(void) {
    delete m_el;
}

enum_specifier_identifier_enumerator_list_comma::~enum_specifier_identifier_enumerator_list_comma(void) {
    delete m_el;
}

enumerator_list_enumerator::~enumerator_list_enumerator(void) {
    delete m_e;
}

enumerator_list_enumerator_list_enumerator::~enumerator_list_enumerator_list_enumerator(void) {
    delete m_el;
    delete m_e;
}

pointer_star_type_qualifier_list::~pointer_star_type_qualifier_list(void) {
    delete m_tql;
}

pointer_star_type_qualifier_list_pointer::~pointer_star_type_qualifier_list_pointer(void) {
    delete m_tql;
    delete m_p;
}

parameter_list_parameter_declaration::~parameter_list_parameter_declaration(void) {
    delete m_pd;
}

parameter_list_parameter_list_parameter_declaration::~parameter_list_parameter_list_parameter_declaration(void) {
    delete m_pl;
    delete m_pd;
}

parameter_declaration_declaration_specifiers_abstract_declarator::~parameter_declaration_declaration_specifiers_abstract_declarator(void) {
    delete m_ds;
    delete m_ad;
}

type_name_specifier_qualifier_list_abstract_declarator::~type_name_specifier_qualifier_list_abstract_declarator(void) {
    delete m_sql;
    delete m_ad;
}

abstract_declarator_direct_abstract_declarator::~abstract_declarator_direct_abstract_declarator(void) {
    delete m_dad;
}

abstract_declarator_pointer_direct_abstract_declarator::~abstract_declarator_pointer_direct_abstract_declarator(void) {
    delete m_p;
    delete m_dad;
}

abstract_declarator_call_conv_specifier_direct_abstract_declarator::~abstract_declarator_call_conv_specifier_direct_abstract_declarator(void) {
    delete m_ccs;
    delete m_dad;
}

abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::~abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(void) {
    delete m_ccs;
    delete m_p;
    delete m_dad;
}

initializer_initializer_list::~initializer_initializer_list(void) {
    delete m_il;
}

initializer_initializer_list_comma::~initializer_initializer_list_comma(void) {
    delete m_il;
}

initializer_list_designation_initializer::~initializer_list_designation_initializer(void) {
    delete m_d;
    delete m_i;
}

initializer_list_initializer_list_designation_initializer::~initializer_list_initializer_list_designation_initializer(void) {
    delete m_il;
    delete m_d;
    delete m_i;
}

statement_labeled_statement::~statement_labeled_statement(void) {
    delete m_s;
}

statement_compound_statement::~statement_compound_statement(void) {
    delete m_s;
}

statement_PRT_NOYIELD_compound_statement::~statement_PRT_NOYIELD_compound_statement(void) {
    delete m_s;
}

statement_PRT_VSE_compound_statement::~statement_PRT_VSE_compound_statement(void) {
    delete m_s;
}

statement_expression_statement::~statement_expression_statement(void) {
    delete m_s;
}

statement_selection_statement::~statement_selection_statement(void) {
    delete m_s;
}

statement_iteration_statement::~statement_iteration_statement(void) {
    delete m_s;
}

statement_jump_statement::~statement_jump_statement(void) {
    delete m_s;
}

//==========================================================================

call_conv_specifier * gen_call_conv_specifier(PILLAR2C_CALLCONV cc) {
    call_conv_specifier *ccs = NULL;
    switch(cc) {
    case ST_CDECL:
        ccs = new call_conv_specifier_CDECL;
        break;
    case ST_STDCALL:
        ccs = new call_conv_specifier_STDCALL;
        break;
    case ST_PCDECL:
        ccs = new call_conv_specifier_PRT_PCDECL;
        ccs->translate_pillar(NULL);
        break;
    case ST_PDECL:
        ccs = new call_conv_specifier_PRT_PDECL;
        ccs->translate_pillar(NULL);
        break;
    default:
        aeprintf("Don't know how to convert %d in add_explicit_call_conv.\n",cc);
        fflush(stdout);
    }

    return ccs;
}

declarator * declarator_direct_declarator::add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
    if(!m_suppress_explicit_call_conv) {
        direct_declarator_paren_declarator *ddpd = dynamic_cast<direct_declarator_paren_declarator*>(m_dd);
        if(ddpd) {
            if(ddpd->is_pointer()) {
                ddpd->add_explicit_call_conv(cc);
                return this;
            }
        }
        declarator_call_conv_specifier_direct_declarator *new_node = NULL;
        call_conv_specifier *ccs = gen_call_conv_specifier(cc);
        new_node = new declarator_call_conv_specifier_direct_declarator(ccs,m_dd,m_s);
        m_parent->replace(this,new_node);
        m_dd = NULL;
        delete this;
        return new_node;
    }
    return this;
}

declarator * declarator_pointer_direct_declarator::add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
    if(!m_suppress_explicit_call_conv) {
        if(dynamic_cast<direct_declarator_paren_declarator*>(get_parent())) {
            declarator_call_conv_specifier_pointer_direct_declarator *new_node = NULL;
            call_conv_specifier *ccs = gen_call_conv_specifier(cc);
            assert(ccs);
            new_node = new declarator_call_conv_specifier_pointer_direct_declarator(ccs,m_p,m_dd,m_s);
            m_parent->replace(this,new_node);
            m_dd = NULL;
            m_p = NULL;
            delete this;
            return new_node;
        } else {
            declarator_pointer_call_conv_specifier_direct_declarator *new_node = NULL;
            call_conv_specifier *ccs = gen_call_conv_specifier(cc);
            assert(ccs);
            new_node = new declarator_pointer_call_conv_specifier_direct_declarator(m_p,ccs,m_dd,m_s);
            m_parent->replace(this,new_node);
            m_dd = NULL;
            m_p = NULL;
            delete this;
            return new_node;
        }
    }
    return this;
}

std::list<ii_ptr > AST_node::get_enclosing_symbols(void) {
    if(m_parent) {
        return m_parent->get_enclosing_symbols();
    } else {
        return std::list<ii_ptr>();
    }
}

function_definition * AST_node::find_enclosing_function(void) const {
    if(m_parent) {
        return m_parent->find_enclosing_function();
    } else {
        return NULL;
    }
}

unsigned AST_node::get_line_number(void) const {
    if(m_parent) {
        return m_parent->get_line_number();
    } else {
        return NULL;
    }
}

call_expression * call_expression_postfix_expression_paren_argument_expression_list::prepend_arg_list(argument_expression_list *ael) {
    m_ael = m_ael->prepend_arg_list(ael);
    return this;
}

call_expression * call_expression_postfix_expression_paren_argument_expression_list::append_arg_list(argument_expression_list *ael) {
    argument_expression_list *save = m_ael;
    m_ael = ael;
    m_ael = m_ael->prepend_arg_list(save);
    return this;
}

call_expression * call_expression_postfix_expression_empty_paren::prepend_arg_list(argument_expression_list *ael) {
    call_expression_postfix_expression_paren_argument_expression_list *new_node = new call_expression_postfix_expression_paren_argument_expression_list(m_pe,ael);

    m_parent->replace(this,new_node);

    m_pe = NULL;
    delete this;

    return new_node;
}

argument_expression_list * argument_expression_list_assignment_expression::prepend_arg_list(argument_expression_list *ael) {
    argument_expression_list_argument_expression_list_assignment_expression * new_node = new argument_expression_list_argument_expression_list_assignment_expression(ael,m_ae);

//    m_parent->replace(this,new_node);

    m_ae = NULL;
    delete this;

    return new_node;
}

direct_declarator * direct_declarator_direct_declarator_empty_paren::prepend_params(parameter_list *pl) {
    direct_declarator_direct_declarator_parameter_type_list *new_node =
       new direct_declarator_direct_declarator_parameter_type_list(m_dd,new parameter_type_list_parameter_list(pl));

    std::list<ii_ptr > symbols = get_enclosing_symbols();
    std::list<ii_ptr >::iterator sym_iter;
    assert(symbols.size() == 1);
#ifndef NODE_INFO_LINK
    for(sym_iter  = symbols.begin();
        sym_iter != symbols.end();
        ++sym_iter) {
        if((*sym_iter)->get_func_decl()) {
            if((*sym_iter)->get_func_decl() == this) {
                (*sym_iter)->set_func_decl(new_node);
            } else {
                aeprintf("Expected sym_iter->get_func_decl() to equal this in prepend_params.\n");
            }
        }
    }
#endif // NODE_INFO_LINK

    m_parent->replace(this,new_node);

    m_dd = NULL;
    delete this;
    return new_node;
}

direct_declarator * direct_declarator_direct_declarator_parameter_type_list::prepend_params(parameter_list *pl) {
    m_ptl->prepend_params(pl);
    return this;
}

void parameter_list_parameter_declaration::prepend_params(parameter_list *pl) {
    parameter_list_parameter_list_parameter_declaration *new_node =
       new parameter_list_parameter_list_parameter_declaration(pl,m_pd);

    m_parent->replace(this,new_node);

    m_pd = NULL;
    delete this;
}

std::list<ii_ptr > declaration_declaration_specifiers_init_declarator_list::get_enclosing_symbols(void) {
    return m_idl->get_enclosing_symbols();
}

void id_info::print(void) {
    printf("%s ",m_id.c_str());
    bool something_set = false;
    if(m_function) {
       something_set = true;
       if(!m_typedef) {
           printf("IIT_FUNCTION ");
       } else {
           printf("IIT_TYPEDEF_FUNCTION ");
       }
    }
    if(m_function_var) {
       something_set = true;
       printf("IIT_FUNCTION_VAR ");
    }
    if(m_var) {
       something_set = true;
       if(!m_typedef) {
           printf("IIT_VAR ");
       } else {
           printf("IIT_TYPEDEF_VAR ");
       }
       if(type_or_lsi.m_type) {
           type_or_lsi.m_type->print();
       }
    }
    if(m_struct_enum_tag) {
       something_set = true;
       printf("IIT_STRUCT_ENUM ");
    }
    if(m_param) {
       something_set = true;
       printf("IIT_PARAM ");
    }
    if(!something_set) {
       printf("IIT_NONE ");
    }
    printf("\n");
    printf("CC = %s\n",cc_to_str(m_cc));
    if(type_or_lsi.m_type) {
        printf("TYPE = ");
        type_or_lsi.m_type->print();
    }
#ifdef SINGLE_DECLARATOR
    if(m_d) {
        printf("DECLARATOR = ");
        m_d->print();
    }
#else
    std::list<declarator*>::iterator decl_iter;
    for(decl_iter  = m_d.begin();
        decl_iter != m_d.end();
        decl_iter++) {
        printf("DECLARATOR = ");
        (*decl_iter)->print();
    }
#endif
    if(m_param_decl) {
        printf("PARAM_DECL = ");
        m_param_decl->print();
    }
    if(m_func_decl) {
        printf("FUNC DECL = ");
        m_func_decl->print();
    }
    if(m_fd) {
        printf("FUNC DEF = ");
        m_fd->print();
    }
}

function_refs function_determine_ref_slots(Scope *func_scope, declarator *d) {
    unsigned num_total_refs = 0;
    unsigned num_total_vars = 0;

    std::queue<Scope *> scopes_to_flatten;
    scopes_to_flatten.push(func_scope);

    function_refs ret;

    // For each scope that is a part of this function.
    while(scopes_to_flatten.size()) {
        Scope *scope_to_flatten = scopes_to_flatten.front();
        scopes_to_flatten.pop();

        // Iterate over the symbols defined in that scope.
        map_str_ii::iterator miter;
        for(miter  = scope_to_flatten->begin();
            miter != scope_to_flatten->end();
            miter++) {

            ii_ptr ii = miter->second;
            if(g_scope_stack.in_top_scope(ii)) {
                continue;
            }
            // If the symbol is a variable or a parameter.
            if(ii->is_var() || ii->is_param()) {
#if 0
                type_specifier *ts = ii->get_type();
                assert(ts);
                // Is this type ultimately a ref type?
                if(ts->is_ultimate_prt_ref()) {
#else
                auto_ptr<expression_type> apet(ii->get_return_type());
//                auto_ptr<expression_type> apet_base(apet->get_base_type());
//                if(apet_base->is_ultimate_prt_ref()) {
                if(apet->is_ultimate_prt_ref()) {
#endif
#ifdef SINGLE_DECLARATOR
                    declarator *iid = ii->get_declarator();
#else
                    declarator *iid = ii->get_first_declarator();
#endif
                    assert(iid);

                    declarator_direct_declarator *ddd = dynamic_cast<declarator_direct_declarator *>(iid);
                    if(ddd) {
                        direct_declarator *dd = ddd->get_direct_declarator();

                        direct_declarator_IDENTIFIER *ddi = dynamic_cast<direct_declarator_IDENTIFIER *>(dd);
                        if(ddi) {
                            if(ii->is_param()) {
                                ret.m_ref_params.push_back(ii);
                                ii->set_ref_index(num_total_refs++);
                            } else if(ii->is_var()) {
                                ret.m_ref_vars.push_back(ii);
                                ii->set_ref_index(num_total_refs++);
                            }
                            std::stringstream new_name;
                            new_name << "_pillar2c_" << scope_to_flatten->get_unique() << "_" << ii->get_name();
                            ii->set_ref_field_name(new_name.str());
                        } else {
                            aeprintf("Unsupported PRT REF declarator type.\n");
                        }
                    } else {
                        if(!dynamic_cast<declarator_pointer_direct_declarator *>(iid)) {
                            aeprintf("Unsupported PRT REF declarator type.\n");
                        }
                    }
                }

                ii->set_var_index(num_total_vars++);
                ret.m_all_vars.push_back(ii);
            }
        }
        scope_to_flatten->add_children_to_queue(scopes_to_flatten);
#if 0
        check_vector<Scope *> child_scopes = scope_to_flatten->get_child_scopes();
        unsigned i;
        for(i=0; i<child_scopes.size(); ++i) {
            scopes_to_flatten.push(child_scopes[i]);
        }
#endif
    }

    return ret;
} // function_determine_ref_slots

#define REF_INFO_ARRAY

class ref_info {
protected:
    unsigned m_orig_ref_index;
#ifdef REF_INFO_ARRAY
    ref_info **m_conflicts;
    unsigned m_num_others;
#else
    std::set<ref_info *> m_conflicts;
#endif
    unsigned m_new_index;
    bool m_is_param;
public:
#ifdef REF_INFO_ARRAY
    ref_info(unsigned orig_index, bool param, unsigned num_others) : m_orig_ref_index(orig_index), m_new_index(0), m_is_param(param) {
        m_conflicts = new ref_info *[num_others];
        m_num_others = num_others;
        memset(m_conflicts,0,m_num_others * sizeof(ref_info *));
    }

   ~ref_info(void) {
        unsigned i;
        for(i=0;i<m_num_others;++i) {
            if(m_conflicts[i]) {
                m_conflicts[i]->m_conflicts[m_orig_ref_index] = NULL;
            }
        }
        delete [] m_conflicts;
    }

    void add_edge(ref_info *new_conflict) {
        m_conflicts[new_conflict->m_orig_ref_index] = new_conflict;
    }

    bool has_conflict(unsigned orig_index) const {
        unsigned i;
        for(i=0;i<m_num_others;++i) {
            if(m_conflicts[i]) {
                if(m_conflicts[i]->m_orig_ref_index == orig_index) {
                    return true;
                }
            }
        }
        return false;
    }

    unsigned get_num_conflicts(void) const {
        unsigned i, sum = 0;
        for(i=0;i<m_num_others;++i) {
            if(m_conflicts[i]) {
                ++sum;
            }
        }
        return sum;
    }

    unsigned get_lowest_unused_neighbor_index(void) const {
        std::set<unsigned> indices;
        unsigned i;

        for(i=0;i<m_num_others;++i) {
            if(m_conflicts[i]) {
                indices.insert(m_conflicts[i]->get_new_index());
            }
        }
        i = 1;
        while(indices.find(i) != indices.end()) {
            ++i;
        }
        return i;
    }
#else
    ref_info(unsigned orig_index, bool param) : m_orig_ref_index(orig_index), m_new_index(0), m_is_param(param) {}

   ~ref_info(void) {
        std::set<ref_info *>::iterator conflict_iter;
        for(conflict_iter  = m_conflicts.begin();
            conflict_iter != m_conflicts.end();
          ++conflict_iter) {
            (*conflict_iter)->m_conflicts.erase(this);
        }
    }

    void add_edge(ref_info *new_conflict) {
        m_conflicts.insert(new_conflict);
    }

    bool has_conflict(unsigned orig_index) const {
        std::set<ref_info*>::const_iterator conflict_iter;
        for(conflict_iter  = m_conflicts.begin();
            conflict_iter != m_conflicts.end();
          ++conflict_iter) {
            if((*conflict_iter)->m_orig_ref_index == orig_index) {
                return true;
            }
        }
        return false;
    }

    unsigned get_num_conflicts(void) const {
        return (unsigned)m_conflicts.size();
    }

    unsigned get_lowest_unused_neighbor_index(void) const {
        std::set<unsigned> indices;
        unsigned i;
        std::set<ref_info*>::const_iterator citer;
        for(citer  = m_conflicts.begin();
            citer != m_conflicts.end();
          ++citer) {
            indices.insert((*citer)->get_new_index());
        }
        i = 1;
        while(indices.find(i) != indices.end()) {
            ++i;
        }
        return i;
    }
#endif

    unsigned get_old_index(void) const {
        return m_orig_ref_index;
    }

    unsigned get_new_index(void) const {
        return m_new_index;
    }

    void set_new_index(unsigned index) {
        m_new_index = index;
    }

    bool is_param(void) const {
        return m_is_param;
    }
};

bool bb_ref_conflict(unsigned ref_index,unsigned conflict_index,check_vector<basic_block*> &m_basic_blocks) {
    unsigned bb_index;
    size_t bb_size = m_basic_blocks.size();
    for(bb_index = 0; bb_index < bb_size; ++bb_index) {
        basic_block *bb = m_basic_blocks[bb_index];
        if(bb->m_sent_upstream[ref_index]      != 0 &&
           bb->m_sent_upstream[conflict_index] != 0) {
            return true;
        }
    }
    return false;
}

bool conflict_sort(ref_info *a, ref_info *b) {
    if(!a && !b) return false;
    if(!a && b)  return true;
    if(a && !b)  return false;
    return a->get_num_conflicts() > b->get_num_conflicts();
}

struct_declaration * gen_single_struct_declaration(ii_ptr ii) {
    assert(ii->get_ref_field_name());
    if(ii->is_volatile()) {
        return
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
               new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
                 new type_qualifier_volatile(),
                 new specifier_qualifier_list_type_specifier(
                  new type_specifier_VOID()
                 )
               ),
               new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                 new declarator_pointer_direct_declarator(
                  new pointer_star(),
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(ii->get_ref_field_name())
                  )))));
    } else {
        return
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
               new specifier_qualifier_list_type_specifier(
                new type_specifier_VOID()
               ),
               new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                 new declarator_pointer_direct_declarator(
                  new pointer_star(),
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(ii->get_ref_field_name())
                  )))));
    }
}

struct_declaration * gen_multiref_struct_declaration(check_vector<ii_ptr > &vec_ii,unsigned &union_num) {
    struct_declaration_list *latest_named_ref = NULL;

    std::stringstream union_name;
    union_name << "ref_union_" << union_num;
    std::string new_qualified_name;

    latest_named_ref = new struct_declaration_list_struct_declaration(gen_single_struct_declaration(vec_ii[0]));
    new_qualified_name = union_name.str() + "." + std::string(vec_ii[0]->get_ref_field_name());
    vec_ii[0]->set_qualified_ref_field_name(new_qualified_name);

    unsigned index;
    for(index = 1; index < vec_ii.size(); ++index) {
        latest_named_ref = new struct_declaration_list_struct_declaration_list_struct_declaration(latest_named_ref,gen_single_struct_declaration(vec_ii[index]));
        new_qualified_name = union_name.str() + "." + std::string(vec_ii[index]->get_ref_field_name());
        vec_ii[index]->set_qualified_ref_field_name(new_qualified_name);
    }

    ++union_num;

    return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
             new specifier_qualifier_list_type_specifier(
               new type_specifier_struct_or_union_specifier(
                 new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                   new struct_or_union_UNION(),
                   latest_named_ref))),
             new struct_declarator_list_struct_declarator(
               new struct_declarator_declarator(
                 new declarator_direct_declarator(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(union_name.str()))))));
}

bool any_conflicts(const check_vector<ref_info *> &vec_ri,unsigned potential_group_index,unsigned potential_group_member) {
    unsigned i;
    size_t len = vec_ri.size();
    for(i = 0; i < len; ++i) {
        if(vec_ri[i] &&
           vec_ri[i]->get_new_index() == potential_group_index &&
           vec_ri[i]->has_conflict(potential_group_member)) {
            return true;
        }
    }
    return false;
}

class loop {
public:
    class exit_info {
    public:
        basic_block *m_block_with_exit;
        basic_block *m_exit_target;
        EDGE_TYPE    m_type;

        exit_info(basic_block *block, basic_block *target, EDGE_TYPE type) : m_block_with_exit(block), m_exit_target(target), m_type(type) {}
    };

    basic_block * m_header;
    std::set<basic_block *> m_loop_members;
    std::set<unsigned> m_hoisting_candidates;
    std::set<unsigned> m_hoisting_selections;
    std::set<unsigned> m_hoisting_selections_write;
    check_vector<exit_info> m_exits;
    check_vector<loop *> m_immediately_nested_loops;
    map_ref_info m_loop_ref_info;

    loop(basic_block *header) : m_header(header) {
        m_loop_members.insert(header);
        header->m_in_loops.insert(this);
    }

   ~loop(void) {
        std::set<basic_block*>::iterator bb_iter;
        for(bb_iter  = m_loop_members.begin();
            bb_iter != m_loop_members.end();
          ++bb_iter) {
            (*bb_iter)->m_in_loops.erase(this);
        }
    }

    bool in_loop(basic_block *bb) {
        return m_loop_members.find(bb) != m_loop_members.end();
    }

    float get_trip_count_estimate(void) const {
        // FIX FIX FIX ... do something better here.
        return 5.0;
    }

    void modify_refs(unsigned ref_id, ii_ptr hoist_ii) {
        std::set<basic_block*>::iterator member_iter;
        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            std::list<statement*>::iterator item_iter;
            for(item_iter  = (*member_iter)->m_items.begin();
                item_iter != (*member_iter)->m_items.end();
              ++item_iter) {
//                printf("Before: ");
//                (*item_iter)->print();
                (*item_iter)->modify_ref(ref_id,hoist_ii);
//                printf("After: ");
//                (*item_iter)->print();
            }
        }
    }

    void find_exits(void) {
        std::set<basic_block*>::const_iterator member_iter;
        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            unsigned precede_index;
            for(precede_index = 0; precede_index < (*member_iter)->m_can_precede.size(); ++precede_index) {
                if(m_loop_members.find((*member_iter)->m_can_precede[precede_index].m_block) == m_loop_members.end()) {
                    m_exits.push_back(exit_info((*member_iter),
                                                (*member_iter)->m_can_precede[precede_index].m_block,
                                                (*member_iter)->m_can_precede[precede_index].m_type));
                }
            }
        }
    }

    bool is_infinite(void) {
        return m_exits.size() == 0;
    }

    void insert(basic_block *bb, std::stack<basic_block*> &bbs) {
        std::pair<std::set<basic_block*>::iterator, bool> res = m_loop_members.insert(bb);
        if(res.second) {
            // The bb was not present in the set before and was inserted.
            bbs.push(bb);
            bb->m_in_loops.insert(this);
        }
    }

    void merge(const loop *other) {
        // Should only merge loops if they have the same header.
        assert(m_header == other->m_header);

        std::set<basic_block*>::const_iterator member_iter;
        for(member_iter  = other->m_loop_members.begin();
            member_iter != other->m_loop_members.end();
          ++member_iter) {
            m_loop_members.insert(*member_iter);
            (*member_iter)->m_in_loops.erase((loop*)other);
            (*member_iter)->m_in_loops.insert(this);
        }
    }

    bool contains_rare_call(void) {
        std::set<basic_block*>::const_iterator member_iter;
        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            if((*member_iter)->contains_rare_call()) {
                return true;
            }
        }
        return false;
    }

    void get_active_refs(ref_map &used_refs, unsigned m_num_total_refs, unsigned m_num_total_vars, const std::set<ii_ptr > &disable_opts) {
        std::map<void*,ref_map> map_context;
        ref_map empty_ref_map(m_num_total_refs);
        ref_map empty_ref_map_var(m_num_total_vars);

        std::set<basic_block*>::const_iterator member_iter;
        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            (*member_iter)->process_downstream_refs_region(m_loop_members, map_context, empty_ref_map, empty_ref_map_var, disable_opts);
        }

        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            (*member_iter)->mark_callsite_refs_region(m_loop_members, map_context, used_refs);
        }

        for(member_iter  = m_loop_members.begin();
            member_iter != m_loop_members.end();
          ++member_iter) {
            if((*member_iter)->m_freq != BB_FREQ_RARE) {
                (*member_iter)->get_ref_freqs(m_loop_ref_info);
            }
        }
    }
};

loop * extract_loop(basic_block * loop_end, basic_block * loop_header) {
    loop * ret = new loop(loop_header);
    std::stack<basic_block *> bb_to_process;
    ret->insert(loop_end, bb_to_process);

    while(!bb_to_process.empty()) {
        basic_block *this_bb = bb_to_process.top();
        bb_to_process.pop();

        unsigned follow_index;
        for(follow_index = 0; follow_index < this_bb->m_can_follow.size(); ++follow_index) {
            ret->insert(this_bb->m_can_follow[follow_index], bb_to_process);
        }
    }

    ret->find_exits();

    return ret;
}

void compute_dominators(check_vector<basic_block*> &bbs_df_order, unsigned bb_size, basic_block *start_block) {
    bool change_found = true;
    VarBitmask vb;
    vb.set_bit_length(bb_size);
    unsigned bb_index;

    while(change_found) {
        change_found = false;

        for(bb_index = 0; bb_index < bb_size; ++bb_index) {
            if(!bbs_df_order[bb_index]) continue;

            if(bbs_df_order[bb_index] != start_block) {
                if(bbs_df_order[bb_index]->m_can_follow.size()) {
                    vb = bbs_df_order[bb_index]->m_can_follow[0]->m_dom_mask;

                    unsigned follow_index;
                    for(follow_index = 1; follow_index < bbs_df_order[bb_index]->m_can_follow.size(); ++follow_index) {
                        vb.self_intersection(bbs_df_order[bb_index]->m_can_follow[follow_index]->m_dom_mask);
                    }

                    vb.set(bbs_df_order[bb_index]->m_bb_index);
                    if(vb != bbs_df_order[bb_index]->m_dom_mask) {
                        bbs_df_order[bb_index]->m_dom_mask = vb;
                        change_found = true;
                    }
                }
            }
        }
    }
}

void function_definition::do_loop_hoist_optimization(unsigned bb_size,
                                                     const check_vector<basic_block*> &bbs_df_order,
                                                     std::map<basic_block *, loop *> &function_loops,
                                                     ii_ptr * id_orig_index,
                                                     const std::set<ii_ptr > &disable_opts,
                                                     compound_statement * &cs,
                                                     const ref_map &active_refs) {
    unsigned bb_index, ref_index;
    std::map<basic_block *, loop *>::iterator function_loops_iter;

    if(g_loop_hoists) {
        // Find loops in the control-flow graph.
        for(bb_index = 0; bb_index < bb_size; ++bb_index) {
            basic_block *this_bb = bbs_df_order[bb_index];
            if(!this_bb) continue;

            unsigned precede_index;
            for(precede_index = 0; precede_index < this_bb->m_can_precede.size(); ++precede_index) {
                if(this_bb->m_dom_mask.get(this_bb->m_can_precede[precede_index].m_block->m_bb_index)) {
                    loop * l = extract_loop(this_bb, this_bb->m_can_precede[precede_index].m_block);

                    if(!l->contains_rare_call()) {
                        delete l;
                        continue;
                    }

                    ref_map active_in_loop(m_num_total_refs);
                    l->get_active_refs(active_in_loop, m_num_total_refs, m_num_total_vars, disable_opts);

                    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
                        // If there is a ref that is on a rare path in this region but on some common
                        // path elsewhere in the function then add it to the loop as a candidate for
                        // hoisting.
                        //printf("loop header: %p, %d, %d, %s\n",l->m_header,active_in_loop[ref_index],active_refs[ref_index],id_orig_index[ref_index]->get_name());
                        if(active_in_loop[ref_index] == RARE_RVALUE && active_refs[ref_index] == RVALUE) {
                            l->m_hoisting_candidates.insert(ref_index);
                        }
                    }

                    if(!l->m_hoisting_candidates.size()) {
                        delete l;
                        continue;
                    }

                    function_loops_iter = function_loops.find(this_bb->m_can_precede[precede_index].m_block);
                    if(function_loops_iter == function_loops.end()) {
                        function_loops.insert(std::pair<basic_block *,loop *>(this_bb->m_can_precede[precede_index].m_block,l));
                    } else {
                        function_loops_iter->second->merge(l);
                        delete l;
                    }
                }
            }
        }

        if(function_loops.size()) {
            // Sort loops by their depths in both directions.
            std::multimap<unsigned,loop *,std::greater<unsigned> > loop_depths;
            std::multimap<unsigned,loop *> loop_depths_less;
            for(function_loops_iter  = function_loops.begin();
                function_loops_iter != function_loops.end();
              ++function_loops_iter) {
                loop_depths.insert(std::pair<unsigned, loop *>(function_loops_iter->second->m_header->m_in_loops.size(),function_loops_iter->second));
                loop_depths_less.insert(std::pair<unsigned, loop *>(function_loops_iter->second->m_header->m_in_loops.size(),function_loops_iter->second));
            }

            // Determine loop nestings.
            std::multimap<unsigned,loop *>::iterator ld_less_iter;
            for(ld_less_iter  = loop_depths_less.begin();
                ld_less_iter != loop_depths_less.end();
              ++ld_less_iter) {
                // If this is a nested loop and a parent is also in the loop list then add it to the parent's listed of directly
                // nested loops.
                unsigned highest_depth_found = 0;
                loop *prev_nested_loop = NULL;

                std::set<loop *>::iterator in_loop_iter;
                for(in_loop_iter  = ld_less_iter->second->m_header->m_in_loops.begin();
                    in_loop_iter != ld_less_iter->second->m_header->m_in_loops.end();
                  ++in_loop_iter) {
                    if(function_loops.find((*in_loop_iter)->m_header) != function_loops.end() &&
                       ld_less_iter->second != *in_loop_iter &&
                       (*in_loop_iter)->m_loop_members.find(ld_less_iter->second->m_header) != (*in_loop_iter)->m_loop_members.end() &&
                       (*in_loop_iter)->m_header->m_in_loops.size() > highest_depth_found) {
                        highest_depth_found = (*in_loop_iter)->m_header->m_in_loops.size();
                        prev_nested_loop    = (*in_loop_iter);
                    }
                }
                if(prev_nested_loop) {
                    prev_nested_loop->m_immediately_nested_loops.push_back(ld_less_iter->second);
                }
            }

            // Iterate through in reverse order so inner-loops are processed first.
            std::multimap<unsigned,loop *,std::greater<unsigned> >::iterator ld_rev_iter;
            for(ld_rev_iter  = loop_depths.begin();
                ld_rev_iter != loop_depths.end();
              ++ld_rev_iter) {
                unsigned nest_index;
                std::list<std::pair<loop *,unsigned> > nested_hoists;

                // Gather information about which nested loops beneath us are hoisting which refs.
                for(nest_index = 0;
                    nest_index < ld_rev_iter->second->m_immediately_nested_loops.size();
                  ++nest_index) {
                    std::set<unsigned>::iterator nested_hoisted_iter;
                    assert(ld_rev_iter->second->m_immediately_nested_loops[nest_index]->m_hoisting_selections.size() <= 2);

                    for(nested_hoisted_iter  = ld_rev_iter->second->m_immediately_nested_loops[nest_index]->m_hoisting_selections.begin();
                        nested_hoisted_iter != ld_rev_iter->second->m_immediately_nested_loops[nest_index]->m_hoisting_selections.end();
                      ++nested_hoisted_iter) {
                        nested_hoists.push_back(
                               std::pair<loop*,unsigned>(
                                    ld_rev_iter->second->m_immediately_nested_loops[nest_index],
                                    *nested_hoisted_iter));
                    }
                }

                // Try to hoist the same refs that our nested loops hoist.
                std::list<std::pair<loop *,unsigned> >::iterator nh_iter;
                for(nh_iter  = nested_hoists.begin();
                    nh_iter != nested_hoists.end();
                  ++nh_iter) {
                    // We cannot hoist the same refs as our nested loop if that ref is not one of our hoisting candidates.
                    if(ld_rev_iter->second->m_hoisting_candidates.find((*nh_iter).second) == ld_rev_iter->second->m_hoisting_candidates.end()) {
                        continue;
                    }

                    // See if this ref was already added to this loops hoisted selections from a previous nested loop.
                    std::set<unsigned>::iterator already_there = ld_rev_iter->second->m_hoisting_selections.find((*nh_iter).second);
                    // If so, then remove it from that nested loop's hoist selections.
                    if(already_there != ld_rev_iter->second->m_hoisting_selections.end()) {
                        (*nh_iter).first->m_hoisting_selections.erase((*nh_iter).second);
                    } else {
                        // This ref didn't previously exist in the hoist selections.  If we still haven't hoisted 2 refs then
                        // hoist this one.
                        if(ld_rev_iter->second->m_hoisting_selections.size() < 2) {
                            // Add this ref as a hoist selection.
                            ld_rev_iter->second->m_hoisting_selections.insert((*nh_iter).second);
                            if(ld_rev_iter->second->m_loop_ref_info.has_write((*nh_iter).second)) {
                                ld_rev_iter->second->m_hoisting_selections_write.insert((*nh_iter).second);
                            }
                            // Remove it from the inner-loop's hoist selections.
                            (*nh_iter).first->m_hoisting_selections.erase((*nh_iter).second);
                        }
                    }
                }

                std::set<unsigned>::iterator this_loop_hoist_candidate;
                std::multimap<unsigned,unsigned,std::greater<unsigned> > most_used_refs;
                for(this_loop_hoist_candidate  = ld_rev_iter->second->m_hoisting_candidates.begin();
                    this_loop_hoist_candidate != ld_rev_iter->second->m_hoisting_candidates.end();
                  ++this_loop_hoist_candidate) {
#ifndef RANDOM_HOIST
                    most_used_refs.insert(std::pair<unsigned,unsigned>(ld_rev_iter->second->m_loop_ref_info.get_total(*this_loop_hoist_candidate),*this_loop_hoist_candidate));
#else
                    if(ld_rev_iter->second->m_hoisting_selections.size() < 2) {
                        // Add this ref as a hoist selection.
                        ld_rev_iter->second->m_hoisting_selections.insert(*this_loop_hoist_candidate);
                        if(ld_rev_iter->second->m_loop_ref_info.has_write(*this_loop_hoist_candidate)) {
                            ld_rev_iter->second->m_hoisting_selections_write.insert(*this_loop_hoist_candidate);
                        }
                    }
#endif
                }

#ifndef RANDOM_HOIST
                std::multimap<unsigned,unsigned,std::greater<unsigned> >::iterator mur_iter;
                // Fill any unfilled hoisting selections with refs present only in our hoisting candidates.
                for(mur_iter  = most_used_refs.begin();
                    mur_iter != most_used_refs.end();
                  ++mur_iter) {
                    if(ld_rev_iter->second->m_hoisting_selections.size() < 2) {
                        // Add this ref as a hoist selection.
                        ld_rev_iter->second->m_hoisting_selections.insert((*mur_iter).second);
                        if(ld_rev_iter->second->m_loop_ref_info.has_write((*mur_iter).second)) {
                            ld_rev_iter->second->m_hoisting_selections_write.insert((*mur_iter).second);
                        }
                    }
                }
#endif
            }

            printf("FUNCTION =====> %s\n",m_ii->get_name());
            printf("==================================================\n");
            for(function_loops_iter  = function_loops.begin();
                function_loops_iter != function_loops.end();
              ++function_loops_iter) {
                printf("Loop headed by %p, nested level = %d\n",
                    function_loops_iter->second->m_header,
                    function_loops_iter->second->m_header->m_in_loops.size());

                printf("Loop entrances\n------------\n");
                unsigned follow_index;
                for(follow_index = 0; follow_index < function_loops_iter->second->m_header->m_can_follow.size(); ++follow_index) {
                    if(function_loops_iter->second->m_loop_members.find(function_loops_iter->second->m_header->m_can_follow[follow_index]) == function_loops_iter->second->m_loop_members.end()) {
                        printf("%p, edge_type = %s\n",
                            function_loops_iter->second->m_header->m_can_follow[follow_index],
                            edge_to_str(function_loops_iter->second->m_header->m_can_follow[follow_index]->get_edge_type(function_loops_iter->second->m_header)));
                    }
                }

                printf("Loop exits\n---------\n");
                unsigned exit_index;
                for(exit_index = 0; exit_index < function_loops_iter->second->m_exits.size(); ++exit_index) {
                    basic_block *exit_target = function_loops_iter->second->m_exits[exit_index].m_exit_target;
                    printf("%p ====(%s)====> %p\n",
                        function_loops_iter->second->m_exits[exit_index].m_block_with_exit,
                        edge_to_str(function_loops_iter->second->m_exits[exit_index].m_type),
                        exit_target);
                    unsigned et_follow;
                    for(et_follow = 0;
                        et_follow < exit_target->m_can_follow.size();
                      ++et_follow) {
                        if(function_loops_iter->second->m_loop_members.find(exit_target->m_can_follow[et_follow]) == function_loops_iter->second->m_loop_members.end()) {
                            aeprintf("Can get to loop exit target through a non-loop path.\n");
                        }
                    }
                }

                if(function_loops_iter->second->m_header->m_in_loops.size() > 1) {
                    std::set<loop *>::iterator in_loop_iter;
                    printf("Nested in loops headed by: ");
                    for(in_loop_iter  = function_loops_iter->second->m_header->m_in_loops.begin();
                        in_loop_iter != function_loops_iter->second->m_header->m_in_loops.end();
                      ++in_loop_iter) {
                        printf("%p(%d) ",(*in_loop_iter)->m_header,(*in_loop_iter)->m_header->m_in_loops.size());
                    }
                    printf("\n");
                }

                std::set<basic_block*>::iterator loop_member_check;
                for(loop_member_check  = function_loops_iter->second->m_loop_members.begin();
                    loop_member_check != function_loops_iter->second->m_loop_members.end();
                  ++loop_member_check) {
                    if(!(*loop_member_check)->m_dom_mask.get(function_loops_iter->second->m_header->m_bb_index)) {
                        aeprintf("Member of a loop found that isn't dominated by the loop header.\n");
                    }
                }

                std::set<unsigned>::iterator hoist_iter;
                for(hoist_iter  = function_loops_iter->second->m_hoisting_candidates.begin();
                    hoist_iter != function_loops_iter->second->m_hoisting_candidates.end();
                  ++hoist_iter) {
                    printf("Hoist candidate => index = %d, name = %s, reads = %d, writes = %d\n",
                        *hoist_iter,
                        id_orig_index[*hoist_iter]->get_ref_field_name(),
                        function_loops_iter->second->m_loop_ref_info.get_reads(*hoist_iter),
                        function_loops_iter->second->m_loop_ref_info.get_writes(*hoist_iter));
                }
                for(hoist_iter  = function_loops_iter->second->m_hoisting_selections.begin();
                    hoist_iter != function_loops_iter->second->m_hoisting_selections.end();
                  ++hoist_iter) {
                    printf("Hoist selection => index = %d, name = %s\n",
                        *hoist_iter,
                        id_orig_index[*hoist_iter]->get_ref_field_name());
                }
                assert(function_loops_iter->second->m_hoisting_selections.size() <= 2);

                if( function_loops_iter->second->m_hoisting_selections.size() == 1 ||
                    function_loops_iter->second->m_hoisting_selections.size() == 2 ) {

                    hoist_iter = function_loops_iter->second->m_hoisting_selections.begin();

                    std::stringstream hoist_buf;
                    hoist_buf << "_pillar2c_hoist_" << function_loops_iter->second->m_header->get_unique() << "_" << id_orig_index[*hoist_iter]->get_ref_field_name();

                    block_item_list *hoist_decls =
                      new block_item_list_block_item(
                        new block_item_declaration(
                          new declaration_declaration_specifiers_init_declarator_list(
                            new declaration_specifiers_type_specifier(
                                (type_specifier*)id_orig_index[*hoist_iter]->get_type()->clone()
                            ),
                            new init_declarator_list_init_declarator(
                              new init_declarator_declarator(
                                new declarator_direct_declarator(
                                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(hoist_buf.str())))))),0));

                    hoist_buf.str("");
                    hoist_buf.clear();

                    for(++hoist_iter;
                        hoist_iter != function_loops_iter->second->m_hoisting_selections.end();
                      ++hoist_iter) {
                        hoist_buf << "_pillar2c_hoist_" << function_loops_iter->second->m_header << "_" << id_orig_index[*hoist_iter]->get_ref_field_name();

                        hoist_decls =
                          new block_item_list_block_item_list_block_item(
                            hoist_decls,
                            new block_item_declaration(
                              new declaration_declaration_specifiers_init_declarator_list(
                                new declaration_specifiers_type_specifier(
                                    (type_specifier*)id_orig_index[*hoist_iter]->get_type()->clone()
                                ),
                                new init_declarator_list_init_declarator(
                                  new init_declarator_declarator(
                                    new declarator_direct_declarator(
                                      new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(hoist_buf.str())))))),0));
                    }

                    cs = cs->prepend_bil(hoist_decls);

                    std::stringstream hoist_label;
                    hoist_label << "_pillar2c_hoist_" << function_loops_iter->second->m_header->get_unique();

                    hoist_iter = function_loops_iter->second->m_hoisting_selections.begin();

                    hoist_buf.str("");
                    hoist_buf.clear();
                    hoist_buf << "pillar2c_hoist_" << function_loops_iter->second->m_header->get_unique() << "_" << id_orig_index[*hoist_iter]->get_ref_field_name();

                    ii_ptr hoist_ii = g_scope_stack.find_or_add(hoist_buf.str());

                    block_item_list *pre_header_label =
                        new block_item_list_block_item(
                          new block_item_statement(
                            new statement_labeled_statement(
                              new labeled_statement_identifier(
                                hoist_label.str(),
                                new statement_expression_statement(
                                  new expression_statement_expression(
                                    new expression_assignment_expression(
                                      new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                        expr_gen(unary_expression,primary_expression,new primary_expression_identifier(hoist_ii)),
                                        new assignment_operator_equal(),
                                        expr_gen(assignment_expression,postfix_expression,
                                          gen_pseudo_pe(id_orig_index[*hoist_iter]->get_ref_field_name(),this)))))))),0));

                    function_loops_iter->second->modify_refs(*hoist_iter,hoist_ii);

                    block_item_list *post_loop = NULL;

                    for(++hoist_iter;
                        hoist_iter != function_loops_iter->second->m_hoisting_selections.end();
                      ++hoist_iter) {
                        hoist_buf.str("");
                        hoist_buf.clear();
                        hoist_buf << "pillar2c_hoist_" << function_loops_iter->second->m_header << "_" << id_orig_index[*hoist_iter]->get_ref_field_name();

                        hoist_ii = g_scope_stack.find_or_add(hoist_buf.str());

                        pre_header_label =
                          new block_item_list_block_item_list_block_item(
                            pre_header_label,
                            new block_item_statement(
                              new statement_expression_statement(
                                new expression_statement_expression(
                                  new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                      expr_gen(unary_expression,primary_expression,new primary_expression_identifier(hoist_ii)),
                                      new assignment_operator_equal(),
                                      expr_gen(assignment_expression,postfix_expression,
                                        gen_pseudo_pe(id_orig_index[*hoist_iter]->get_ref_field_name(),this)))))),0));

                        function_loops_iter->second->modify_refs(*hoist_iter,hoist_ii);
                    }

#if 1
                    for(hoist_iter  = function_loops_iter->second->m_hoisting_selections_write.begin();
                        hoist_iter != function_loops_iter->second->m_hoisting_selections_write.end();
                      ++hoist_iter) {
#else
                    for(hoist_iter  = function_loops_iter->second->m_hoisting_selections.begin();
                        hoist_iter != function_loops_iter->second->m_hoisting_selections.end();
                      ++hoist_iter) {
#endif
                        hoist_buf.str("");
                        hoist_buf.clear();
                        hoist_buf << "pillar2c_hoist_" << function_loops_iter->second->m_header << "_" << id_orig_index[*hoist_iter]->get_ref_field_name();

                        hoist_ii = g_scope_stack.find_or_add(hoist_buf.str());

                        if(!post_loop) {
                            post_loop =
                                new block_item_list_block_item(
                                  new block_item_statement(
                                    new statement_expression_statement(
                                      new expression_statement_expression(
                                        new expression_assignment_expression(
                                          new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                            expr_gen(unary_expression,postfix_expression,
                                              gen_pseudo_pe(id_orig_index[*hoist_iter]->get_ref_field_name(),this)),
                                            new assignment_operator_equal(),
                                            expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(hoist_buf.str()))))))),0));
                        } else {
                            post_loop =
                                new block_item_list_block_item_list_block_item(
                                  post_loop,
                                  new block_item_statement(
                                    new statement_expression_statement(
                                      new expression_statement_expression(
                                        new expression_assignment_expression(
                                          new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                            expr_gen(unary_expression,postfix_expression,
                                              gen_pseudo_pe(id_orig_index[*hoist_iter]->get_ref_field_name(),this)),
                                            new assignment_operator_equal(),
                                            expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(hoist_ii)))))),0));
                        }
                    }

                    AST_node *first_loop_stmt = function_loops_iter->second->m_header->get_first_item();
                    if(first_loop_stmt) {
                        first_loop_stmt->insert_before_statement(pre_header_label);

                        for(follow_index = 0; follow_index < function_loops_iter->second->m_header->m_can_follow.size(); ++follow_index) {
                            if(function_loops_iter->second->m_loop_members.find(function_loops_iter->second->m_header->m_can_follow[follow_index]) == function_loops_iter->second->m_loop_members.end()) {
                                edge_info entrance_edge = function_loops_iter->second->m_header->m_can_follow[follow_index]->get_edge_info(function_loops_iter->second->m_header);
                                // An entrance to the loop.
                                switch(entrance_edge.m_type) {
                                case EDGE_FALLTHROUGH:
                                    // Intentionally nothing needs to be done here.
                                    break;
                                case EDGE_GOTO:
                                    assert(entrance_edge.m_goto);
                                    entrance_edge.m_goto->change_label(hoist_label.str());
                                    // TODO
                                    break;
                                default:
                                    aeprintf("Hoist loop entrance processing for type %s not implemeneted yet.\n",edge_to_str(function_loops_iter->second->m_header->m_can_follow[follow_index]->get_edge_type(function_loops_iter->second->m_header)));
                                }
                            }
                        }
                    } else {
                        aeprintf("Loop basic block header has a NULL first item statement recorded.\n");
                    }

                    if(post_loop) {
                        for(exit_index = 0; exit_index < function_loops_iter->second->m_exits.size(); ++exit_index) {
                            if(function_loops_iter->second->m_exits[exit_index].m_exit_target->get_first_item()) {
                                function_loops_iter->second->m_exits[exit_index].m_exit_target->get_first_item()->prepend_bil(
                                    exit_index == (function_loops_iter->second->m_exits.size() - 1) ?
                                        post_loop :
                                        post_loop->clone()
                                );
                            } else {
                                aeprintf("Loop exit didn't have its first item set.\n");
                            }
                        }
                    }
                }

                printf("          ---------------------------------------------\n");
                if(function_loops_iter->second->m_header->get_first_item()) {
                    function_loops_iter->second->m_header->get_first_item()->print();
                    printf("\n");
                } else {
                    printf("          basic_block first item not set.\n");
                }
            }
        }
    }
}

struct_declaration * make_sd_for_prt_arg(const argument_info &ai) {
    return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
            new specifier_qualifier_list_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(ai.m_type_name))
            ),
            new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(ai.m_var_name))))));
}

struct_declaration * make_sd_for_prt_arg(const std::list<argument_info> &args,const std::string &ce) {
    assert(args.size() > 0);
//    if(args.size() > 1) {
    if(args.size() > 0) {
        struct_declaration_list *prt_arg_sdl = NULL;

        std::stringstream sd_name;

        std::list<argument_info>::const_iterator prt_arg_iter;
        for(prt_arg_iter  = args.begin();
            prt_arg_iter != args.end();
          ++prt_arg_iter) {
            if(prt_arg_sdl) {
                prt_arg_sdl = new struct_declaration_list_struct_declaration_list_struct_declaration(
                  prt_arg_sdl,
                  make_sd_for_prt_arg(*prt_arg_iter));
            } else {
                prt_arg_sdl = new struct_declaration_list_struct_declaration(
                  make_sd_for_prt_arg(*prt_arg_iter));
            }
        }

        sd_name << "prt_args_" << ce;

        return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                new type_specifier_struct_or_union_specifier(
                    new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                    new struct_or_union_STRUCT(),
                    prt_arg_sdl))),
                new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                    new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(sd_name.str()))))));
    } else {
        return make_sd_for_prt_arg(args.front());
    }
}

block_item_list_block_item_list_block_item * gen_zero_ref(block_item_list *link_pseudo_frame, ii_ptr ii, function_definition *fd) {
    return    new block_item_list_block_item_list_block_item(
                link_pseudo_frame,
                new block_item_statement(
                 new statement_expression_statement(
                  new expression_statement_expression(
                   new expression_assignment_expression(
                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                     new unary_expression_postfix_expression(
                      new postfix_expression_postfix_expression_dot_identifier(
                       new postfix_expression_postfix_expression_dot_identifier(
                        gen_pseudo_pe("prt_refs_and_array",fd),
                        "prt_refs"),
                       ii->get_qualified_ref_field_name())),
                     new assignment_operator_equal(),
                     expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0")))))),0));
}

declaration * get_declaration_from_prototype(AST_node *dd);

// The main routine that transforms a managed Pillar function into pure C.
void function_definition::function_generic_translate_pillar(
    declarator *&decl,
    declaration_specifiers *&ds,
    PILLAR2C_CALLCONV func_cc,
    compound_statement *cs,
    function_refs &refs) {

#ifdef WIN32
    StartTimer3();
#endif

#if 0
    printf("%s\n",m_symbol->get_string().c_str());
    fflush(stdout);
    if(m_symbol->get_string() == "v1618__whenFinalTableOrdDo") {
        printf("Translating target function\n");
    }
#endif

    // Add explicit calling convention indicator to the function if it
    // doesn't already have one.
    if(!g_intel64) {
        decl = decl->add_explicit_call_conv(func_cc);
    }

    // Unmanaged code doesn't need any further changes.
    if(cc_to_man_unman(get_function_cc()) == MU_UNMANAGED) {
        return;
    }

    // Safe functions need no further translation.
    if(is_gc_safe()) {
        ++g_safe_pdecl;
        return;
    } else {
        ++g_unsafe_pdecl;
    }

//    ds = ds->remove_static();

    // Add "noinline" to the function declaration so that the compiler can't inline it and cause
    // this function prolog to fail to have a return address for the fake_eip_ptr to point to.
    ds = ds->add_noinline();
#ifndef __x86_64__
    if(g_gcc_compatible) {
        ds = ds->add_no_regparm();
    }
#endif
    if(this != m_ii->get_func_definition()) {
        aeprintf("Function definition and symbol mismatch. %s\n",m_ii->get_name());
    }

    direct_declarator *proto_dd = m_ii->get_func_decl();
    if(proto_dd) {
        declaration *proto_decl = get_declaration_from_prototype(proto_dd);
        if(proto_decl) {
            declaration_specifiers *proto_ds = proto_decl->get_declaration_specifiers();
            if(proto_ds) {
                proto_ds->add_noinline();
#ifndef __x86_64__
                if(g_gcc_compatible) {
                    proto_ds->add_no_regparm();
                }
#endif
            }
        }
    }

    function_metadata this_func_meta;
    get_func_metadata(this_func_meta);

    // We can leave active ref params where they are in the global option says to do that and
    // none of the params are non-register sized (so that we can easily compute the offset from the return address).
    bool ref_params_in_pseudo = g_ref_param_in_pseudo || this_func_meta.has_param_of_unknown_size();

    // Somebody has previously called function_determine_ref_slots so m_ref_params is the ref params and m_ref_vars is the ref variables.
    std::list<ii_ptr> combined_refs = refs.m_ref_params;
    std::list<ii_ptr> ref_var_copy  = refs.m_ref_vars;

    // The param and var refs combined in one list.
    combined_refs.splice(combined_refs.end(),ref_var_copy);

    ii_ptr * id_orig_index = new ii_ptr [m_num_total_refs];

    std::set<ii_ptr > disable_opts;
    std::list<ii_ptr>::iterator disable_iter;
    for(disable_iter  = combined_refs.begin();
        disable_iter != combined_refs.end();
      ++disable_iter) {
        if((*disable_iter)->get_address_taken()) {
            printf("WARNING: address of ref %s taken so this ref will always be live.\n",(*disable_iter)->get_name());
            // If the address of a ref is taken then presume it is always alive.
            disable_opts.insert(*disable_iter);
        }
        // Create the original index array.
        id_orig_index[(*disable_iter)->get_ref_index()] = *disable_iter;
    }

    // Create the array to hold the mapping from the old ref index to the compressed ref index.
    unsigned *old_new_ref_map = new unsigned[m_num_total_refs];
    unsigned ref_index;
    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        // Initialize the sentinel which means "not mapped."
        old_new_ref_map[ref_index] = (unsigned)-1;
    }

    unsigned max_index = 0;
    unsigned bb_index;
//    unsigned num_special_ref_params = 0;
    unsigned bb_size = m_basic_blocks.size();
    check_vector<basic_block*> bbs_df_order;

    // Prepare the basic block of this function to have their DFS order determined and to compute dominators.
    for(bb_index = 0; bb_index < bb_size; ++bb_index) {
        bbs_df_order.push_back(NULL); // make the depth-first order vector the right size

        // Initialize the dominator algorithm.
        m_basic_blocks[bb_index]->m_bb_index = bb_index;
        m_basic_blocks[bb_index]->m_dom_mask.set_bit_length(bb_size);
        if(m_basic_blocks[bb_index] == m_start_block) {
            m_basic_blocks[bb_index]->m_dom_mask.set(bb_index);
        } else {
            m_basic_blocks[bb_index]->m_dom_mask.set_all();
        }

        if(ref_debug) {
            unsigned i;
            printf("%p (",m_basic_blocks[bb_index]);
            for(i=0;i<m_basic_blocks[bb_index]->m_can_follow.size();++i) {
                printf("%p ",m_basic_blocks[bb_index]->m_can_follow[i]);
            }
            printf(") (");
            for(i=0;i<m_basic_blocks[bb_index]->m_can_precede.size();++i) {
                printf("%p ",m_basic_blocks[bb_index]->m_can_precede[i].m_block);
            }
            printf(")\n");
        }
    }

    // Compute the depth-first ordering.
    m_start_block->compute_dfn(m_basic_blocks.size(),bbs_df_order);

    // Do dominator algorithm.
    compute_dominators(bbs_df_order, bb_size, m_start_block);

#ifdef WIN32
    StartTimer2();
#endif

#ifdef COUNT_PDR
    unsigned total_pdr = 0;
#endif
    // --------------------------------------------------------------------------------------------------------------------
    // Start ref processing here by seeing which refs are live at which points.
    for(bb_index = 0; bb_index < m_basic_blocks.size(); ++bb_index) {
#ifdef COUNT_PDR
        g_num_pdr = 0;
#endif
        m_basic_blocks[bb_index]->process_downstream_refs(ref_map(m_num_total_refs), ref_map(m_num_total_vars), disable_opts);
#ifdef COUNT_PDR
        total_pdr += g_num_pdr;
        printf("%d calls starting from block %d\n", g_num_pdr, bb_index);
#endif
    }
#ifdef COUNT_PDR
    printf("Generate live map: %d basic blocks, %d # of calls\n", m_basic_blocks.size(), total_pdr);
#endif
#ifdef WIN32
    g_compute_liveness += StopTimer2();
#endif

    g_static_num_refs += m_num_total_refs;

    ref_map active_refs(m_num_total_refs);
    ref_map active_rare(m_num_total_refs);

    check_vector<ref_info *> vec_ri;

    // Compute which refs are active at any callsite.
    for(bb_index = 0; bb_index < m_basic_blocks.size(); ++bb_index) {
        m_basic_blocks[bb_index]->mark_callsite_refs(active_refs);
    }

    // Split the information from active_refs into those active at any callsite to those active at only rare callsites.
    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        if(!ref_params_in_pseudo && active_refs[ref_index] && id_orig_index[ref_index]->is_param()) {
            id_orig_index[ref_index]->get_parameter_declaration()->add_volatile();
            m_ii->add_volatile();
            continue;
        }
        if(active_refs[ref_index] == RARE_RVALUE) {
            active_refs[ref_index] = LR_NOT_FOUND;
            active_rare[ref_index] = RVALUE;
        }
    }

    // refs in assignments of the form "ref1 = ref2;" will be considered live at some callsite so they may be merged and assignments eliminated.
    std::multimap<unsigned,ref_assignment_data>::iterator ref_assign_iter;
    std::set<unsigned> kept_alive_from_assigns;
    if(g_retain_assign_ref) {
        for(ref_assign_iter  = m_ref_assignments->begin();
            ref_assign_iter != m_ref_assignments->end();
            ++ref_assign_iter) {
            if(!active_refs[ref_assign_iter->first]) {
                kept_alive_from_assigns.insert(ref_assign_iter->first);
                active_refs.make_rvalue(ref_assign_iter->first);
            }
            if(!active_refs[ref_assign_iter->second.m_target_index]) {
                kept_alive_from_assigns.insert(ref_assign_iter->second.m_target_index);
                active_refs.make_rvalue(ref_assign_iter->second.m_target_index);
            }
        }
    }

    // Create interference graph vertices.
    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        // If we aren't putting ref params in the pseudo-frame for this function, then create null entry and go to next ref.
        if(!ref_params_in_pseudo && id_orig_index[ref_index]->is_param()) {
            ++g_num_inactive_refs;
            vec_ri.push_back(NULL);
            continue;
        }

        if(active_refs[ref_index] == RVALUE) {
#ifdef REF_INFO_ARRAY
            ref_info *ri = new ref_info(ref_index, id_orig_index[ref_index]->is_param(),m_num_total_refs);
#else
            ref_info *ri = new ref_info(ref_index, id_orig_index[ref_index]->is_param());
#endif
            vec_ri.push_back(ri);
        } else {
            ++g_num_inactive_refs;
            vec_ri.push_back(NULL);
        }
    }

#ifdef WIN32
    StartTimer2();
#endif

    // Add edges to the live ref interference graph.
    for(bb_index = 0; bb_index < bb_size; ++bb_index) {
#ifdef __GNUC__
        if(bb_index + 1 < bb_size) {
            __builtin_prefetch(&(m_basic_blocks[bb_index+1]->m_sent_upstream),0,2);
        }
#endif
        basic_block *bb = m_basic_blocks[bb_index];
        bb->m_sent_upstream.add_edge_if_conflict(vec_ri);
    }

#ifdef WIN32
    g_compute_conflict_time += StopTimer2();
#endif

//            check_vector<ref_info *> vec_ri_save = vec_ri;

    if(g_retain_assign_ref) {
        std::set<unsigned> indices_to_free;
        for(ref_assign_iter  = m_ref_assignments->begin();
            ref_assign_iter != m_ref_assignments->end();
            ++ref_assign_iter) {
            assert(vec_ri[ref_assign_iter->first]);
            if(vec_ri[ref_assign_iter->first]->has_conflict(ref_assign_iter->second.m_target_index) ) {
                if(kept_alive_from_assigns.find(ref_assign_iter->first) != kept_alive_from_assigns.end()) {
                    indices_to_free.insert(ref_assign_iter->first);
                }
                if(kept_alive_from_assigns.find(ref_assign_iter->second.m_target_index) != kept_alive_from_assigns.end()) {
                    indices_to_free.insert(ref_assign_iter->second.m_target_index);
                }
            } else {
                if( vec_ri[ref_assign_iter->first]->get_new_index() == 0 && vec_ri[ref_assign_iter->second.m_target_index]->get_new_index() == 0) {
                    // Neither ref is part of a group yet and we know they don't conflict so create a new group for them.
                    vec_ri[ref_assign_iter->first]->set_new_index(++max_index);
                    vec_ri[ref_assign_iter->second.m_target_index]->set_new_index(max_index);
                } else if(vec_ri[ref_assign_iter->first]->get_new_index() != 0 && vec_ri[ref_assign_iter->second.m_target_index]->get_new_index() == 0) {
                    if(!any_conflicts(vec_ri,vec_ri[ref_assign_iter->first]->get_new_index(),ref_assign_iter->second.m_target_index)) {
                        vec_ri[ref_assign_iter->second.m_target_index]->set_new_index(vec_ri[ref_assign_iter->first]->get_new_index());
                    }
                } else if(vec_ri[ref_assign_iter->first]->get_new_index() == 0 && vec_ri[ref_assign_iter->second.m_target_index]->get_new_index() != 0) {
                    if(!any_conflicts(vec_ri,vec_ri[ref_assign_iter->second.m_target_index]->get_new_index(),ref_assign_iter->first)) {
                        vec_ri[ref_assign_iter->first]->set_new_index(vec_ri[ref_assign_iter->second.m_target_index]->get_new_index());
                    }
                } // Final case is both have already been assigned to a group so nothing to do here.
            }
        }

        std::set<unsigned>::iterator free_iter;
        for(free_iter  = indices_to_free.begin();
            free_iter != indices_to_free.end();
            ++free_iter) {
            delete vec_ri[*free_iter];
            vec_ri[*free_iter] = NULL;
            active_refs[*free_iter] = LR_NOT_FOUND;
        }
    }

    // Sorts the nodes of the conflict graph by the refs with the most conflicts.
    sort(vec_ri.begin(),vec_ri.end(),conflict_sort);

    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        // If the ref is in the interference graph and we haven't determined a new index for that ref yet.
        if(vec_ri[ref_index] && vec_ri[ref_index]->get_new_index() == 0) {
            // Get the first available index with which we do not conflict.
            unsigned new_index = vec_ri[ref_index]->get_lowest_unused_neighbor_index();
            // Remember our new index.
            vec_ri[ref_index]->set_new_index(new_index);
            // Keep track of maximum index.
            if(new_index > max_index) max_index = new_index;
        }
    }

    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        // If the ref is in the interference graph.
        if(vec_ri[ref_index]) {
            assert(vec_ri[ref_index]->get_old_index() < m_num_total_refs);
            // Fill in the map with the ref's original index to its new index.
            old_new_ref_map[vec_ri[ref_index]->get_old_index()] = vec_ri[ref_index]->get_new_index() - 1;
        }
    }

    if(g_retain_assign_ref) {
        for(ref_assign_iter  = m_ref_assignments->begin();
            ref_assign_iter != m_ref_assignments->end();
            ++ref_assign_iter) {
            if(old_new_ref_map[ref_assign_iter->first] != (unsigned)-1 && old_new_ref_map[ref_assign_iter->second.m_target_index] != (unsigned)-1) {
                if(old_new_ref_map[ref_assign_iter->first] == old_new_ref_map[ref_assign_iter->second.m_target_index]) {
                    printf("%s MATCHED\n",m_ii->get_name());
                } else {
                    printf("%s UNMATCHED\n",m_ii->get_name());
                }
            }
        }
    }

    g_condensed_num_refs += max_index;

    std::map<basic_block *, loop *> function_loops;
    std::map<basic_block *, loop *>::iterator function_loops_iter;

    do_loop_hoist_optimization(bb_size, bbs_df_order, function_loops, id_orig_index, disable_opts, cs, active_refs);

    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        delete vec_ri[ref_index];
    }

    bool cast_off_volatile = false;

    // If we are using setjmp/longjmp for continuations and the number of continuations in the function is non-zero.
    // Create an array of all variables indexed by its variable index.
    if(!g_use_try_except && m_continuations.size()) {
        ii_ptr * indexed_var = new ii_ptr [m_num_total_vars];
        //memset(indexed_var,0,sizeof(id_info*) * m_num_total_vars);
        unsigned all_var_index;
        for(all_var_index = 0; all_var_index < m_num_total_vars; ++all_var_index) {
            indexed_var[refs.m_all_vars[all_var_index]->get_var_index()] = refs.m_all_vars[all_var_index];
        }
        check_vector<ii_ptr> all_var_indexed;

        unsigned cp_index;
        for(cp_index = 0; cp_index < m_continuations.size(); ++cp_index) {
            unsigned var_index;
            for(var_index = 0; var_index < m_num_total_vars; ++var_index) {
                if(m_continuations[cp_index]->m_var_indices[var_index]) {
                    if(indexed_var[var_index]->has_ref_index()) {
                        indexed_var[var_index]->make_volatile();
//                            printf("Live at continuation entrance: %s\n",indexed_var[var_index]->get_name());
                    } else {
                        ii_ptr non_ref_volatile_ii = indexed_var[var_index];
#ifdef SINGLE_DECLARACTOR
                        aeprintf("Need to handle the case of non-ref that needs to be volatile.\n");
#else
                        std::list<declarator *> decl_list = non_ref_volatile_ii->get_declarator();
                        if(decl_list.size() == 0) {
                            decl->print();
                            printf("\n");
                            aeprintf("Couldn't find declarator for a variable (%s) live at a continuation site that needs to be made volatile. 1\n",non_ref_volatile_ii->get_string().c_str());
                        } else {
                            std::list<declarator *>::iterator decl_list_iter;
                            for(decl_list_iter  = decl_list.begin();
                                decl_list_iter != decl_list.end();
                                ++decl_list_iter) {
                                declarator *decl = *decl_list_iter;
                                AST_node *parent = decl;

                                declaration *var_declaration = NULL;
                                parameter_declaration *param_declaration = NULL;
                                do {
                                    parent = parent->get_parent();
                                    if(!parent) {
                                        decl->print();
                                        printf("\n");
                                        aeprintf("Couldn't find declaration for a variable (%s) that needs to be made volatile. 2\n",non_ref_volatile_ii->get_string().c_str());
                                    }
                                    var_declaration = dynamic_cast<declaration*>(parent);
                                    param_declaration = dynamic_cast<parameter_declaration*>(parent);
                                    if(dynamic_cast<function_definition*>(parent)) {
                                        decl->print();
                                        printf("\n");
                                        aeprintf("Couldn't find declaration for a variable (%s) that needs to be made volatile. 3\n",non_ref_volatile_ii->get_string().c_str());
                                    }
                                } while (!var_declaration && !param_declaration);

                                cast_off_volatile = true;
                                non_ref_volatile_ii->add_volatile();
                                if(var_declaration) {
                                    var_declaration->add_volatile();
                                } else {
                                    param_declaration->add_volatile();
                                    m_ii->add_volatile();

                                    direct_declarator *proto_dd = m_ii->get_func_decl();
                                    if(proto_dd) {
                                        parameter_type_list *proto_dd_ptl = search_up_for_type<parameter_type_list>(param_declaration);
                                        if(!proto_dd_ptl) {
                                            aeprintf("Could not find ptl for proto_dd.\n");
                                        }
                                        int param_index = proto_dd_ptl->get_parameter_index(param_declaration);

                                        check_vector<parameter_declaration *> pdvec;
                                        bool ellipsis;
                                        proto_dd->vectorize_params(pdvec,ellipsis);

                                        pdvec[param_index]->add_volatile();
                                        //proto_dd->print();
                                        //printf("\n");
                                    }
                                }
                            }
                        }
#endif
                    }
                }
            }
        }

        delete [] indexed_var;
    }

    std::stringstream func_param_struct;
    func_param_struct << "params_" << this->get_unique();

    // for each ref...
    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        // if it is a ref parameter and the ref is not to be moved into the pseudo-frame...
        if(!ref_params_in_pseudo && id_orig_index[ref_index]->is_param()) {
#ifdef __x86_64__
            aeprintf("Cannot use ref params in 64-bit mode.");
#endif // __x86_64__
            unsigned pi;
            unsigned ref_param_offset = REGISTER_PARAM_SIZE; // first param is 4 bytes higher on the stack than the return eip *
            for(pi = 0; pi < this_func_meta.m_params.size(); ++pi) {
                if(this_func_meta.m_params[pi]->get_ii() == id_orig_index[ref_index]) {
                    id_orig_index[ref_index]->set_ref_param_in_place();
                    assert(ref_param_offset > (REGISTER_PARAM_SIZE * get_num_p2c_added_params()));
                    id_orig_index[ref_index]->set_ref_index(ref_param_offset);
                    assert(pi >= get_num_p2c_added_params());
                    break;
                } else {
                    // Keep track of the offset length from return eip * to the current parameter.
                    try {
                        ref_param_offset += this_func_meta.m_params[pi]->get_type()->get_minimum_size();
                    }
                    catch (unknown_size) {
                        aeprintf("Cannot determine the size of a paramter #%d to function %s.\n",pi,get_symbol()->get_string().c_str());
                    }
                    catch (...) {
                        aeprintf("Unknown exception encountered why getting the size of a paramter.\n");
                    }
                }
            }
            if(pi == this_func_meta.m_params.size()) {
                aeprintf("Should not get here.\n");
            }
        }
    }

    for(bb_index = 0; bb_index < m_basic_blocks.size(); ++bb_index) {
        m_basic_blocks[bb_index]->final_backtrace(m_num_total_refs, old_new_ref_map, max_index, id_orig_index, func_param_struct.str(), active_rare, ref_params_in_pseudo);
    }

    check_vector<ii_ptr> uninit_var_to_be_zeroed;

    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        if(m_start_block->m_sent_upstream[ref_index] == RVALUE || m_start_block->m_sent_upstream[ref_index] == RARE_RVALUE) {
            if(!id_orig_index[ref_index]->is_param()) {
                if(disable_opts.find(id_orig_index[ref_index]) == disable_opts.end()) {
                    if(id_orig_index[ref_index]->get_qualified_ref_field_name() != NULL && id_orig_index[ref_index]->has_ref_index()) {
                        if(old_new_ref_map[id_orig_index[ref_index]->get_ref_index()] != (unsigned)-1) {
                            printf("%s: potential use of uninitialized variable %s.\n",get_symbol()->get_string().c_str(),id_orig_index[ref_index]->get_string().c_str());
                            uninit_var_to_be_zeroed.push_back(id_orig_index[ref_index]);
                        }
                    }
                }
            }
        }
    }

    for(ref_index = 0; ref_index < m_num_total_refs; ++ref_index) {
        if(!ref_params_in_pseudo && id_orig_index[ref_index]->is_param()) {
            id_orig_index[ref_index]->set_ref_index((unsigned)-1);
        }
    }

//    max_index -= num_special_ref_params;

    while(!function_loops.empty()) {
        function_loops_iter = function_loops.begin();
        loop *l = function_loops_iter->second;
        function_loops.erase(function_loops_iter);
        delete l;
    }

    ref_debug = false;

    // Create name of this function's pseudo-frame type.
    std::string func_struct_name  = std::string("_pillar2c_pseudo_entry_") + m_ii->get_name();
    std::string func_typedef_name = std::string("pillar2c_pseudo_entry_")  + m_ii->get_name();

    // Generate the "prev" field in the pseudo-frame.
#ifndef PREV_OPT
    struct_declaration *sd_prev =
        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
            new type_specifier_struct_or_union_specifier(
              new struct_or_union_specifier_struct_or_union_identifier(
                new struct_or_union_STRUCT(),
                "_pillar2c_pseudo_stack_entry"))),
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prev"))))));
#endif // PREV_OPT

    struct_declaration *sd_ref_mask_ptr =
        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
            new type_specifier_VOID()),
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("ref_mask_ptr"))))));

    struct_declaration *sd_fake_reg =
        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
            new type_specifier_TYPE_NAME(
             g_scope_stack.find_or_add("PrtCodeAddress"))),
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("fake_eip_target"))))));

    // Generate the "count" field in the pseudo-frame.
    struct_declaration_list *main_sdl = NULL;

    // Create initial struct member list composed of prev and count fields.
#ifdef PREV_OPT
    main_sdl =
        new struct_declaration_list_struct_declaration_list_struct_declaration(
         new struct_declaration_list_struct_declaration(sd_fake_reg),
         sd_ref_mask_ptr);
#else  // PREV_OPT
    main_sdl =
        new struct_declaration_list_struct_declaration_list_struct_declaration(
         new struct_declaration_list_struct_declaration_list_struct_declaration(
          new struct_declaration_list_struct_declaration(sd_prev),
          sd_fake_reg),
         sd_ref_mask_ptr);
#endif // PREV_OPT

    std::stringstream str_num_args;
    str_num_args << max_index;

    std::list<ii_ptr>::iterator cur_ref = combined_refs.begin();
    for(; cur_ref != combined_refs.end(); ++cur_ref) {
        if((*cur_ref)->get_ref_index() >=0 && (*cur_ref)->get_ref_index() < m_num_total_refs) {
            (*cur_ref)->set_ref_index(old_new_ref_map[(*cur_ref)->get_ref_index()]);
        }
    }

    // If there are ref params or fields, the third part of the pseudo-frame
    // struct is a union composed of two parts, the explicit part and the
    // generic part.
    if(max_index) {
        // Generate the generic part of the union.  An array of void * whose
        // size is the number of ref params and vars.
        struct_declaration *sd_array =
         new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
           new type_specifier_struct_or_union_specifier(
            new struct_or_union_specifier_struct_or_union_struct_declaration_list(
             new struct_or_union_STRUCT(),
             new struct_declaration_list_struct_declaration(
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
               new specifier_qualifier_list_type_specifier(
                 new type_specifier_VOID()
               ),
               new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                 new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_direct_declarator_assignment_expression(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("ref_array")),
                   expr_gen(assignment_expression,primary_expression,
                    new primary_expression_constant(str_num_args.str()))))))))))),
          new struct_declarator_list_struct_declarator(
           new struct_declarator_declarator(
            new declarator_direct_declarator(
             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("ref_array_struct"))))));

        std::list<ii_ptr>::iterator cur_ref = combined_refs.begin();
        if(combined_refs.size() != m_num_total_refs) {
            aeprintf("combined_refs doesn't match.\n");
        }
        assert(cur_ref != combined_refs.end());
        std::map<unsigned,ii_ptr> ref_map;
        std::map<unsigned,check_vector<ii_ptr> > ref_map_new;

        for(; cur_ref != combined_refs.end(); ++cur_ref) {
            ii_ptr rmii = *cur_ref;
            unsigned rmiindex = rmii->get_ref_index();
            if(rmiindex != (unsigned)-1) {
                std::pair<std::map<unsigned,check_vector<ii_ptr> >::iterator,bool> rmn_iter;
                rmn_iter = ref_map_new.insert(std::pair<unsigned,check_vector<ii_ptr> >(rmiindex,check_vector<ii_ptr>()));
                rmn_iter.first->second.push_back(rmii);
            }
        }

        struct_declaration_list *latest_named_ref = NULL;

        std::map<unsigned,check_vector<ii_ptr> >::iterator ref_map_new_iter = ref_map_new.begin();
        unsigned union_num = 0;

        if(ref_map_new_iter != ref_map_new.end()) {
            if((*ref_map_new_iter).second.size() > 1) {
                latest_named_ref = new struct_declaration_list_struct_declaration(gen_multiref_struct_declaration((*ref_map_new_iter).second,union_num));
            } else {
                assert((*ref_map_new_iter).second.size() == 1);
                latest_named_ref = new struct_declaration_list_struct_declaration(gen_single_struct_declaration((*ref_map_new_iter).second[0]));
            }

            ++ref_map_new_iter;
        }

        while(ref_map_new_iter != ref_map_new.end()) {
            if((*ref_map_new_iter).second.size() > 1) {
                latest_named_ref = new struct_declaration_list_struct_declaration_list_struct_declaration(
                                      latest_named_ref,
                                      gen_multiref_struct_declaration((*ref_map_new_iter).second,union_num));
            } else {
                assert((*ref_map_new_iter).second.size() == 1);
                latest_named_ref = new struct_declaration_list_struct_declaration_list_struct_declaration(
                                      latest_named_ref,
                                      gen_single_struct_declaration((*ref_map_new_iter).second[0]));
            }

            ++ref_map_new_iter;
        }

        if(latest_named_ref) {
            struct_declaration *sd_named =
             new struct_declaration_specifier_qualifier_list_struct_declarator_list(
              new specifier_qualifier_list_type_specifier(
               new type_specifier_struct_or_union_specifier(
                new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                 new struct_or_union_STRUCT(),
                 latest_named_ref))),
              new struct_declarator_list_struct_declarator(
               new struct_declarator_declarator(
                new declarator_direct_declarator(
                 new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prt_refs"))))));

            struct_declaration *sd_union =
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                  new type_specifier_struct_or_union_specifier(
                    new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                      new struct_or_union_UNION(),
                      new struct_declaration_list_struct_declaration_list_struct_declaration(
                        new struct_declaration_list_struct_declaration(
                          sd_named),
                        sd_array)))),
                new struct_declarator_list_struct_declarator(
                  new struct_declarator_declarator(
                    new declarator_direct_declarator(
                      new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prt_refs_and_array"))))));
            main_sdl = new struct_declaration_list_struct_declaration_list_struct_declaration(main_sdl,sd_union);
        } else {
            struct_declaration *sd_union =
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                new specifier_qualifier_list_type_specifier(
                  new type_specifier_struct_or_union_specifier(
                    new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                      new struct_or_union_UNION(),
                      new struct_declaration_list_struct_declaration(sd_array)))),
                new struct_declarator_list_struct_declarator(
                  new struct_declarator_declarator(
                    new declarator_direct_declarator(
                      new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prt_refs_and_array"))))));
            main_sdl = new struct_declaration_list_struct_declaration_list_struct_declaration(main_sdl,sd_union);
        }
    }

    if(g_prt_args_in_pseudo) {
        struct_declaration_list *prt_arg_sdl = NULL;

        std::map<std::string,std::list<argument_info> >::iterator prt_arg_iter;
//        std::list<std::pair<std::string,std::string> >::iterator prt_arg_iter;
        for(prt_arg_iter  = m_prt_arg_list.begin();
            prt_arg_iter != m_prt_arg_list.end();
          ++prt_arg_iter) {
            assert(prt_arg_iter->second.size() > 0);
            if(prt_arg_sdl) {
                prt_arg_sdl = new struct_declaration_list_struct_declaration_list_struct_declaration(
                  prt_arg_sdl,
                  make_sd_for_prt_arg(prt_arg_iter->second,prt_arg_iter->first));
            } else {
                prt_arg_sdl = new struct_declaration_list_struct_declaration(
                  make_sd_for_prt_arg(prt_arg_iter->second,prt_arg_iter->first));
            }
        }

        if(prt_arg_sdl) {
#if 1
            struct_declaration *named_prt_args_union =
                new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                  new specifier_qualifier_list_type_specifier(
                    new type_specifier_struct_or_union_specifier(
                      new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                        new struct_or_union_UNION(),
                        prt_arg_sdl))),
                  new struct_declarator_list_struct_declarator(
                    new struct_declarator_declarator(
                      new declarator_direct_declarator(
                        new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prt_arguments"))))));

            main_sdl =
                new struct_declaration_list_struct_declaration_list_struct_declaration(
                    main_sdl,
                    named_prt_args_union);
#else
            anonymous_struct_declaration *prt_args_union =
                new anonymous_struct_declaration_specifier_qualifier_list(
                  new specifier_qualifier_list_type_specifier(
                    new type_specifier_struct_or_union_specifier(
                      new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                        new struct_or_union_UNION(),
                        prt_arg_sdl))));

            main_sdl =
                new struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(
                    main_sdl,
                    prt_args_union
                );
#endif
        }
    }

    if(g_pseudo_pad) {
        std::stringstream pad_str;
        pad_str << g_pseudo_pad;
        main_sdl =
            new struct_declaration_list_struct_declaration_list_struct_declaration(
              main_sdl,
              new struct_declaration_specifier_qualifier_list_struct_declarator_list(
               new specifier_qualifier_list_type_specifier(
                 new type_specifier_VOID()
               ),
               new struct_declarator_list_struct_declarator(
                new struct_declarator_declarator(
                 new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_direct_declarator_assignment_expression(
                   new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("padding")),
                   expr_gen(assignment_expression,primary_expression,
                    new primary_expression_constant(pad_str.str()))))))));
    }

    external_declaration *pseudo_stack_decl =
        new external_declaration_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_storage_class_specifier_declaration_specifiers(
              new storage_class_specifier_TYPEDEF(),
              new declaration_specifiers_type_specifier(
                new type_specifier_struct_or_union_specifier(
                  new struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(
                    new struct_or_union_STRUCT(),
                    func_struct_name,
                    main_sdl)))),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator(
                new declarator_direct_declarator(
                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(func_typedef_name.c_str())))))));

    insert_before_top_level(pseudo_stack_decl);

    block_item_list *pseudo_stack_declaration =
      new block_item_list_block_item(
        new block_item_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_type_specifier(
              new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(func_typedef_name.c_str()))),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator(
                new declarator_direct_declarator(
                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(PSEUDO_NAME)))))),0));

    block_item_list *pseudo_stack_ptr = NULL;
    if(g_use_restrict_pointer) {
        pseudo_stack_ptr = new block_item_list_block_item(
                             new block_item_text(func_typedef_name + std::string("* __restrict ") + std::string(PSEUDO_NAME_PTR) +
                               std::string(" = &") + std::string(PSEUDO_NAME) + std::string(";\n")));
    }

    // Remove ref var declarations from the function.
    for(cur_ref  = refs.m_ref_vars.begin();
        cur_ref != refs.m_ref_vars.end();
      ++cur_ref) {
        if((*cur_ref)->has_ref_index()) {
#ifdef SINGLE_DECLARATOR
            declarator *d= (*cur_ref)->get_declarator();
            assert(d);
#else
            assert((*cur_ref)->get_declarator().size() == 1);
            declarator *d= (*cur_ref)->get_first_declarator();
            assert(d);
#endif
            try {
                d->get_parent()->sub_destroyed(d);
            } catch(...) {}
        }
    }

    unsigned num_prolog_statements = 0;

    // Add code to link pseudo-frames together.
#ifdef PREV_OPT
    ++num_prolog_statements;
#if 0
#ifdef __x86_64__
    aeprintf("Previous optimization not supported in __x86_64__ mode.\n");
#else  // __x86_64__
    std::stringstream fake_eip_text;
    fake_eip_text << PSEUDO_NAME << ".fake_eip_target = (PrtCodeAddress *)(((unsigned *)&" << g_first_added_param_name << ")-1);\n";
    block_item_list *link_pseudo_frame =
       new block_item_list_block_item(
         new block_item_text(fake_eip_text.str())
       );
#endif // __x86_64__
#else // 0
    block_item_list *link_pseudo_frame =
       new block_item_list_block_item(
        new block_item_statement(
         new statement_expression_statement(
          new expression_statement_expression(
           new expression_assignment_expression(
            new assignment_expression_unary_expression_assignment_operator_assignment_expression(
             new unary_expression_postfix_expression(
              new postfix_expression_postfix_expression_dot_identifier(
               new postfix_expression_primary_expression(
                new primary_expression_identifier(
                 g_scope_stack.find_or_add(PSEUDO_NAME))),
               "fake_eip_target"
              )
             ),
             new assignment_operator_equal(),
             expr_gen(assignment_expression,cast_expression,
                 new cast_expression_type_name_cast_expression(
                  new type_name_specifier_qualifier_list_abstract_declarator(
                   new specifier_qualifier_list_type_specifier(
                      new type_specifier_TYPE_NAME(
                        g_scope_stack.find_or_add("PrtCodeAddress"))),
                   new abstract_declarator_pointer(
                    new pointer_star())),
                  expr_gen(cast_expression,primary_expression,
                     new primary_expression_expression(
                      new expression_assignment_expression(
                       expr_gen(assignment_expression,additive_expression,
                           new additive_expression_additive_expression_minus_multiplicative_expression(
                            new additive_expression_multiplicative_expression(
                             new multiplicative_expression_cast_expression(
                              new cast_expression_unary_expression(
                               new unary_expression_postfix_expression(
                                new postfix_expression_primary_expression(
                                 new primary_expression_expression(
                                  new expression_assignment_expression(
                                   expr_gen(assignment_expression,cast_expression,
                                       new cast_expression_type_name_cast_expression(
                                        new type_name_specifier_qualifier_list_abstract_declarator(
                                         new specifier_qualifier_list_type_specifier(
                                          new type_specifier_UNSIGNED()),
                                         new abstract_declarator_pointer(
                                          new pointer_star())),
                                        new cast_expression_unary_expression(
                                         new unary_expression_unary_operator_cast_expression(
                                          new unary_operator_and(),
                                          expr_gen(cast_expression,primary_expression,
                                             new primary_expression_identifier(g_scope_stack.find_or_add(g_first_added_param_name)))))))))))))),
                            expr_gen(multiplicative_expression,primary_expression,new primary_expression_constant("1")))))))))))))));
#endif // 0
#else  // PREV_OPT
    ++num_prolog_statements;
    block_item_list *link_pseudo_frame =
      new block_item_list_block_item(
       new block_item_statement(
        new statement_expression_statement(
         new expression_statement_expression(
          new expression_assignment_expression(
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             gen_pseudo_pe("prev",this)),
            new assignment_operator_equal(),
            expr_gen(assignment_expression,primary_expression,
                       new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_prev_pseudo_stack"))))))),0));

    ++num_prolog_statements;
#if 1
#ifdef __x86_64__
    if(g_gcc_compatible) {
        link_pseudo_frame =
           new block_item_list_block_item_list_block_item(
             link_pseudo_frame,
//             new block_item_text("__asm__ (\n \"mov %%%%rbp, %%%%rax; mov %%%%rax, %%0;\"\n: \"=r\"(_pillar2c_current_pseudo_frame.fake_eip_target) \n:\n: \"memory\", \"%%rax\" );\n")
//             new block_item_text("__asm__ (\n \"mov %%%%rbp, %%%%rax; nop; nop; nop; nop; add 8, %%%%rax; nop; nop; nop; nop; mov %%%%rax, %%0; nop; nop; nop; nop; \"\n: \"=r\"(_pillar2c_current_pseudo_frame.fake_eip_target) \n:\n: \"memory\", \"%%rax\" );\n")
             new block_item_text("__asm__ (\n \"mov %%%%rbp, %%%%rax; add $8, %%%%rax; mov %%%%rax, %%0\"\n: \"=r\"(" PSEUDO_NAME ".fake_eip_target) \n:\n: \"memory\", \"%%rax\" );\n")
//             new block_item_text("__asm__ (\n \"mov %%%%rsp, %%%%rax; add $8, %%%%rax; mov %%%%rax, %%0\"\n: \"=r\"(" PSEUDO_NAME ".fake_eip_target) \n:\n: \"memory\", \"%%rax\" );\n")
           );
    } else {
        aeprintf("__x86_64__ only supported in gcc mode.\n");
    }
#else  // __x86_64__
    std::stringstream fake_eip_text;
    fake_eip_text << PSEUDO_NAME << ".fake_eip_target = (PrtCodeAddress *)(((unsigned *)&" << g_first_added_param_name << ")-1);\n";
    link_pseudo_frame =
       new block_item_list_block_item_list_block_item(
         link_pseudo_frame,
         new block_item_text(fake_eip_text.str())
       );
#endif // __x86_64__
#else // 0
    link_pseudo_frame =
       new block_item_list_block_item_list_block_item(
        link_pseudo_frame,
        new block_item_statement(
         new statement_expression_statement(
          new expression_statement_expression(
           new expression_assignment_expression(
            new assignment_expression_unary_expression_assignment_operator_assignment_expression(
             new unary_expression_postfix_expression(
              gen_pseudo_pe("fake_eip_target",this)),
             new assignment_operator_equal(),
             expr_gen(assignment_expression,cast_expression,
                 new cast_expression_type_name_cast_expression(
                  new type_name_specifier_qualifier_list_abstract_declarator(
                   new specifier_qualifier_list_type_specifier(
//                    new type_specifier_VOID()
                      new type_specifier_TYPE_NAME(
                        g_scope_stack.find_or_add("PrtCodeAddress"))),
                   new abstract_declarator_pointer(
                    new pointer_star())),
                  expr_gen(cast_expression,primary_expression,
                     new primary_expression_expression(
                      new expression_assignment_expression(
                       expr_gen(assignment_expression,additive_expression,
                           new additive_expression_additive_expression_minus_multiplicative_expression(
                            new additive_expression_multiplicative_expression(
                             new multiplicative_expression_cast_expression(
                              new cast_expression_unary_expression(
                               new unary_expression_postfix_expression(
                                new postfix_expression_primary_expression(
                                 new primary_expression_expression(
                                  new expression_assignment_expression(
                                   expr_gen(assignment_expression,cast_expression,
                                       new cast_expression_type_name_cast_expression(
                                        new type_name_specifier_qualifier_list_abstract_declarator(
                                         new specifier_qualifier_list_type_specifier(
                                          new type_specifier_UNSIGNED()),
                                         new abstract_declarator_pointer(
                                          new pointer_star())),
                                        new cast_expression_unary_expression(
                                         new unary_expression_unary_operator_cast_expression(
                                          new unary_operator_and(),
                                          expr_gen(cast_expression,primary_expression,
                                             new primary_expression_identifier(g_scope_stack.find_or_add(g_first_added_param_name))
                                            )))))))))))),
                            expr_gen(multiplicative_expression,primary_expression,new primary_expression_constant("1")))))))))))))));
#endif // 0
#endif // PREV_OPT

    // Add code to copy ref params into the pseudo-frame.
    for(cur_ref  = refs.m_ref_params.begin();
        cur_ref != refs.m_ref_params.end();
      ++cur_ref) {
        if((*cur_ref)->has_ref_index()) {
            if(ref_params_in_pseudo) {
                ++num_prolog_statements;
                link_pseudo_frame =
                  new block_item_list_block_item_list_block_item(
                    link_pseudo_frame,
                    new block_item_statement(
                     new statement_expression_statement(
                      new expression_statement_expression(
                       new expression_assignment_expression(
                        new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                         new unary_expression_postfix_expression(
                          new postfix_expression_postfix_expression_dot_identifier(
                           new postfix_expression_postfix_expression_dot_identifier(
                            gen_pseudo_pe("prt_refs_and_array",this),
                            "prt_refs"),
                           (*cur_ref)->get_qualified_ref_field_name())),
                         new assignment_operator_equal(),
                         expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(*cur_ref)))))),0));
            } else {
                aeprintf("Should never get here.\n");
            }
        }
    }

    // Add code to zero ref fields whose optimizations are disabled in the pseudo-frame.
    std::set<ii_ptr>::iterator cur_zero_ref;
    for(cur_zero_ref  = disable_opts.begin();
        cur_zero_ref != disable_opts.end();
      ++cur_zero_ref) {
        if(!(*cur_zero_ref)->is_param()) {
            ++num_prolog_statements;

            link_pseudo_frame = gen_zero_ref(link_pseudo_frame,*cur_zero_ref, this);
        }
    }

    // Zero out refs that may be used while not initialized.  This is actually quite unlikely
    // and most likely due to the translator not knowing that a certain call will not return.
    check_vector<ii_ptr>::iterator uninit_iter;
    for(uninit_iter  = uninit_var_to_be_zeroed.begin();
        uninit_iter != uninit_var_to_be_zeroed.end();
      ++uninit_iter) {
        assert(! (*uninit_iter)->is_param() );

        ++num_prolog_statements;

        link_pseudo_frame = gen_zero_ref(link_pseudo_frame,*uninit_iter, this);
    }

    if(g_gen_prolog_yields) {
        link_pseudo_frame =
          new block_item_list_block_item_list_block_item(
            link_pseudo_frame,
            gen_yield_check()
          );
    }

    // Scan the entire function again looking for uses of refs and replace those with references in the pseudo-frame.
    if(m_num_total_refs) {
        cs->replace_refs_with_pseudo_expression();
    }
//  if(cast_off_volatile) {
        cs->cast_off_volatile();
//  }

    // If instrumentation is turned on.
    if(g_instrument) {
        // Declare the two externed globals (declared in pillar2c runtime) we use to collection call info.
        if(!g_instrument_externs_declared) {
            g_instrument_externs_declared = true;

            insert_before_top_level(new external_declaration_emit_text("extern unsigned long long g_pillar2c_managed_calls;\n"));
//            g_scope_stack.find_or_add("g_pillar2c_managed_calls");

            insert_before_top_level(new external_declaration_emit_text("extern unsigned long long g_pillar2c_managed_call_stmt_overhead;\n"));
//            g_scope_stack.find_or_add("g_pillar2c_managed_call_stmt_overhead");
        }

        // Add 1 to the number of managed calls.
        link_pseudo_frame =
          new block_item_list_block_item_list_block_item(
            link_pseudo_frame,
            new block_item_text("++g_pillar2c_managed_calls;\n"));

        std::stringstream overhead_str;
        overhead_str << "g_pillar2c_managed_call_stmt_overhead += " << num_prolog_statements << ";\n";

        // Add the number of pillar2c prolog statements we added to the global metric.
        link_pseudo_frame =
          new block_item_list_block_item_list_block_item(
            link_pseudo_frame,
            new block_item_text(overhead_str.str()));
    }

    cs = cs->prepend_bil(link_pseudo_frame);
    if(g_use_restrict_pointer) {
        cs = cs->prepend_bil(pseudo_stack_ptr);
    }
    cs = cs->prepend_bil(pseudo_stack_declaration);

    delete [] old_new_ref_map;
    delete [] id_orig_index;

#ifdef WIN32
    g_function_translate += StopTimer3();
#endif
} // function_generic_translate_pillar

// ---------------------------------------------------------------------------

translation_unit * gen_pre_trans(void) {
    translation_unit *latest = NULL;

    external_declaration *prt_wb = ::remove_decl_by_name("gc_heap_slot_write_barrier_indirect_prt");
    if(prt_wb) {
        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,prt_wb);
    } else {
        ii_ptr ii_prt_wb;
        declarator *wwo_cc = NULL;
        declarator *big_decl = NULL;
        parameter_list *task_handle_param = NULL;
        if(g_use_th_param) {
            task_handle_param = new parameter_list_parameter_declaration(
                        new parameter_declaration_declaration_specifiers_abstract_declarator(
                          new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                            new abstract_declarator_pointer(new pointer_star())));
        }

        parameter_type_list *wb_ptl =
            new parameter_type_list_parameter_list(
              new parameter_list_parameter_list_parameter_declaration(
                new parameter_list_parameter_list_parameter_declaration(
                  new parameter_list_parameter_list_parameter_declaration(
                    parameter_list::new_recursive(
                      task_handle_param,
                      new parameter_declaration_declaration_specifiers_abstract_declarator(
                        new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                          new abstract_declarator_pointer(new pointer_star()))),
                    new parameter_declaration_declaration_specifiers_abstract_declarator(
                      new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                        new abstract_declarator_pointer(new pointer_star()))),
                  new parameter_declaration_declaration_specifiers_abstract_declarator(
                    new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                      new abstract_declarator_pointer(new pointer_star()))),
                new parameter_declaration_declaration_specifiers_abstract_declarator(
                  new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                   new abstract_declarator_pointer(new pointer_star()))));

        direct_declarator_direct_declarator_parameter_type_list *ddddptl;

        if(g_gcc_compatible) {
            wwo_cc =
                new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_heap_slot_write_barrier_indirect_prt")));

            big_decl = new declarator_call_conv_specifier_direct_declarator(
                          new call_conv_specifier_STDCALL(),
                          ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                             new direct_declarator_paren_declarator(wwo_cc),
                             wb_ptl));
        } else {
            wwo_cc =
                new declarator_call_conv_specifier_pointer_direct_declarator(
                  new call_conv_specifier_STDCALL(),
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_heap_slot_write_barrier_indirect_prt")));

            big_decl = new declarator_direct_declarator(
                             ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                               new direct_declarator_paren_declarator(wwo_cc),
                               wb_ptl));
        }

        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,
                   new external_declaration_declaration(
                     new declaration_declaration_specifiers_init_declarator_list(
                       new declaration_specifiers_type_specifier(
                         new type_specifier_VOID()),
                       new init_declarator_list_init_declarator(
                         new init_declarator_declarator(big_decl)))));

        ii_prt_wb->add(IIT_FUNCTION);
        ii_prt_wb->set_func_decl(ddddptl);
//        ii_prt_wb->set_function_cc(ST_PCDECL);
    }

    external_declaration *prt_wb_interior = ::remove_decl_by_name("gc_heap_slot_write_interior_indirect_prt");
    if(prt_wb_interior) {
        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,prt_wb_interior);
    } else {
        ii_ptr ii_prt_wb;
        declarator *wwo_cc = NULL;
        declarator *big_decl = NULL;

        parameter_declaration *task_handle_param = NULL;
        if(g_use_th_param) {
            task_handle_param =
                        new parameter_declaration_declaration_specifiers_abstract_declarator(
                          new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                            new abstract_declarator_pointer(new pointer_star()));
        }

        parameter_type_list *wbi_ptl =
            new parameter_type_list_parameter_list(
                                parameter_list::new_recursive(
                                 parameter_list::new_recursive(
                                   parameter_list::new_recursive(
                                     parameter_list::new_recursive(
                                       parameter_list::new_recursive(
                                         NULL,
                                         new parameter_declaration_declaration_specifiers_abstract_declarator(
                                           new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                           new abstract_declarator_pointer(new pointer_star()))),
                                       new parameter_declaration_declaration_specifiers_abstract_declarator(
                                         new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                         new abstract_declarator_pointer(new pointer_star()))),
                                       new parameter_declaration_declaration_specifiers(
                                         new declaration_specifiers_type_specifier(new type_specifier_UNSIGNED())
                                     )),
                                     task_handle_param),
                                   new parameter_declaration_declaration_specifiers_abstract_declarator(
                                     new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                     new abstract_declarator_pointer(new pointer_star()))));

        direct_declarator_direct_declarator_parameter_type_list *ddddptl;

        if(g_gcc_compatible) {
            wwo_cc =
                new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_heap_slot_write_interior_indirect_prt")));

            big_decl =
                new declarator_call_conv_specifier_direct_declarator(
                  new call_conv_specifier_STDCALL(),
                  ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                     new direct_declarator_paren_declarator(wwo_cc),
                     wbi_ptl));
        } else {
            wwo_cc =
                new declarator_call_conv_specifier_pointer_direct_declarator(
                  new call_conv_specifier_STDCALL(),
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_heap_slot_write_interior_indirect_prt")));

            big_decl =
                new declarator_direct_declarator(
                ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                  new direct_declarator_paren_declarator(wwo_cc),
                  wbi_ptl));
        }

        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,
                   new external_declaration_declaration(
                     new declaration_declaration_specifiers_init_declarator_list(
                       new declaration_specifiers_type_specifier(
                         new type_specifier_VOID()),
                       new init_declarator_list_init_declarator(
                         new init_declarator_declarator(big_decl)))));

        ii_prt_wb->add(IIT_FUNCTION);
        ii_prt_wb->set_func_decl(ddddptl);
//        ii_prt_wb->set_function_cc(ST_PCDECL);
    }

    external_declaration *prt_cas_wb = ::remove_decl_by_name("gc_cas_write_barrier_indirect_prt");
    if(prt_cas_wb) {
        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,prt_cas_wb);
    } else {
        ii_ptr ii_prt_wb;
        declarator *wwo_cc = NULL;
        declarator *big_decl = NULL;
        parameter_list *task_handle_param = NULL;
        if(g_use_th_param) {
            task_handle_param = new parameter_list_parameter_declaration(
                        new parameter_declaration_declaration_specifiers_abstract_declarator(
                          new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                            new abstract_declarator_pointer(new pointer_star())));
        }

        parameter_type_list *wb_ptl =
            new parameter_type_list_parameter_list(
              new parameter_list_parameter_list_parameter_declaration(
                new parameter_list_parameter_list_parameter_declaration(
                  new parameter_list_parameter_list_parameter_declaration(
                    new parameter_list_parameter_list_parameter_declaration(
                      parameter_list::new_recursive(
                        task_handle_param,
                        new parameter_declaration_declaration_specifiers_abstract_declarator(
                          new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                            new abstract_declarator_pointer(new pointer_star()))),
                      new parameter_declaration_declaration_specifiers_abstract_declarator(
                        new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                          new abstract_declarator_pointer(new pointer_star()))),
                    new parameter_declaration_declaration_specifiers_abstract_declarator(
                      new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                        new abstract_declarator_pointer(new pointer_star()))),
                  new parameter_declaration_declaration_specifiers_abstract_declarator(
                    new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                      new abstract_declarator_pointer(new pointer_star()))),
                new parameter_declaration_declaration_specifiers_abstract_declarator(
                  new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                   new abstract_declarator_pointer(new pointer_star()))));

        direct_declarator_direct_declarator_parameter_type_list *ddddptl;

        if(g_gcc_compatible) {
            wwo_cc =
                new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_cas_write_barrier_indirect_prt")));

            big_decl = new declarator_pointer_call_conv_specifier_direct_declarator(
                          new pointer_star(),
                          new call_conv_specifier_STDCALL(),
                          ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                             new direct_declarator_paren_declarator(wwo_cc),
                             wb_ptl));
        } else {
            wwo_cc =
                new declarator_call_conv_specifier_pointer_direct_declarator(
                  new call_conv_specifier_STDCALL(),
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_cas_write_barrier_indirect_prt")));

            big_decl = new declarator_pointer_direct_declarator(
                             new pointer_star(),
                             ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                               new direct_declarator_paren_declarator(wwo_cc),
                               wb_ptl));
        }

        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,
                   new external_declaration_declaration(
                     new declaration_declaration_specifiers_init_declarator_list(
                       new declaration_specifiers_type_specifier(
                         new type_specifier_VOID()),
                       new init_declarator_list_init_declarator(
                         new init_declarator_declarator(big_decl)))));

        ii_prt_wb->add(IIT_FUNCTION);
        ii_prt_wb->set_func_decl(ddddptl);
//        ii_prt_wb->set_function_cc(ST_PCDECL);
    }

    external_declaration *prt_cas_wb_interior = ::remove_decl_by_name("gc_cas_write_interior_indirect_prt");
    if(prt_cas_wb_interior) {
        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,prt_cas_wb_interior);
    } else {
        ii_ptr ii_prt_wb;
        declarator *wwo_cc = NULL;
        declarator *big_decl = NULL;

        parameter_declaration *task_handle_param = NULL;
        if(g_use_th_param) {
            task_handle_param =
                        new parameter_declaration_declaration_specifiers_abstract_declarator(
                          new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                            new abstract_declarator_pointer(new pointer_star()));
        }

        parameter_type_list *wbi_ptl =
            new parameter_type_list_parameter_list(
                               parameter_list::new_recursive(
                                parameter_list::new_recursive(
                                 parameter_list::new_recursive(
                                   parameter_list::new_recursive(
                                     parameter_list::new_recursive(
                                       parameter_list::new_recursive(
                                         NULL,
                                         new parameter_declaration_declaration_specifiers_abstract_declarator(
                                           new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                           new abstract_declarator_pointer(new pointer_star()))),
                                       new parameter_declaration_declaration_specifiers_abstract_declarator(
                                         new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                         new abstract_declarator_pointer(new pointer_star()))),
                                       new parameter_declaration_declaration_specifiers(
                                         new declaration_specifiers_type_specifier(new type_specifier_UNSIGNED())
                                     )),
                                    new parameter_declaration_declaration_specifiers_abstract_declarator(
                                      new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                      new abstract_declarator_pointer(new pointer_star()))),
                                   task_handle_param),
                                  new parameter_declaration_declaration_specifiers_abstract_declarator(
                                    new declaration_specifiers_type_specifier(new type_specifier_VOID()),
                                    new abstract_declarator_pointer(new pointer_star()))));

        direct_declarator_direct_declarator_parameter_type_list *ddddptl;

        if(g_gcc_compatible) {
            wwo_cc =
                new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_cas_write_interior_indirect_prt")));

            big_decl =
                new declarator_pointer_call_conv_specifier_direct_declarator(
                  new pointer_star(),
                  new call_conv_specifier_STDCALL(),
                  ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                     new direct_declarator_paren_declarator(wwo_cc),
                     wbi_ptl));
        } else {
            wwo_cc =
                new declarator_call_conv_specifier_pointer_direct_declarator(
                  new call_conv_specifier_STDCALL(),
                  new pointer_star(),
                  new direct_declarator_IDENTIFIER(
                    ii_prt_wb = g_scope_stack.find_or_add("gc_cas_write_interior_indirect_prt")));

            big_decl =
                new declarator_pointer_direct_declarator(
                  new pointer_star(),
                  ddddptl = new direct_declarator_direct_declarator_parameter_type_list(
                    new direct_declarator_paren_declarator(wwo_cc),
                    wbi_ptl));
        }

        latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,
                   new external_declaration_declaration(
                     new declaration_declaration_specifiers_init_declarator_list(
                       new declaration_specifiers_type_specifier(
                         new type_specifier_VOID()),
                       new init_declarator_list_init_declarator(
                         new init_declarator_declarator(big_decl)))));

        ii_prt_wb->add(IIT_FUNCTION);
        ii_prt_wb->set_func_decl(ddddptl);
//        ii_prt_wb->set_function_cc(ST_PCDECL);
    }

    if(g_gc_at_call) {
        external_declaration *pgc_force = ::remove_decl_by_name("pgc_force_gc");
        if(pgc_force) {
            latest = translation_unit_translation_unit_external_declaration::new_recursive(latest,pgc_force);
        } else {
            aeprintf("pgc_force_gc.\n");
        }
    }

    ii_ptr ii_malloc_pillar2c_register = g_scope_stack.find_or_add("malloc_pillar2c_register");
    ii_malloc_pillar2c_register->add(IIT_FUNCTION);
    ii_ptr ii_memcpy_pillar2c_register = g_scope_stack.find_or_add("memcpy_pillar2c_register");
    ii_memcpy_pillar2c_register->add(IIT_FUNCTION);

    return latest;
}

translation_unit * gen_prepend_pillar(void) {
    translation_unit_external_declaration *g4_declaration =
        new translation_unit_external_declaration(
         new external_declaration_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
           new declaration_specifiers_storage_class_specifier_declaration_specifiers(
            new storage_class_specifier_TYPEDEF(),
            new declaration_specifiers_type_specifier(
             new type_specifier_INT())),
           new init_declarator_list_init_declarator(
            new init_declarator_declarator(
             new declarator_direct_declarator(
              new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("g4"))))))));

    translation_unit *latest = g4_declaration;

    std::set<unsigned>::iterator arg_iter;
    for(arg_iter  = g_prt_stub_arg_numbers.begin();
        arg_iter != g_prt_stub_arg_numbers.end();
        ++arg_iter) {

        struct_declarator_list *sdl = NULL;
        sdl =
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("arg0")))));

        unsigned num_args = *arg_iter;
        unsigned i;
        for(i=1;i<num_args;++i) {
            std::stringstream buf;
            buf << "arg" << i;

            struct_declarator *iter_sdl = NULL;
            iter_sdl =
                new struct_declarator_declarator(
                  new declarator_pointer_direct_declarator(
                    new pointer_star(),
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(buf.str()))));
           sdl = new struct_declarator_list_struct_declarator_list_struct_declarator(sdl,iter_sdl);
        }

        std::stringstream struct_buf;
        struct_buf << "PrtArgs" << num_args;

        external_declaration *this_decl = NULL;
        this_decl =
          new external_declaration_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_storage_class_specifier_declaration_specifiers(
                new storage_class_specifier_TYPEDEF(),
                new declaration_specifiers_type_specifier(
                  new type_specifier_struct_or_union_specifier(
                    new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                      new struct_or_union_STRUCT(),
                      new struct_declaration_list_struct_declaration(
                        new struct_declaration_specifier_qualifier_list_struct_declarator_list (
                          new specifier_qualifier_list_type_specifier(
                            new type_specifier_VOID()),
                          sdl)))))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(struct_buf.str())))))));

        latest = new translation_unit_translation_unit_external_declaration(latest,this_decl);
    }

    latest = new translation_unit_translation_unit_external_declaration(latest,g_pseudo_stack_decl);

    external_declaration *pillar2c_pcall_target_args =
        new external_declaration_declaration(
          new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_storage_class_specifier_declaration_specifiers(
              new storage_class_specifier_TYPEDEF(),
              new declaration_specifiers_type_specifier(
                new type_specifier_struct_or_union_specifier(
                  new struct_or_union_specifier_struct_or_union_struct_declaration_list(
                    new struct_or_union_STRUCT(),
                    new struct_declaration_list_struct_declaration_list_struct_declaration(
                      new struct_declaration_list_struct_declaration_list_struct_declaration(
                        new struct_declaration_list_struct_declaration_list_struct_declaration(
                          new struct_declaration_list_struct_declaration(
                            new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                              new specifier_qualifier_list_type_specifier( new type_specifier_VOID() ),
                              new struct_declarator_list_struct_declarator(
                                new struct_declarator_declarator(
                                  new declarator_pointer_direct_declarator(
                                    new pointer_star(),
                                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("func"))))))),
                          new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                            new specifier_qualifier_list_type_specifier( new type_specifier_VOID() ),
                            new struct_declarator_list_struct_declarator(
                              new struct_declarator_declarator(
                                new declarator_pointer_direct_declarator(
                                  new pointer_star(),
                                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("argStart"))))))),
                        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
#ifdef __x86_64__
                          new specifier_qualifier_list_type_specifier( new type_specifier_LONG() ),
#else  // __x86_64__
                          new specifier_qualifier_list_type_specifier( new type_specifier_UNSIGNED() ),
#endif // __x86_64__
                          new struct_declarator_list_struct_declarator(
                            new struct_declarator_declarator(
                              new declarator_direct_declarator(
                                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("argSize"))))))),
                          new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                            new specifier_qualifier_list_type_specifier( new type_specifier_VOID() ),
                            new struct_declarator_list_struct_declarator(
                              new struct_declarator_declarator(
                                new declarator_pointer_direct_declarator(
                                  new pointer_star(),
                                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("enumerator")))))))
                                )))),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator(
                new declarator_direct_declarator(
                  new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("pillar2c_pcall_target_args")))))));

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_pcall_target_args);

    // ==================================================================================================================================

    external_declaration *pillar2cInvokeUnmanagedFunc_prototype = NULL;
    if(g_gcc_compatible) {
        if(g_intel64) {
//            pillar2cInvokeUnmanagedFunc_prototype =
//                new external_declaration_emit_text("unsigned pillar2cInvokeUnmanagedFunc ( void * , void * , void * , void * , unsigned , unsigned ) ;\n");
        } else {
            if(g_use_th_param) {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned __attribute__((stdcall)) pillar2cInvokeUnmanagedFunc ( void * , void * , void * , void * , unsigned , unsigned ) ;\n");
            } else {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned __attribute__((stdcall)) pillar2cInvokeUnmanagedFunc ( void * , void * , void * , unsigned , unsigned ) ;\n");
            }
        }
    } else {
        if(g_intel64) {
            if(g_use_th_param) {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned pillar2cInvokeUnmanagedFunc ( void * , void * , void * , void * , unsigned , unsigned ) ;\n");
            } else {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned pillar2cInvokeUnmanagedFunc ( void * , void * , void * , unsigned , unsigned ) ;\n");
            }
        } else {
            if(g_use_th_param) {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned __stdcall pillar2cInvokeUnmanagedFunc ( void * , void * , void * , void * , unsigned , unsigned ) ;\n");
            } else {
                pillar2cInvokeUnmanagedFunc_prototype =
                    new external_declaration_emit_text("unsigned __stdcall pillar2cInvokeUnmanagedFunc ( void * , void * , void * , unsigned , unsigned ) ;\n");
            }
        }
    }
    if(pillar2cInvokeUnmanagedFunc_prototype) {
        g_scope_stack.find_or_add("pillar2cInvokeUnmanagedFunc");
        latest = new translation_unit_translation_unit_external_declaration(latest,pillar2cInvokeUnmanagedFunc_prototype);
    }

    // ==================================================================================================================================

    external_declaration *pillar2c_pcall_target_prototype = NULL;
    if(g_gcc_compatible) {
        if(g_intel64) {
            pillar2c_pcall_target_prototype =
                new external_declaration_emit_text("unsigned pillar2c_pcall_target ( void * , void * , unsigned ) ;\n");
        } else {
            pillar2c_pcall_target_prototype =
                new external_declaration_emit_text("unsigned __attribute__((stdcall)) pillar2c_pcall_target ( void * , void * , unsigned ) ;\n");
        }
    } else {
        if(g_intel64) {
            pillar2c_pcall_target_prototype =
                new external_declaration_emit_text("unsigned pillar2c_pcall_target ( void * , void * , unsigned ) ;\n");
        } else {
            pillar2c_pcall_target_prototype =
                new external_declaration_emit_text("unsigned __stdcall pillar2c_pcall_target ( void * , void * , unsigned ) ;\n");
        }
    }
    g_scope_stack.find_or_add("pillar2c_pcall_target");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_pcall_target_prototype);

    // ==================================================================================================================================

    external_declaration *pillar2c_pcall_arg_enumerator_prototype = NULL;
    if(g_gcc_compatible) {
        if(g_intel64) {
            pillar2c_pcall_arg_enumerator_prototype =
                new external_declaration_emit_text("void pillar2c_pcall_arg_enumerator ( void * , void * , void *, void * ) ;\n");
        } else {
            pillar2c_pcall_arg_enumerator_prototype =
                new external_declaration_emit_text("void __attribute__((cdecl)) pillar2c_pcall_arg_enumerator ( void * , void * , void *, void * ) ;\n");
        }
    } else {
        if(g_intel64) {
            pillar2c_pcall_arg_enumerator_prototype =
                new external_declaration_emit_text("void pillar2c_pcall_arg_enumerator ( void * , void * , void *, void * ) ;\n");
        } else {
            pillar2c_pcall_arg_enumerator_prototype =
                new external_declaration_emit_text("void __cdecl pillar2c_pcall_arg_enumerator ( void * , void * , void *, void * ) ;\n");
        }
    }
    g_scope_stack.find_or_add("pillar2c_pcall_arg_enumerator");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_pcall_arg_enumerator_prototype);

    // ==================================================================================================================================

    external_declaration *malloc_decl = ::find_decl_by_name("malloc");
    if(!malloc_decl) {
        printf("Declaration for malloc not found.\n");
    } else {
        external_declaration *malloc_pillar2c_register = new external_declaration_emit_text("static void * malloc_pillar2c_register(unsigned reg_count) { return malloc(reg_count * sizeof(void*)); }\n");
        malloc_decl->insert_after_top_level(malloc_pillar2c_register);
    }

    // ==================================================================================================================================

    external_declaration *memcpy_decl = ::find_decl_by_name("memcpy");
    if(!memcpy_decl) {
        printf("Declaration for memcpy not found.\n");
    } else {
        external_declaration *memcpy_pillar2c_register = new external_declaration_emit_text("static void * memcpy_pillar2c_register(void *OUT, const void *IN, unsigned reg_count) { return memcpy(OUT,IN,reg_count * sizeof(void*)); }\n");
        memcpy_decl->insert_after_top_level(memcpy_pillar2c_register);
    }

    // ==================================================================================================================================

    external_declaration *pillar2c_get_last_pseudo_proto = new external_declaration_emit_text("pillar2c_pseudo_stack_entry * pillar2c_get_last_pseudo(void);\n");
    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_get_last_pseudo_proto);

    // ==================================================================================================================================

    if(g_collect_read_stats) {
        external_declaration *gc_read_stats_prototype = NULL;
        if(g_gcc_compatible) {
            if(g_intel64) {
                gc_read_stats_prototype =
                    new external_declaration_emit_text("void * gc_heap_object_read_stats ( void * ) ;\n");
            } else {
                gc_read_stats_prototype =
                    new external_declaration_emit_text("void * __attribute__((stdcall)) gc_heap_object_read_stats ( void * ) ;\n");
            }
        } else {
            if(g_intel64) {
                gc_read_stats_prototype =
                    new external_declaration_emit_text("void * gc_heap_object_read_stats ( void * ) ;\n");
            } else {
                gc_read_stats_prototype =
                    new external_declaration_emit_text("void * __stdcall gc_heap_object_read_stats ( void * ) ;\n");
            }
        }
        g_scope_stack.find_or_add("gc_heap_object_read_stats");

        latest = new translation_unit_translation_unit_external_declaration(latest,gc_read_stats_prototype);
    }

    external_declaration *pillar2c_yield_prototype = NULL;
    if(g_gcc_compatible) {
        if(g_intel64) {
            if(g_use_th_param) {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void pillar2cYield ( void * , void * ) ;\n");
            } else {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void pillar2cYield ( void * ) ;\n");
            }
        } else {
            if(g_use_th_param) {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void __attribute__((stdcall)) pillar2cYield ( void * , void * ) ;\n");
            } else {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void __attribute__((stdcall)) pillar2cYield ( void * ) ;\n");
            }
        }
    } else {
        if(g_intel64) {
            if(g_use_th_param) {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void pillar2cYield ( void * , void * ) ;\n");
            } else {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void pillar2cYield ( void * ) ;\n");
            }
        } else {
            if(g_use_th_param) {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void __stdcall pillar2cYield ( void * , void * ) ;\n");
            } else {
                pillar2c_yield_prototype =
                    new external_declaration_emit_text("void __stdcall pillar2cYield ( void * ) ;\n");
            }
        }
    }
    g_scope_stack.find_or_add("pillar2cYield");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_yield_prototype);

#ifdef __x86_64__
    external_declaration *pillar2c_m2u_unwinder_prototype = NULL;
    if(g_gcc_compatible) {
        if(g_intel64) {
            pillar2c_m2u_unwinder_prototype =
                new external_declaration_emit_text("void pillar2c_m2u_unwinder( void * , void * ) ;\n");
        } else {
            aeprintf("not supported\n");
//            pillar2c_yield_prototype = new external_declaration_emit_text("void __attribute__((stdcall)) pillar2cYield ( void * , void * ) ;\n");
        }
    } else {
        aeprintf("not supported\n");
#if 0
        if(g_intel64) {
            pillar2c_yield_prototype =
                new external_declaration_emit_text("void pillar2cYield ( void * , void * ) ;\n");
        } else {
            pillar2c_yield_prototype =
                new external_declaration_emit_text("void __stdcall pillar2cYield ( void * , void * ) ;\n");
        }
#endif
    }
    g_scope_stack.find_or_add("pillar2c_m2u_unwinder");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_m2u_unwinder_prototype);
#endif // __x86_64__

    external_declaration *pillar2c_tls_offset_decl =
        new external_declaration_emit_text("unsigned g_pillar2c_tls_offset;\n");
    g_scope_stack.find_or_add("g_pillar2c_tls_offset");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar2c_tls_offset_decl);

    external_declaration *pillar_tls_offset_decl =
        new external_declaration_emit_text("unsigned g_pillar_tls_offset;\n");
    g_scope_stack.find_or_add("g_pillar_tls_offset");

    latest = new translation_unit_translation_unit_external_declaration(latest,pillar_tls_offset_decl);

    if(g_use_th_param) {
        latest = new translation_unit_translation_unit_external_declaration(latest,
                   new external_declaration_emit_text("#define PILLAR2C_TLS_FAST(x) (*(char **)((char*)_pillar2c_task_handle + g_pillar_tls_offset))\n")
                 );
    } else {
        latest = new translation_unit_translation_unit_external_declaration(latest,
                   new external_declaration_emit_text("#define PILLAR2C_TLS_FAST(x) (*(char **)((char*)prtGetTaskHandle() + g_pillar_tls_offset))\n")
                 );
    }
    g_scope_stack.find_or_add("PILLAR2C_TLS_FAST");

    latest = new translation_unit_translation_unit_external_declaration(latest,
        new external_declaration_emit_text("#if defined __GNUC__\n"
                                           "#define MEMORY_BARRIER __asm__ __volatile__ (\"\" : : : \"memory\");\n"
                                           "#elif defined __MSCVER__\n"
                                           "#include <intrin.h>\n"
                                           "#pragma intrinsic(_ReadWriteBarrier)\n"
                                           "#define MEMORY_BARRIER _ReadWriteBarrier();\n"
                                           "#elif defined __INTEL_COMPILER\n"
                                           "#define MEMORY_BARRIER __memory_barrier();\n"
                                           "#endif\n"));

    latest = new translation_unit_translation_unit_external_declaration(latest,
               new external_declaration_emit_text("void * __pillar2c_get_tailcall(void *task_handle, unsigned num_slots_needed);\n")
             );
    g_scope_stack.find_or_add("__pillar2c_get_tailcall");

    if(g_log_m2u) {
        latest = new translation_unit_translation_unit_external_declaration(latest,
                   new external_declaration_emit_text("void * __pillar2c_log_m2u(char *);\n")
                 );
        g_scope_stack.find_or_add("__pillar2c_log_m2u");
    }

    latest = new translation_unit_translation_unit_external_declaration(latest,
               new external_declaration_emit_text("typedef struct {\nshort active;\nshort tag;\nvoid * id;\n} _pillar2c_gen_ref_info;\n")
             );

    std::stringstream buf0;
    buf0 << "typedef struct {\nunsigned length;\n} _pillar2c_gen_ref_0;\n";

    latest = new translation_unit_translation_unit_external_declaration(latest,
               new external_declaration_emit_text(buf0.str()));

    std::set<unsigned>::iterator gen_ref_lengths_iter;
    for(gen_ref_lengths_iter  = g_gen_ref_lengths.begin();
        gen_ref_lengths_iter != g_gen_ref_lengths.end();
      ++gen_ref_lengths_iter) {
        std::stringstream buf;
        buf << "typedef struct {\nunsigned length;\n_pillar2c_gen_ref_info refs[" << *gen_ref_lengths_iter << "];\n} _pillar2c_gen_ref_" << *gen_ref_lengths_iter << ";\n";

        latest = new translation_unit_translation_unit_external_declaration(latest,
                   new external_declaration_emit_text(buf.str())
                 );
    }

    external_declaration *prt_calling_convention_enum = ::remove_decl_by_name("PrtCallingConvention");
    if(prt_calling_convention_enum) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_calling_convention_enum);
    } else {
        printf("PrtCallingConvention not found.\n");
    }

    external_declaration *prt_code_address = ::remove_decl_by_name("PrtCodeAddress");
    if(prt_code_address) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_code_address);
    } else {
        printf("PrtCodeAddress not found.\n");
    }

    external_declaration *prt_M2U = ::remove_decl_by_name("prtInvokeUnmanagedFunc");
    if(prt_M2U) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_M2U);
    } else {
        printf("prtInvokeUnmanagedFunc not found.\n");
    }

    external_declaration *prt_task_struct = ::remove_decl_by_name("PrtTaskStruct");
    if(prt_task_struct) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_task_struct);
    } else {
        printf("PrtTaskStruct not found.\n");
    }

    external_declaration *prt_task_handle = ::remove_decl_by_name("PrtTaskHandle");
    if(prt_task_handle) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_task_handle);
    } else {
        printf("PrtTaskHandle not found.\n");
    }

    external_declaration *prt_yield_unmanaged = ::remove_decl_by_name("prtYieldUnmanaged");
    if(prt_yield_unmanaged) {
        latest = new translation_unit_translation_unit_external_declaration(latest,prt_yield_unmanaged);
    } else {
        printf("prtYieldUnmanaged not found.\n");
    }

    return latest;
}

#define RT_NORMAL_FUNC(x) g_pillar_runtime_funcs.insert(std::pair<std::string,PILLAR_RUNTIME_FUNC_TYPE>(std::string(x),PILLAR_RUNTIME_FUNC_NORMAL));
#define RT_NO_DIRECT_CALL_FUNC(x) g_pillar_runtime_funcs.insert(std::pair<std::string,PILLAR_RUNTIME_FUNC_TYPE>(std::string(x),PILLAR_RUNTIME_FUNC_NO_DIRECT_CALL));

extern "C" void pre_parse(void) {
    g_cc_stack.push(ST_PDECL);

    ii_ptr g4 = g_scope_stack.find_or_add("g4");
    g4->add(IIT_TYPEDEF_VAR);
    g4->set_type(new type_specifier_INT(),true);

/*
    ii_ptr noop = g_scope_stack.find_or_add("__noop");
    noop->add(IIT_FUNCTION);
    noop->set_function_cc(ST_PCDECL);
*/

#ifndef __x86_64__
    ii_ptr pillar2cInvokeUnmanaged = g_scope_stack.find_or_add("pillar2cInvokeUnmanagedFunc");
    pillar2cInvokeUnmanaged->add(IIT_FUNCTION);
#endif // __x86_64__

#if 0
    //---------------------------------------------------------------------------------------
    ii_ptr pillar2c_write_barrier = g_scope_stack.find_or_add("pillar2c_write_barrier");
    pillar2c_write_barrier->add(IIT_FUNCTION);
    pillar2c_write_barrier->set_func_definition(
      new function_definition_no_decl_list(
        new declaration_specifiers_type_specifier(
          new type_specifier_VOID()),
        new declarator_direct_declarator(
          new direct_declarator_direct_declarator_empty_paren(
            new direct_declarator_IDENTIFIER(pillar2c_write_barrier))),
        new compound_statement_empty()));

    //---------------------------------------------------------------------------------------
    ii_ptr pillar2c_write_barrier_interior = g_scope_stack.find_or_add("pillar2c_write_barrier_interior");
    pillar2c_write_barrier_interior->add(IIT_FUNCTION);
    pillar2c_write_barrier_interior->set_func_definition(
      new function_definition_no_decl_list(
        new declaration_specifiers_type_specifier(
          new type_specifier_VOID()),
        new declarator_direct_declarator(
          new direct_declarator_direct_declarator_empty_paren(
            new direct_declarator_IDENTIFIER(pillar2c_write_barrier_interior))),
        new compound_statement_empty()));
#endif

    //---------------------------------------------------------------------------------------
    ii_ptr pillar2c_yield = g_scope_stack.find_or_add("pillar2cYield");
    pillar2c_yield->add(IIT_FUNCTION);
    pillar2c_yield->set_function_cc(ST_PDECL);
    pillar2c_yield->set_func_definition(
      new function_definition_no_decl_list(
        new declaration_specifiers_type_specifier(
          new type_specifier_VOID()),
        new declarator_direct_declarator(
          new direct_declarator_direct_declarator_empty_paren(
            new direct_declarator_IDENTIFIER(pillar2c_yield))),
        new compound_statement_empty()));

    //---------------------------------------------------------------------------------------
    ii_ptr pillar2c_pcall = g_scope_stack.find_or_add("pillar2c_pcall_target");
    pillar2c_pcall->add(IIT_FUNCTION);

    // prt.h functions
    RT_NORMAL_FUNC("prtInit");
    RT_NORMAL_FUNC("prtStart");
    RT_NORMAL_FUNC("prtSetOption");
    RT_NORMAL_FUNC("prtExit");
    RT_NORMAL_FUNC("prtGetTls");
    RT_NORMAL_FUNC("prtSetTls");
    RT_NORMAL_FUNC("prtGetTlsForTask");
    RT_NORMAL_FUNC("prtSetTlsForTask");
    RT_NORMAL_FUNC("prtGetTaskHandle");
    RT_NORMAL_FUNC("prtRegisterTaskExistenceCallback");
    RT_NORMAL_FUNC("prtRegisterTaskSplitCallback");
    RT_NORMAL_FUNC("prtEnablePrscallStealing");
    RT_NORMAL_FUNC("prtDisablePrscallStealing");
    RT_NORMAL_FUNC("prtYieldUnmanaged");
    RT_NORMAL_FUNC("prtCheckStackIntegrity");
    RT_NORMAL_FUNC("prtThinCutTo");
    RT_NORMAL_FUNC("prtYoungestActivationFromUnmanaged");
    RT_NORMAL_FUNC("prtYoungestActivationFromUnmanagedInTask");
    RT_NORMAL_FUNC("prtNextActivation");
    RT_NORMAL_FUNC("prtIsActivationPastEnd");
    RT_NORMAL_FUNC("prtGetActivationIP");
    RT_NORMAL_FUNC("prtSetStackIteratorFields");
    RT_NORMAL_FUNC("prtMarkFrameAsVisited");
    RT_NORMAL_FUNC("prtHasFrameBeenVisited");
    RT_NORMAL_FUNC("prtGetUnwindContinuation");
    RT_NORMAL_FUNC("prtGetSpanDescriptor");
    RT_NORMAL_FUNC("prtGetActivationString");
    RT_NORMAL_FUNC("prtEnumerateRootsOfActivation");
    RT_NORMAL_FUNC("prtEnumerateVseRootsOfTask");
    RT_NORMAL_FUNC("prtEnumerateTaskRootSet");
    RT_NORMAL_FUNC("prtEnumerateTlsRootSet");
    RT_NORMAL_FUNC("prtEnumerateGlobalRootSet");
    RT_NORMAL_FUNC("prtRegisterGlobalEnumerator");
    RT_NORMAL_FUNC("prtRegisterTlsEnumerator");
    RT_NORMAL_FUNC("prtRegisterVseRseFunction");
    RT_NORMAL_FUNC("prtGetVsh");
    RT_NORMAL_FUNC("prtPushVse");
    RT_NORMAL_FUNC("prtPopVse");
    RT_NORMAL_FUNC("prtGetVseType");
    RT_NORMAL_FUNC("prtGetNextVse");
    RT_NORMAL_FUNC("prtGetTaskSet");
    RT_NORMAL_FUNC("prtReleaseTaskSet");
    RT_NORMAL_FUNC("prtStartIterator");
    RT_NORMAL_FUNC("prtNextIterator");
    RT_NORMAL_FUNC("prtGetNextTlsOffset");
    RT_NORMAL_FUNC("prtSuspendTask");
    RT_NORMAL_FUNC("prtResumeTask");
    RT_NORMAL_FUNC("prtHandoffReacquireStackLock");
    RT_NORMAL_FUNC("prtVtunePause");
    RT_NORMAL_FUNC("prtVtuneResume");
    RT_NORMAL_FUNC("prtPcall");
    // prtcodegenerator.h functions
    RT_NORMAL_FUNC("prtYieldUntilMovable");
    RT_NORMAL_FUNC("prtYieldUntil");
    RT_NORMAL_FUNC("prtYield");
    // GC functions
    RT_NORMAL_FUNC("gc_heap_slot_write_barrier_indirect");
    RT_NORMAL_FUNC("gc_heap_slot_write_interior_indirect");
    RT_NORMAL_FUNC("gc_cas_write_barrier_indirect");
    RT_NORMAL_FUNC("gc_cas_write_interior_indirect");
    RT_NORMAL_FUNC("orp_local_to_gc_local");

    // prt.h functions
//    RT_NO_DIRECT_CALL_FUNC("prtPcall");
    RT_NO_DIRECT_CALL_FUNC("prtInvokeManagedFunc");
    RT_NO_DIRECT_CALL_FUNC("prtFatCutTo");
    // prtcodegenerator.h functions
    RT_NO_DIRECT_CALL_FUNC("prtGetStackLimit");
    RT_NO_DIRECT_CALL_FUNC("prtInvokeUnmanagedFunc");
    RT_NO_DIRECT_CALL_FUNC("prtSystemCall");
    RT_NO_DIRECT_CALL_FUNC("prtPrscall");
//    RT_NO_DIRECT_CALL_FUNC("prtYield");
    RT_NO_DIRECT_CALL_FUNC("prtExtendStack");
    RT_NO_DIRECT_CALL_FUNC("prtRegisterCodeInfoManager");
    RT_NO_DIRECT_CALL_FUNC("prtAddCodeRegion");
    RT_NO_DIRECT_CALL_FUNC("prtAddEipUnwinder");
    RT_NO_DIRECT_CALL_FUNC("prtAddEipRse");

    // Pillar runtime functions using task pointer in ebx.
    // prtYield
    // prtInvokeManagedFunc
    // prtInvokeUnmanagedFunc
    // prtExtendStack
    // prtPrscall

    struct_declaration *sd_ref_mask_ptr =
        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
            new type_specifier_VOID()),
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("ref_mask_ptr"))))));

    struct_declaration *sd_fake_reg =
        new struct_declaration_specifier_qualifier_list_struct_declarator_list(
          new specifier_qualifier_list_type_specifier(
            new type_specifier_VOID()),
          new struct_declarator_list_struct_declarator(
            new struct_declarator_declarator(
              new declarator_pointer_direct_declarator(
                new pointer_star(),
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("fake_eip_target"))))));

    ii_ptr ppse_ii = NULL;
    declarator *ppse_decl = NULL;

    g_pseudo_stack_decl =
    new external_declaration_declaration(
      new declaration_declaration_specifiers_init_declarator_list(
        new declaration_specifiers_storage_class_specifier_declaration_specifiers(
          new storage_class_specifier_TYPEDEF(),
          new declaration_specifiers_type_specifier(
            new type_specifier_struct_or_union_specifier(
              new struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(
                new struct_or_union_STRUCT(),
                "_pillar2c_pseudo_stack_entry",
                 new struct_declaration_list_struct_declaration_list_struct_declaration(
#ifdef PREV_OPT
                  new struct_declaration_list_struct_declaration(
#else  // PREV_OPT
                  new struct_declaration_list_struct_declaration_list_struct_declaration(
                   new struct_declaration_list_struct_declaration(
                     new struct_declaration_specifier_qualifier_list_struct_declarator_list(
                       new specifier_qualifier_list_type_specifier(
                         new type_specifier_struct_or_union_specifier(
                           new struct_or_union_specifier_struct_or_union_identifier(
                             new struct_or_union_STRUCT(),
                             "_pillar2c_pseudo_stack_entry"))),
                       new struct_declarator_list_struct_declarator(
                         new struct_declarator_declarator(
                           new declarator_pointer_direct_declarator(
                             new pointer_star(),
                             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add("prev"))))))),
#endif // PREV_OPT
                   sd_fake_reg),
                  sd_ref_mask_ptr))))),
        new init_declarator_list_init_declarator(
          new init_declarator_declarator(ppse_decl =
            new declarator_direct_declarator(
              new direct_declarator_IDENTIFIER(ppse_ii = g_scope_stack.find_or_add("pillar2c_pseudo_stack_entry")))))));
    ppse_ii->add(IIT_STRUCT_ENUM);
    ppse_ii->set_declarator(ppse_decl);

} // pre_parse

void translation_unit_external_declaration::insert_before_top_level(external_declaration *ed) {
    translation_unit_translation_unit_external_declaration *parent =
        dynamic_cast<translation_unit_translation_unit_external_declaration *>(m_parent);

    translation_unit_translation_unit_external_declaration *new_node = new
        translation_unit_translation_unit_external_declaration(this,m_ed);
    m_ed = ed;
    m_ed->set_parent(this);

    if(parent) {
        parent->m_tu = new_node;
        new_node->set_parent(parent);
    } else {
        aeprintf("insert_before_top_level should not be called when using the top-level list.\n");
    }
}

compound_statement * compound_statement_empty::prepend_bil(block_item_list *bil) {
    compound_statement_block_item_list *new_node =
        new compound_statement_block_item_list(bil);
    m_parent->replace(this,new_node);
    delete this;
    return new_node;
}

void declaration_declaration_specifiers_init_declarator_list::sub_destroyed(AST_node *node) {
    if(node == m_idl) {
        delete m_idl;
        m_idl = NULL;
        delete m_ds;
        m_ds = NULL;

        m_parent->sub_destroyed(this);
    } else if(node == m_ds) {
        delete m_idl;
        m_idl = NULL;
        delete m_ds;
        m_ds = NULL;

        m_parent->sub_destroyed(this);
    } else {
        aeprintf("sub_destroyed\n");
    }
}

void block_item_list_block_item::sub_destroyed(AST_node *node) {
    if(node == m_bi) {
        delete m_bi;
        m_bi = NULL;

        block_item_list_block_item_list_block_item *bbb =
            dynamic_cast<block_item_list_block_item_list_block_item*>(m_parent);
        if(bbb) {
            m_bi = bbb->m_bi;
            m_bi->set_parent(this);
            bbb->m_bi  = NULL;
            bbb->m_bil = NULL;
            AST_node *bbb_parent = bbb->m_parent;
            bbb_parent->replace(bbb,this);
            delete bbb;
            throw redo(bbb_parent);
        } else {
            m_parent->sub_destroyed(this);
        }
    } else {
        aeprintf("sub_destroyed\n");
    }
}

void block_item_list_block_item_list_block_item::sub_destroyed(AST_node *node) {
    if(node == m_bi) {
        delete m_bi;
        m_bi = NULL;

        AST_node *node_redo = m_parent;
        m_parent->replace(this,m_bil);
        m_bil = NULL;
        delete this;
        throw done(node_redo);
    } else if(node == m_bil) {
        aeprintf("I don't think this can possibly happen.\n");
    } else {
        aeprintf("sub_destroyed\n");
    }
}

compound_statement * compound_statement_empty::insert_post_declarations(block_item_list *bil) {
    compound_statement_block_item_list * new_node =
       new compound_statement_block_item_list(bil);
    m_parent->replace(this,new_node);
    delete this;
    return new_node;
}

void block_item_list_block_item::insert_post_declarations(block_item_list *bil) {
    block_item_declaration *bid = dynamic_cast<block_item_declaration*>(m_bi);
    if(bid) {
        block_item_list *old_bil = this;
        m_parent->replace(this,bil);

        block_item_list *cur_bil = bil;
        block_item_list_block_item_list_block_item *bilbilbi = NULL;
        do {
            bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(cur_bil);
            if(bilbilbi) {
                cur_bil = bilbilbi->m_bil;
            }
        } while (bilbilbi);

        // cur_bil now points at the block_item_list_block_item
        block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(cur_bil);
        assert(bilbi);

        block_item_list_block_item_list_block_item *new_node = new
          block_item_list_block_item_list_block_item(old_bil,bilbi->m_bi);
        bilbi->m_parent->replace(bilbi,new_node);

        bilbi->m_bi = NULL;
        delete bilbi;
    } else {
        // Must be a statement and must be the first thing in the block.
        block_item_list_block_item_list_block_item *new_node = new
          block_item_list_block_item_list_block_item(bil,m_bi);

        m_parent->replace(this,new_node);

        m_bi = NULL;
        delete this;
    }
} // block_item_list_block_item::insert_post_declarations

void block_item_list_block_item_list_block_item::insert_post_declarations(block_item_list *bil) {
    block_item_declaration *bid = dynamic_cast<block_item_declaration*>(m_bi);
    if(bid) {
        block_item_list *old_bil = this;
        m_parent->replace(this,bil);

        block_item_list *cur_bil = bil;
        block_item_list_block_item_list_block_item *bilbilbi = NULL;
        do {
            bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(cur_bil);
            if(bilbilbi) {
                cur_bil = bilbilbi->m_bil;
            }
        } while (bilbilbi);

        // cur_bil now points at the block_item_list_block_item
        block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(cur_bil);
        assert(bilbi);

        block_item_list_block_item_list_block_item *new_node = new
          block_item_list_block_item_list_block_item(old_bil,bilbi->m_bi);
        bilbi->m_parent->replace(bilbi,new_node);

        bilbi->m_bi = NULL;
        delete bilbi;
    } else {
        // must be a statement...but is it the first one?
        m_bil->insert_post_declarations(bil);
    }
} //block_item_list_block_item_list_block_item::insert_post_declarations

#if 0
void jump_statement_prt_cut_to::translate_pillar(function_definition *fd) {
    TRANSLATE(m_ae);

    type_specifier_continuation *tsc = dynamic_cast<type_specifier_continuation *>(m_ae->get_type());
    if(!tsc) {
        aeprintf("cut to called on a non-continuation variable.\n");
    }

    // We have to verify that the tree is structured with a statement as our parent and block-item above that
    // because we are going to replace statement_jump_statement with statement_expression_statement and
    // we have to know that the passing back up the translate_pillar tree through deleted nodes won't be a
    // problem.
    statement *one_node_up = dynamic_cast<statement *>(m_parent);
    if(!one_node_up) {
        aeprintf("Pillar cut to translation found non-statement as parent.\n");
    }

    AST_node *two_nodes_up = one_node_up->get_parent();
    assert(two_nodes_up);

    statement *new_node =
      new statement_expression_statement(
       new expression_statement_expression(
        new expression_assignment_expression(
         expr_gen(assignment_expression,postfix_expression,
                       new postfix_expression_call_expression(
                        new call_expression_postfix_expression_paren_argument_expression_list(
                         new postfix_expression_primary_expression(
                          new primary_expression_identifier(g_scope_stack.find_or_add("prtFatCutTo"))),
                         new argument_expression_list_assignment_expression(m_ae)))))));

    two_nodes_up->replace(one_node_up,new_node);

    m_ae = NULL;
    delete one_node_up;

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        cur_bb->add_item(this);
    }
} // jump_statement_prt_cut_to::translate_pillar
#endif

TranslateResult jump_statement_prt_cut_to_argument_expression_list::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    TRANSLATE(m_ae,tr1);
    if(m_ael) {
        TRANSLATE(m_ael,tr2);
    }

    basic_block *ret_bb = get_return_target();
    assert(ret_bb);

    check_vector<type_specifier*> ts_vec;

    auto_ptr<expression_type> expr_type(m_ae->get_type());
    // Allow "cut to" of a void pointer for backwards compatability.
    if(!expr_type->is_void_pointer()) {
#ifdef USE_ET_BASE
        auto_ptr<expression_type> base_apet(expr_type->get_base_type());
        if(base_apet->m_ad) {
            aeprintf("cut to called on a non-continuation variable (pointer).\n");
        }

        type_specifier *base_type = base_apet->m_sql->get_type_specifier();
#else
        if(expr_type->m_ad) {
            aeprintf("cut to called on a non-continuation variable (pointer).\n");
        }

        type_specifier *base_type = expr_type->m_sql->get_type_specifier()->get_base_type();
#endif
        if(!base_type) {
            aeprintf("Problem in jump_statement_prt_cut_to_argument_expression_list::translate_pillar. Couldn't find base type.\n");
        }

        type_specifier_continuation *tsc = dynamic_cast<type_specifier_continuation *>(base_type);
        if(!tsc) {
            type_specifier_INT *tsi = dynamic_cast<type_specifier_INT*>(base_type);
            if(!tsi) {
                aeprintf("cut to called on a non-continuation variable.\n");
            }
        } else {
            continuation_var_type *cvt = tsc->get_var_type();
            cvt->get_types(ts_vec);
        }
    }

    check_vector<assignment_expression *> arg_vec;
    if(m_ael) {
        m_ael->vectorize(arg_vec);
    }

    // type check
    if(ts_vec.size() != arg_vec.size()) {
        aeprintf("Mismatch between the continuation args and the args in the cut to expression.\n");
    }

    std::stringstream cont_decl_name;
    cont_decl_name << "_pillar2c_continuation_type_cut_to_" << this->get_unique();

    std::stringstream temp_cont_name;
    temp_cont_name << "_pillar2c_temp_cont_" << this->get_unique();

    if(m_ael) {
        std::stringstream cont_decl_str;
        cont_decl_str << "typedef struct {\nPrtCodeAddress eip;\nPrtVseHandle vsh;\n";
        if(!g_use_try_except) {
            cont_decl_str << "jmp_buf cont_jump_buf;\n";
        }
        unsigned flat_index;
        for(flat_index = 0; flat_index < ts_vec.size(); ++flat_index) {
            type_specifier *ts = ts_vec[flat_index];
            assert(ts);
            cont_decl_str << *ts << " param" << flat_index << ";\n";
        }
        cont_decl_str << "} " << cont_decl_name.str() << ";\n";

        external_declaration *cont_decl = new external_declaration_emit_text(cont_decl_str.str());
        fd->insert_before_top_level(cont_decl);

        std::stringstream temp_cont_decl;
        temp_cont_decl << "void * " << temp_cont_name.str() << ";\n";

        fd->prepend_bil(
            new block_item_list_block_item(
              new block_item_text(temp_cont_decl.str())));
    }

    // We have to verify that the tree is structured with a statement as our parent and block-item above that
    // because we are going to replace statement_jump_statement with statement_expression_statement and
    // we have to know that the passing back up the translate_pillar tree through deleted nodes won't be a
    // problem.
    statement *one_node_up = dynamic_cast<statement *>(m_parent);
    if(!one_node_up) {
        aeprintf("Pillar cut to translation found non-statement as parent.\n");
    }

    AST_node *two_nodes_up = one_node_up->get_parent();
    assert(two_nodes_up);

    expression *new_node = NULL;

    if(m_ael) {
        new_node =
          new expression_assignment_expression(
            new assignment_expression_unary_expression_assignment_operator_assignment_expression(
              expr_gen(unary_expression,primary_expression,
                new primary_expression_identifier(g_scope_stack.find_or_add(temp_cont_name.str()))
              ),
              new assignment_operator_equal(),
              m_ae
            )
          );

        unsigned flat_index;
        for(flat_index = 0; flat_index < ts_vec.size(); ++flat_index) {
            type_specifier *ts = ts_vec[flat_index];
            assert(ts);
            assignment_expression *ae = arg_vec[flat_index];
            assert(ae);

            std::stringstream field_name;
            field_name << "param" << flat_index;

            assignment_expression *new_ae =
                new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                  new unary_expression_postfix_expression(
                    new postfix_expression_postfix_expression_ptr_op_identifier(
                      new postfix_expression_primary_expression(
                        new primary_expression_expression(
                          new expression_assignment_expression(
                            expr_gen(assignment_expression,cast_expression,
                              new cast_expression_type_name_cast_expression(
                                new type_name_specifier_qualifier_list_abstract_declarator(
                                  new specifier_qualifier_list_type_specifier(
                                    new type_specifier_TYPE_NAME(
                                      g_scope_stack.find_or_add(cont_decl_name.str()))),
                                  new abstract_declarator_pointer(
                                    new pointer_star())),
                                expr_gen(cast_expression,primary_expression,
                                  new primary_expression_identifier(g_scope_stack.find_or_add(temp_cont_name.str())))))))),
                      field_name.str())),
                  new assignment_operator_equal(),
                  ae);

            new_node = expression_expression_assignment_expression::new_recursive(new_node,new_ae);
        }
    }

    if(new_node) {
      new_node = new expression_expression_assignment_expression(
        new_node,
        expr_gen(assignment_expression,postfix_expression,
          new postfix_expression_call_expression(
            new call_expression_postfix_expression_paren_argument_expression_list(
              new postfix_expression_primary_expression(
                new primary_expression_identifier(g_scope_stack.find_or_add("prtFatCutTo"))
              ),
              new argument_expression_list_assignment_expression(
                expr_gen(assignment_expression,primary_expression,
                  new primary_expression_identifier(g_scope_stack.find_or_add(temp_cont_name.str()))))))));
    } else {
      new_node = new expression_assignment_expression(
        expr_gen(assignment_expression,postfix_expression,
          new postfix_expression_call_expression(
            new call_expression_postfix_expression_paren_argument_expression_list(
              new postfix_expression_primary_expression(
                new primary_expression_identifier(g_scope_stack.find_or_add("prtFatCutTo"))
              ),
              new argument_expression_list_assignment_expression(
                m_ae)))));
    }

    statement *the_new_stmt = NULL;

    two_nodes_up->replace(one_node_up,
        the_new_stmt = new statement_expression_statement(
          new expression_statement_expression(new_node)
        )
      );

    the_new_stmt->add_to_statement_cut(m_id_vec);
    the_new_stmt->generate_filters(fd);

    if(!fd->m_has_except_var) {
        fd->m_has_except_var = true;

        block_item_list *bil =
            new block_item_list_block_item(
                new block_item_text(std::string("void *_pillar2c_except_var;\n"))
            );

        fd->prepend_bil(bil);
    }

    m_ae = NULL;

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, ret_bb, EDGE_CUT);
    }

    unsigned cut_index;
    for(cut_index = 0; cut_index < m_id_vec.size(); ++cut_index) {
        basic_block *cont_block = m_id_vec[cut_index]->get_block_for_continuation();
        if(!cont_block) {
            cont_block = new basic_block(NULL);
            m_id_vec[cut_index]->set_block_for_continuation(cont_block);
        } else {
//                cont_block->set_first_item(NULL);
        }
        if(cur_bb) {
            add_flow_graph_edge(cur_bb, cont_block, EDGE_CUT);
        }
    }

    fd->set_cur_basic_block(NULL);

    delete one_node_up;
    throw done(two_nodes_up);
    return TranslateResult();
}

void jump_statement_prt_tailcall::create_call_graph(function_definition *fd) {
    // Get the function that this function call takes place in.
    assert(fd);

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();
    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(fd->get_function_cc() != ST_PDECL) {
        aeprintf("Tailcall must be from a managed function.\n");
    }
    if(callee_cc != ST_PDECL) {
        aeprintf("Tailcall must be to a managed function.\n");
    }

    fd->set_gc_unsafe();
    std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(m_ce->get_func_name());
    if(fmiter != g_func_map.end()) {
        fmiter->second->add_call_by(fd);
    }
}

void statement_prt_tailcall::create_call_graph(function_definition *fd) {
    // Get the function that this function call takes place in.
    assert(fd);

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();
    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(fd->get_function_cc() != ST_PDECL) {
        aeprintf("Tailcall must be from a managed function.\n");
    }
    if(callee_cc != ST_PDECL) {
        aeprintf("Tailcall must be to a managed function.\n");
    }

    fd->set_gc_unsafe();
    std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(m_ce->get_func_name());
    if(fmiter != g_func_map.end()) {
        fmiter->second->add_call_by(fd);
    }
}

void translate_tailcall(call_expression *m_ce, function_definition *fd, statement *stmt_parent, jump_statement *jump);

TranslateResult jump_statement_prt_tailcall::translate_pillar(function_definition *fd) {
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();

    basic_block *ret_bb = get_return_target();
    assert(ret_bb);

    add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

    TranslateResult tr;

    TRANSLATE(m_ce,tr);

    statement *stmt = dynamic_cast<statement *>(m_parent);
    assert(stmt);

    translate_tailcall(m_ce,fd,stmt,this);
    return tr;
}

TranslateResult statement_prt_tailcall::translate_pillar(function_definition *fd) {
    base_translate(fd);

    TranslateResult tr;

    TRANSLATE(m_ce,tr);

    if(tr.m_et.get() && !tr.m_et->is_void()) {
        aeprintf("Error: tailcall call_expression() returns non-void type but is not preceded by a return statement.\n");
    }

    translate_tailcall(m_ce,fd,this,NULL);
    return tr;
}

unsigned g_tailcalls_translated = 0;
unsigned g_tailcalls_as_tailcalls = 0;
unsigned g_tailcalls_as_normal_calls = 0;
unsigned g_tailcalls_topo = 0;
unsigned g_tailcalls_non_topo = 0;
unsigned g_tailcalls_topo_known_params = 0;
unsigned g_tailcalls_topo_caller_large_enough = 0;
unsigned g_tailcalls_topo_cycles_broken = 0;

void translate_tailcall(call_expression *m_ce, function_definition *fd, statement *stmt_parent, jump_statement *jump) {
    std::string callee_func_name = m_ce->get_func_name();

    if(callee_func_name == "prtYield") {
        aeprintf("Tailcalls to prtYield forbidden.\n");
    }

    assert(fd);

    std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(callee_func_name);
    function_definition *callee_func_def = NULL;
    if(fmiter != g_func_map.end()) {
        callee_func_def = fmiter->second;
    }

    bool implement_as_tailcall = false;
    if(g_tailcall_implementation && g_bypass_limit) {
        implement_as_tailcall = true;
    }
    if(callee_func_def && !fd->has_same_scc_number(callee_func_def)) {
        implement_as_tailcall = false;
    }

    ++g_tailcalls_translated;
    if(implement_as_tailcall) {
        ++g_tailcalls_as_tailcalls;
        --g_bypass_limit;
        if(!g_bypass_limit) {
            g_tailcall_implementation = 0;
        }
    } else {
        ++g_tailcalls_as_normal_calls;
    }

#ifdef __x86_64__
    unsigned arg_index;

    check_vector<std::string> destination_args;

    {
        call_expression *working = m_ce->clone();
        // We need this postfix expression because if the call_expression doesn't have any args
        // then the following prepend_arg_list will try to update the parent of the call_expression.
        postfix_expression_call_expression *pece = new postfix_expression_call_expression(working);
        argument_expression_list *ael = gen_extra_args(true);
        working = working->prepend_arg_list(ael);

        auto_ptr<call_expression_metadata> cem64(working->get_call_metadata());

#if 0
        printf("------------------------\n");
        working->print();
        printf("\n");
#endif

        delete pece;

        short next_int_reg = 0, next_float_reg = 0;
        for(arg_index = 0; arg_index < cem64->m_args.size(); ++arg_index) {
            expression_type *et = NULL;
            if(arg_index < cem64->m_func_metadata.m_params.size()) {
#if 0
                cem64->m_func_metadata.m_params[arg_index]->print();
                printf("\n");
#endif
                et = cem64->m_func_metadata.m_params[arg_index]->get_type();
#if 0
                et->print();
                printf("\n");
#endif
            } else {
#if 0
                cem64->m_args[arg_index]->print();
                printf("\n");
#endif
                et = cem64->m_args[arg_index]->get_type();
#if 0
                et->print();
                printf("\n");
#endif
            }
            if(!et) {
                printf("Failed to get argument type. Function %s. Argument %d\n",fd->get_symbol()->get_name(),arg_index);
                aeprintf("Arguments to tailcalled functions that are not of int or float type are not currently supported.\n");
            }

            auto_ptr<expression_type> apet(et);
            auto_ptr<expression_type> base_apet(et->get_base_type());
            if(!base_apet.get()) {
                printf("Failed to get base argument type. Function %s. Argument %d\n",fd->get_symbol()->get_name(),arg_index);
                aeprintf("Arguments to tailcalled functions that are not of int or float type are not currently supported.\n");
            }

#if 0
            base_apet->print();
            printf("\n");
#endif
            bool is_float_arg  = false;
            bool float_exactly = false;
            bool is_int_arg    = false;

            if(base_apet->is_pointer()) {
                is_int_arg = true;
            } else {
                // This asks if it is a float or a double.
                if(base_apet->is_float_type()) {
                    // This says float or double.
                    is_float_arg = true;
                    // This clarifies to which one it is.
                    float_exactly = base_apet->is_float();
                } else if(base_apet->is_int_type()) {
                    is_int_arg = true;
                }
            }
            if(!is_float_arg && !is_int_arg) {
                printf("Function %s. Argument %d\n",fd->get_symbol()->get_name(),arg_index);
                aeprintf("Arguments to tailcalled functions that are not of int or float type are not currently supported.\n");
            }

            std::stringstream dest_reg;
            if(is_float_arg) {
                if(next_float_reg > 7) {
                    implement_as_tailcall = false;
                    printf("Cannot implement calls to function %s as tailcalls due to too many floating point arguments...reverting to normal calls.\n",fd->get_symbol()->get_name());
                    goto end_64_arg_regs;
                } else {
                    if(g_mic_compatible) {
                        if(float_exactly) {
                            // Nothing special for floats.
                            dest_reg << "zmm" << next_float_reg;
                        } else {
                            // Encode type in register string.  "double " will be removed later.
                            dest_reg << "double zmm" << next_float_reg;
                        }
                    } else {
                        dest_reg << "xmm" << next_float_reg;
                    }
                    ++next_float_reg;
                }
            } else {
                switch(next_int_reg) {
                case 0:
                    dest_reg << "rdi";
                    break;
                case 1:
                    dest_reg << "rsi";
                    break;
                case 2:
                    dest_reg << "rdx";
                    break;
                case 3:
                    dest_reg << "rcx";
                    break;
                case 4:
                    dest_reg << "r8";
                    break;
                case 5:
                    dest_reg << "r9";
                    break;
                default:
                    implement_as_tailcall = false;
                    printf("Cannot implement calls to function %s as tailcalls due to too many integer arguments...reverting to normal calls.\n",fd->get_symbol()->get_name());
                    goto end_64_arg_regs;
                }
                ++next_int_reg;
            }
            destination_args.push_back(dest_reg.str());
        }

        end_64_arg_regs: ;
    }
#endif // __x86_64__

    if(g_pillar2c_debug_level > 2) {
        printf("//jump_statement_prt_tailcall::translate_pillar\n");
        printf("// fd = %p, name = %s\n",fd,fd->get_symbol()->get_name());
        printf("// Parent CC = %s, Callee CC = %s\n",cc_to_str(fd->get_function_cc()),cc_to_str(m_ce->get_call_cc()));
    }

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();
    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(fd->get_function_cc() != ST_PDECL) {
        aeprintf("Tailcall must be from a managed function.\n");
    }
    if(callee_cc != ST_PDECL) {
        aeprintf("Tailcall must be to a managed function.\n");
    }

    if(!implement_as_tailcall) {
        if(jump) {
            m_ce->get_parent()->replace(m_ce,NULL);

            AST_node *jmp_parent = jump->get_parent();

            postfix_expression_call_expression *pe;

            jump_statement *new_node =
                new jump_statement_return_expression(
                  new expression_assignment_expression(
                    expr_gen(assignment_expression, postfix_expression, pe = new postfix_expression_call_expression(m_ce))));

            jmp_parent->replace(jump,new_node);

            pe->translate_call(fd);

            basic_block *cur_bb = fd->get_cur_basic_block();
            if(cur_bb) {
                basic_block *ret_bb = stmt_parent->get_return_target();
                assert(ret_bb);

                add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

                fd->set_cur_basic_block(NULL);
            }

            delete jump;
            throw done(jmp_parent);
        } else {
            m_ce->get_parent()->replace(m_ce,NULL);

            postfix_expression_call_expression *pe;

            statement *new_stmt = new statement_expression_statement(
                new expression_statement_expression(
                  new expression_assignment_expression(
                    expr_gen(assignment_expression,postfix_expression, pe = new postfix_expression_call_expression(m_ce))
                  )
                )
            );

            AST_node *stmt_gp = stmt_parent->get_parent();

            stmt_gp->replace(stmt_parent,new_stmt);

            pe->translate_call(fd);

            basic_block *cur_bb = fd->get_cur_basic_block();
            if(cur_bb) {
                cur_bb->add_item(new_stmt);
            }

            delete stmt_parent;
            throw done(stmt_gp);
        }
    } else {
        std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE>::iterator iter;
        call_expression *te_ce = m_ce->clone();
        auto_ptr<postfix_expression_call_expression> pece(new postfix_expression_call_expression(te_ce));

        iter = g_pillar_runtime_funcs.find(te_ce->get_func_name());
        if(iter == g_pillar_runtime_funcs.end()) {
            std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(te_ce->get_func_name());
            if(fmiter == g_func_map.end()) {
                assert(!fd->is_gc_safe());
                ++g_unsafe_calls;
                // one managed function calling another. add the two extra args
                argument_expression_list *ael = gen_extra_args(implement_as_tailcall);
                te_ce = te_ce->prepend_arg_list(ael);
            } else {
                if(!fmiter->second->is_gc_safe()) {
                    assert(!fd->is_gc_safe());
                    ++g_unsafe_calls;
                    // one managed function calling an unsafe GC one. add the two extra args
                    argument_expression_list *ael = gen_extra_args(implement_as_tailcall);
                    te_ce = te_ce->prepend_arg_list(ael);
                } else {
                    aeprintf("No tailcall should be a safe call.\n");
                    ++g_safe_calls;
                }
            }
        } else {
            aeprintf("Tailcalls to Pillar runtime functions not allowed.\n");
        }

        // Version 2 of the tailcall implementation.

//        te_ce->print();
//        printf("%s %s\n",fd->get_symbol()->get_string().c_str(),te_ce->get_func_name().c_str());
        if(fd->get_symbol()->get_string() == te_ce->get_func_name()) {
    //        printf("Found self-recursive call.\n");
        }

        if(fd->get_symbol()->get_string() == "v187647_tslam") {
//            printf("Found bad tailcall for debugging.\n");
        }

        function_metadata this_func_meta;
        fd->get_func_metadata(this_func_meta);

        // Get the function expression and a vector of function arguments.
        auto_ptr<call_expression_metadata> cem(te_ce->get_call_metadata());
    //    cem.print();

        size_t callee_num_args = cem->m_args.size();
        if(callee_num_args < get_num_p2c_added_params()) {
            aeprintf("Tailcalls should have at least %d arguments.\n",get_num_p2c_added_params());
        }

        unsigned fd_param_size, ce_param_size, fd_ce_diff;
        std::vector<unsigned> topo_order;
        std::map<unsigned,std::string> args_to_presave;
        bool topo_success = false;
        std::vector<name_offset> fd_offsets, ce_offsets;
        // If we can determine the size of all the params to the caller and the callee...
        if( g_use_topo_tailcall &&
            g_topo_limit > 0 &&
            this_func_meta.get_param_size_and_offsets(fd_param_size,fd_offsets) &&
            cem->m_func_metadata.get_param_size_and_offsets(ce_param_size,ce_offsets)) {
            ++g_tailcalls_topo_known_params;

            // ... and we then know that the caller param space is at least as large as the callee param space ...
            if(fd_param_size >= ce_param_size) {
                ++g_tailcalls_topo_caller_large_enough;
                fd_ce_diff = fd_param_size - ce_param_size;

                // ... then we find out which caller params are used to generate each callee param.
                std::vector<std::vector<std::string> > arg_ids;
                arg_ids = cem->get_arg_identifiers();
                if(g_use_th_param) {
                    arg_ids[0].push_back(std::string("_pillar2c_task_handle"));
                    arg_ids[1].push_back(std::string("_pillar2c_prev_pseudo_stack"));
                } else {
                    arg_ids[0].push_back(std::string("_pillar2c_prev_pseudo_stack"));
                }

                // Create a map of the offset from the end of the caller's param space to the index of the
                // corresponding param.
                std::vector<unsigned> fd_rev_map;
                unsigned fd_offset_index;
                for(fd_offset_index = fd_offsets.size();
                    fd_offset_index > 0;
                    --fd_offset_index) {
                    unsigned size_index;
                    // Some params are larger than the size of a register so multiple entries in the reverse map
                    // will point to the same param index.
                    for(size_index = 0; size_index < (fd_offsets[fd_offset_index-1].size / REGISTER_PARAM_SIZE); ++size_index) {
                        fd_rev_map.push_back(fd_offset_index-1);
                    }
                }

                std::vector<unsigned> ce_rev_map;
                unsigned ce_offset_index;
                for(ce_offset_index = ce_offsets.size();
                    ce_offset_index > 0;
                    --ce_offset_index) {
                    unsigned size_index;
                    // Some params are larger than the size of a register so multiple entries in the reverse map
                    // will point to the same param index.
                    for(size_index = 0; size_index < (ce_offsets[ce_offset_index-1].size / REGISTER_PARAM_SIZE); ++size_index) {
                        ce_rev_map.push_back(ce_offset_index-1);
                    }
                }

                // Create the edges in the param interference DAG.
                unsigned arg_id_index;
                // For each callee param...
                for(arg_id_index = 0; arg_id_index < arg_ids.size(); ++arg_id_index) {
                    unsigned target_size, target_offset;
                    // Save the size of the callee param and the offset from the start of the args.
                    target_size   = ce_offsets[arg_id_index].size;
                    target_offset = ce_offsets[arg_id_index].offset;

                    // For each caller param used in the expression for this callee param.
                    unsigned uses_index;
                    for(uses_index = 0; uses_index < arg_ids[arg_id_index].size(); ++uses_index) {
                        // Get the name of the param used.
                        std::string param_used = arg_ids[arg_id_index][uses_index];
                        // Find the index of caller param used.
                        unsigned fd_param_index = get_name_index(fd_offsets,param_used);

                        // For each register-sized quantity of the callee param...
                        unsigned tsize;
                        for(tsize = 0; tsize < target_size; tsize+=REGISTER_PARAM_SIZE) {
                            //... compute how far it is from the end of the callee params.
                            unsigned target_rev_offset = ce_param_size - (target_offset + tsize);
                            // the same rev offset but measured in register-sized chunks
                            unsigned target_rev_slot = (target_rev_offset / REGISTER_PARAM_SIZE) - 1;
                            // see which caller param index occupies this callee param slot
                            unsigned target_as_caller_index = fd_rev_map[target_rev_slot];
                            // add an interference edge to the DAG
                            if(fd_param_index != target_as_caller_index) {
                                fd_offsets[fd_param_index].interference_edges.insert(target_as_caller_index);
                            }
                        }

                        unsigned this_fd_param_size   = fd_offsets[fd_param_index].size;
                        unsigned this_fd_param_offset = fd_offsets[fd_param_index].offset;
                        for(tsize = 0; tsize < this_fd_param_size; tsize+=REGISTER_PARAM_SIZE) {
                            //... compute how far it is from the end of the callee params.
                            unsigned target_rev_offset = fd_param_size - (this_fd_param_offset + tsize);
                            if(target_rev_offset > ce_param_size) {
                                continue;
                            }
                            // the same rev offset but measured in register-sized chunks
                            unsigned target_rev_slot = (target_rev_offset / REGISTER_PARAM_SIZE) - 1;
                            // see which caller param index occupies this callee param slot
                            unsigned target_as_callee_index = ce_rev_map[target_rev_slot];
                            // add an interference edge to the DAG
                            if(arg_id_index != target_as_callee_index) {
                                ce_offsets[target_as_callee_index].interference_edges.insert(arg_id_index);
                            }
                        }
                    }
                }

                while(1) {
                    try {
                        topo_success = name_offset_topological_sort(ce_offsets,topo_order);
                        break;
                    }
                    catch (topo_cycle &tc) {
                        unsigned i;
                        for(i=0; i < ce_offsets.size(); ++i) {
                            ce_offsets[i].interference_edges.erase(tc.index_to_save);
                        }

                        std::stringstream temp_tailcall_str;
                        temp_tailcall_str << "PrtTailcall_" << te_ce->get_unique() << "_temp_" << tc.index_to_save;

                        args_to_presave.insert(std::pair<unsigned,std::string>(tc.index_to_save,temp_tailcall_str.str()));
                        topo_order.clear();
                        ++g_tailcalls_topo_cycles_broken;
                    }
                }
            }
        }

        if(topo_success) {
            ++g_tailcalls_topo;
            --g_topo_limit;
        } else {
            ++g_tailcalls_non_topo;
        }

        std::stringstream unique_ss;
        unique_ss << te_ce->get_unique();

        std::stringstream callsite_tailcall_str;
        callsite_tailcall_str << "PrtTailcall_" << unique_ss.str();

        std::stringstream callsite_tailcall_ptr_str;
        callsite_tailcall_ptr_str << "tailcall_" << unique_ss.str();

        std::stringstream callsite_tailcall_label_str;
        callsite_tailcall_label_str << "do_tailcall_" << unique_ss.str();

        std::stringstream callsite_arg_copy_loop;
        callsite_arg_copy_loop << "arg_copy_loop_" << unique_ss.str();

        std::stringstream fake_ret;
        fake_ret << "fake_ret_" << unique_ss.str();

        auto_ptr<expression_type> this_func_ret_type(fd->get_return_type());

        std::list<external_declaration *> spec_struct;
        if(topo_success) {
            spec_struct = gen_specific_callsite_prt_args(2,fd->get_symbol()->get_string(),callsite_tailcall_str.str(),*cem,true /* gen for tailcall */, true /* don't include arguments */);
        } else {
            spec_struct = gen_specific_callsite_prt_args(2,fd->get_symbol()->get_string(),callsite_tailcall_str.str(),*cem,true /* gen for tailcall */);
        }
        fd->insert_before_top_level(spec_struct);

        block_item_list *tailcall_translation = NULL;

        // ****************************************************************
        // *             _X86_64__ TAILCALL TRANSLATION                   *
        // ****************************************************************
#ifdef __x86_64__
        std::stringstream tc_trans;

#if 0
        tc_trans << callsite_tailcall_str.str() << " * " << callsite_tailcall_ptr_str.str() << ";\n";
        tc_trans << "__asm__ (\n";
        tc_trans << "\"mov %%%%rsp, %%0\\n\\t\"\n";
        tc_trans << "\"sub %%1, %%0\\n\\t\"\n";
        tc_trans << ": \"=r\" (" << callsite_tailcall_ptr_str.str() << ")\n";
        tc_trans << ": \"r\" (sizeof(" << callsite_tailcall_str.str() << "))\n";
        tc_trans << ");\n";                // end of __asm__
#else
        tc_trans << callsite_tailcall_str.str() << " * " << callsite_tailcall_ptr_str.str() << ";\n";
        tc_trans << "__asm__ (\n";
        tc_trans << "\"mov %%%%rsp, %%0\\n\\t\"\n";
        tc_trans << "\"sub $128, %%0\\n\\t\"\n";
        tc_trans << "\"sub %%1, %%0\\n\\t\"\n";
        tc_trans << ": \"=r\" (" << callsite_tailcall_ptr_str.str() << ")\n";
        tc_trans << ": \"g\" (sizeof(" << callsite_tailcall_str.str() << "))\n";
        tc_trans << ");\n";                // end of __asm__
#endif

        tailcall_translation = new block_item_list_block_item(new block_item_text(tc_trans.str()));

        unsigned ret_size=0;
        type_specifier *ret_ts = this_func_ret_type->m_sql->get_type_specifier()->get_base_type();
        if(!ret_ts)  {
            aeprintf("Should not fail to get return type base type in tailcall translation.\n");
        }
        bool ret_void = this_func_ret_type->is_void();
        bool float_ret = false;
        if(!ret_void) {
            if(this_func_ret_type->is_pointer() || ret_ts->is_ultimate_prt_ref()) {
                ret_size = 8;
            } else {
                if(ret_ts->is_float_type() || ret_ts->is_int_type()) {
                    if(ret_ts->is_float_type()) {
                        float_ret = true;
                    }
                    ret_size = ret_ts->get_minimum_size();
                } else {
                    aeprintf("Pillar2c does not currently support tailcall return types that are not float or integer.\n");
                }
            }

            if(ret_size == 8) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_declaration(
                                     new declaration_declaration_specifiers_init_declarator_list(
                                      new declaration_specifiers_type_specifier(
                                       this_func_ret_type->m_sql->get_type_specifier()->clone()),
                                      new init_declarator_list_init_declarator(
                                       new init_declarator_declarator(
                                        this_func_ret_type->m_ad ?
                                            this_func_ret_type->m_ad->gen_declarator(fake_ret.str()) :
                                            new declarator_direct_declarator(
                                             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(fake_ret.str())))))),0));
            } else if (ret_size < 8) {
                std::stringstream fake_ret_type_name;
                fake_ret_type_name << "fake_ret_type_" << unique_ss.str();
                std::stringstream fake_ret_type;
                fake_ret_type << "typedef struct {\nunion " <<
                                 " {\n" << *(this_func_ret_type->m_sql->get_type_specifier()) <<
                                 " real_ret; \nvoid *tailcall_ret;\n} both" << unique_ss.str() <<
                                 ";\n} " << fake_ret_type_name.str() << ";\n";
                fd->insert_before_top_level(new external_declaration_emit_text(fake_ret_type.str()));
                std::stringstream fake_ret_decl;
                fake_ret_decl << fake_ret_type_name.str() << " " << fake_ret.str() << ";\n";
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                         new block_item_text(fake_ret_decl.str()));
            } else {
                aeprintf("Pillar2c does not currently implement tailcall return types of length %d\n",ret_size);
            }
        }

        tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                new block_item_statement(
                                 new statement_expression_statement(
                                  new expression_statement_expression(
                                   new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                     expr_gen(unary_expression,postfix_expression,
                                      new postfix_expression_postfix_expression_ptr_op_identifier(
                                       new postfix_expression_primary_expression(
                                        new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                       "func")),
                                     new assignment_operator_equal(),
                                     expr_gen(assignment_expression,postfix_expression,cem->claim_function()))))),0));

        tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                new block_item_statement(
                                 new statement_expression_statement(
                                  new expression_statement_expression(
                                   new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                     expr_gen(unary_expression,postfix_expression,
                                      new postfix_expression_postfix_expression_ptr_op_identifier(
                                       new postfix_expression_primary_expression(
                                        new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                       "real_return")),
                                     new assignment_operator_equal(),
                                     expr_gen(assignment_expression,unary_expression,
                                      new unary_expression_unary_operator_cast_expression(
                                       new unary_operator_star(),
                                       expr_gen(cast_expression,postfix_expression,
                                        gen_pseudo_pe("fake_eip_target",fd)))))))),0));

#if 0
        tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                new block_item_statement(
                                 new statement_expression_statement(
                                  new expression_statement_expression(
                                   new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                     expr_gen(unary_expression,postfix_expression,
                                      new postfix_expression_postfix_expression_ptr_op_identifier(
                                       new postfix_expression_primary_expression(
                                        new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                       "argQwords")),
                                     new assignment_operator_equal(),
                                     expr_gen(assignment_expression,multiplicative_expression,
                                      new multiplicative_expression_multiplicative_expression_div_cast_expression(
                                       expr_gen(multiplicative_expression,primary_expression,
                                        new primary_expression_expression(
                                         new expression_assignment_expression(
                                          expr_gen(assignment_expression,additive_expression,
                                           new additive_expression_additive_expression_minus_multiplicative_expression(
                                            expr_gen(additive_expression,unary_expression,
                                             new unary_expression_sizeof_type_name(
                                              new type_name_specifier_qualifier_list(
                                               new specifier_qualifier_list_type_specifier(
                                                new type_specifier_TYPE_NAME(
                                                 g_scope_stack.find_or_add(callsite_tailcall_str.str())))))),
                                            expr_gen(multiplicative_expression,primary_expression,
                                             new primary_expression_constant("24"))))))),
                                       expr_gen(cast_expression,primary_expression,
                                        new primary_expression_constant("8"))))))))));
#endif

        unsigned total_param_size = 0;
        for(arg_index = 0; arg_index < cem->m_args.size(); ++arg_index) {
            if(arg_index < cem->m_func_metadata.m_params.size()) {
                auto_ptr<expression_type> apet(cem->m_func_metadata.m_params[arg_index]->get_type());
                total_param_size += apet->get_param_size();
                tailcall_translation =
                   new block_item_list_block_item_list_block_item(tailcall_translation,
                    new block_item_statement(
                     new statement_expression_statement(
                      new expression_statement_expression(
                       new expression_assignment_expression(
                        create_expression_for_arg(apet.get(),cem->m_args[arg_index],arg_index,te_ce,"arg","tailcall_",false,true /* use "->" rather than "." */)))),0));
            } else {
                auto_ptr<expression_type> apet(cem->m_args[arg_index]->get_type());
                total_param_size += apet->get_param_size();
                tailcall_translation =
                   new block_item_list_block_item_list_block_item(tailcall_translation,
                    new block_item_statement(
                     new statement_expression_statement(
                      new expression_statement_expression(
                       new expression_assignment_expression(
                        create_expression_for_arg(apet.get(),cem->m_args[arg_index],arg_index,te_ce,"arg","tailcall_",false,true /* use "->" rather than "." */)))),0));
            }
        }

        std::stringstream the_asm;

        if(g_gcc_compatible) {
            const char *reg_unmodified_across_return = "r11";

#ifdef UNIQUE_TAILCALL_ASM_LABELS
            std::stringstream real_label_str;
            real_label_str << "real_label_" << unique_ss.str();
#endif

            // Add start of inline assembly.
            the_asm << "__asm__ (\n";
            the_asm << "\"jmp ";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            the_asm << real_label_str.str();
#else
            the_asm << "1f";
#endif
            the_asm << "\\n\\t\"\n";

            the_asm << "\"";
            // Add tailcall site label.
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            the_asm << callsite_tailcall_label_str.str();
#else
            the_asm << "0";
#endif
            the_asm << ":\\n\\t\"\n";

            if(destination_args.size() != cem->m_args.size()) {
                aeprintf("Internal tailcall translation error.  Destination args do not match function args.\n");
            }
            for(arg_index = 0; arg_index < cem->m_args.size(); ++arg_index) {
                if(destination_args[arg_index].substr(0,3) == "zmm") {
                    the_asm << "\"vbroadcastss " << (arg_index * 8) << "(%%%%" << reg_unmodified_across_return <<
                               "),%%%%" << destination_args[arg_index] << "\\n\\t\"\n";
                } else if(destination_args[arg_index].substr(0,10) == "double zmm") {
                    the_asm << "\"vbroadcastsd " << (arg_index * 8) << "(%%%%" << reg_unmodified_across_return <<
                               "),%%%%" << destination_args[arg_index].substr(10) << "\\n\\t\"\n";
                } else {
                    the_asm << "\"movq " << (arg_index * 8) << "(%%%%" << reg_unmodified_across_return <<
                               "),%%%%" << destination_args[arg_index] << "\\n\\t\"\n";
                }
            }

            the_asm << "\"movq " << ((arg_index+0) * 8) << "(%%%%" << reg_unmodified_across_return << "),%%%%r10\\n\\t\"\n";
            the_asm << "\"push %%%%r10\\n\\t\"\n";
            the_asm << "\"movq " << ((arg_index+1) * 8) << "(%%%%" << reg_unmodified_across_return << "),%%%%r10\\n\\t\"\n";
            the_asm << "\"jmp *%%%%r10\\n\\t\"\n";

            the_asm << "\"";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            the_asm << real_label_str.str();
#else
            the_asm << "1";
#endif
            the_asm << ":\\n\\t\"\n";

#if 1
            the_asm << "\"mov %%1,%%%%r10\\n\\t\"\n";
#else
            the_asm << "\"mov %%0,%%%%r10\\n\\t\"\n";
            the_asm << "\"add $" << total_param_size << ",%%%%r10\\n\\t\"\n";
#endif

            the_asm << "\"leaq ";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            the_asm << callsite_tailcall_label_str.str().c_str();
#else
            the_asm << "0b";
#endif
            the_asm << ",%%%%r11\\n\\t\"\n";

//            the_asm << "\"lea " << callsite_tailcall_label_str.str() << ",%%%%r11\\n\\t\"\n";

            the_asm << "\"movq %%%%r11,(%%%%r10)\\n\\t\"\n";

            the_asm << "\"movq %%%%rax, %%%%" << reg_unmodified_across_return << "\\n\\t\"\n";
            the_asm << ":\n";
#if 0
            // Final }
            if(ret_void) {
                the_asm << ":\n";
            } else {
#if 1
                the_asm << "\"movq %%%%rax, %%%%" << reg_unmodified_across_return << "\\n\\t\"\n";
                the_asm << ":\n";
#else
                the_asm << "\"movq %%%%rax, %%0\\n\\t\"\n";
                if(ret_size == 8) {
                    the_asm << ": \"=g\" (" << fake_ret.str() << ")\n";
                } else if (ret_size < 8) {
                    the_asm << ": \"=g\" (" << fake_ret.str() << ".both" << unique_ss.str() << ".tailcall_ret)\n";
                } else {
                    aeprintf("Pillar2c does not currently implement tailcall return types of length %d\n",ret_size);
                }
#endif
            }
#endif
//            the_asm << ": \"a\" (" << callsite_tailcall_ptr_str.str() << ")\n";
            the_asm << ": \"a\" (" << callsite_tailcall_ptr_str.str() << "), \"r\" ( " PSEUDO_NAME ".fake_eip_target)\n";
            the_asm << "\n);\n";
//            the_asm << ":\n);\n";

//            the_asm << ":\n:\n:\n);\n";

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(the_asm.str().c_str()),0));

            if(ret_void) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                        new block_item_statement(
                                         new statement_jump_statement(
                                          new jump_statement_return()),0));
            } else {
                std::stringstream ret_stmt;
                if(ret_size == 8) {
                    ret_stmt << "return " << fake_ret.str() << ";\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else if(ret_size < 8) {
                    ret_stmt << "return " << fake_ret.str() << ".both" << unique_ss.str() << ".real_ret;\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }
        } else {
            aeprintf("Tailcalls not supported in __x86_64__ outside of gcc.\n");
#if 0
            // Add start of inline assembly.
            strcpy(asm_buf,"__asm {\n");
            // Move the tailcall structure pointer into eax
            strcat(asm_buf,"mov eax, ");
            strcat(asm_buf,callsite_tailcall_ptr_str.str().c_str());
            strcat(asm_buf,"\n");
            if(!ret_void) {
                if(ret_size == 8) {
                    strcat(asm_buf,"mov ");
                    strcat(asm_buf,fake_ret.str().c_str());
                    strcat(asm_buf,", rax\n");
                } else if(ret_size < 8) {
                    strcat(asm_buf,"mov ");
                    strcat(asm_buf,fake_ret.str().c_str());
                    strcat(asm_buf,".tailcall_ret, rax\n");
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }
            // Move the tailcall stub into ecx
            strcat(asm_buf,"lea ecx, ");
            strcat(asm_buf,callsite_tailcall_label_str.str().c_str());
            strcat(asm_buf,"\n");
            // Move the address of the first param into edx
            strcat(asm_buf,"lea edx, _pillar2c_task_handle \n");
            // Compute address of the return eip by subtract 4 from the address of the first added parameter.
            strcat(asm_buf,"sub edx, 4 \n");
            // Overwrite real return eip with tailcall stub.
            strcat(asm_buf,"mov dword ptr [edx], ecx \n");
            // Final }
            strcat(asm_buf,"}\n");

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(asm_buf)));

            if(ret_void) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                        new block_item_statement(
                                         new statement_jump_statement(
                                          new jump_statement_return())));
            } else {
                std::stringstream ret_stmt;
                if(ret_size == 8) {
                    ret_stmt << "return " << fake_ret.str() << ";\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else if(ret_size < 8) {
                    ret_stmt << "return " << fake_ret.str() << ".both" << unique_ss.str() << ".real_ret;\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }

            // Add start of inline assembly.
            strcpy(asm_buf,"__asm {\n");
            // Add tailcall site label.
            strcat(asm_buf,callsite_tailcall_label_str.str().c_str());
            strcat(asm_buf,":\n");
            // Num arg dwords into ecx;
            strcat(asm_buf,"mov ecx, [eax] \n");
            // Loop label.
            strcat(asm_buf,callsite_arg_copy_loop.str().c_str());
            strcat(asm_buf,":\n");
            // Push args.
            strcat(asm_buf,"push dword ptr [eax+ecx*4]\n");
            strcat(asm_buf,"loop ");
            strcat(asm_buf,callsite_arg_copy_loop.str().c_str());
            strcat(asm_buf,"\n");
            // Get address of real return eip
            strcat(asm_buf,"mov ecx, [eax] \n");
            strcat(asm_buf,"lea eax, [eax+ecx*4+4] \n");
            // Simulated call = push real eip + jmp
            strcat(asm_buf,"push dword ptr [eax]\n");
            strcat(asm_buf,"jmp  dword ptr [eax+4]\n");
            // Final }
            strcat(asm_buf,"}\n");

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(asm_buf)));
#endif
        }

#else  // __x86_64__

        assignment_expression *tc_task_handle_expr = NULL;
        if(g_use_th_param) {
            tc_task_handle_expr = expr_gen(assignment_expression,primary_expression,
                                    new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle")));
        } else {
            tc_task_handle_expr = expr_gen(assignment_expression,postfix_expression,
                                    new postfix_expression_call_expression(
                                      new call_expression_postfix_expression_empty_paren(
                                        new postfix_expression_primary_expression(
                                          new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle"))))));
        }

        // ****************************************************************
        // *                  IA32 TAILCALL TRANSLATION                   *
        // ****************************************************************
        // Create the statement to declare a tailcall struct of the right type and make it point to the pillar2c tls area
        tailcall_translation = new block_item_list_block_item(
                                new block_item_declaration(
                                 new declaration_declaration_specifiers_init_declarator_list(
                                  new declaration_specifiers_type_specifier(
                                   new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(callsite_tailcall_str.str()))),
                                  new init_declarator_list_init_declarator(
                                   new init_declarator_declarator_initializer(
                                    new declarator_pointer_direct_declarator(
                                     new pointer_star(),
                                     new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                    new initializer_assignment_expression(
                                     expr_gen(assignment_expression,cast_expression,
                                      new cast_expression_type_name_cast_expression(
                                       new type_name_specifier_qualifier_list_abstract_declarator(
                                        new specifier_qualifier_list_type_specifier(
                                         new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(callsite_tailcall_str.str()))),
                                        new abstract_declarator_pointer(
                                         new pointer_star())),
                                       expr_gen(cast_expression,primary_expression,
                                        new primary_expression_expression(
                                         new expression_assignment_expression(
                                          expr_gen(assignment_expression,postfix_expression,
                                           new call_expression_postfix_expression_paren_argument_expression_list(
                                            new postfix_expression_primary_expression(
                                             new primary_expression_identifier(g_scope_stack.find_or_add("__pillar2c_get_tailcall"))),
                                            new argument_expression_list_argument_expression_list_assignment_expression(
                                             new argument_expression_list_assignment_expression(tc_task_handle_expr),
                                             expr_gen(assignment_expression,multiplicative_expression,
                                               new multiplicative_expression_multiplicative_expression_div_cast_expression(
                                                expr_gen(multiplicative_expression,primary_expression,
                                                 new primary_expression_expression(
                                                  new expression_assignment_expression(
                                                   expr_gen(assignment_expression,unary_expression,
                                                    new unary_expression_sizeof_type_name(
                                                     new type_name_specifier_qualifier_list(
                                                      new specifier_qualifier_list_type_specifier(
                                                       new type_specifier_TYPE_NAME(
                                                        g_scope_stack.find_or_add(callsite_tailcall_str.str()))))))))),
                                                expr_gen(cast_expression,primary_expression,
                                                 new primary_expression_constant("4")))))))))))))))),0));

        unsigned ret_size=0;
#ifdef USE_ET_BASE
        auto_ptr<expression_type> base_apet(this_func_ret_type->get_base_type());

        if(!base_apet.get())  {
            aeprintf("Should not fail to get return type base type in tailcall translation.\n");
        }
        bool ret_void = base_apet->is_void();
        bool float_ret = false;
        if(!ret_void) {
            if(base_apet->is_pointer() || base_apet->m_sql->get_type_specifier()->is_ultimate_prt_ref()) {
                ret_size = 4;
            } else {
                if(base_apet->is_float_type() || base_apet->is_int_type()) {
                    if(base_apet->is_float_type()) {
                        float_ret = true;
                    }
                    ret_size = base_apet->get_minimum_size();
                } else {
                    aeprintf("Pillar2c does not currently support tailcall return types that are not float or integer.\n");
                }
            }
#else
        type_specifier *ret_ts = this_func_ret_type->m_sql->get_type_specifier()->get_base_type();
        if(!ret_ts)  {
            aeprintf("Should not fail to get return type base type in tailcall translation.\n");
        }
        bool ret_void = this_func_ret_type->is_void();
        bool float_ret = false;
        if(!ret_void) {
            if(this_func_ret_type->is_pointer() || ret_ts->is_ultimate_prt_ref()) {
                ret_size = 4;
            } else {
                if(ret_ts->is_float_type() || ret_ts->is_int_type()) {
                    if(ret_ts->is_float_type()) {
                        float_ret = true;
                    }
                    ret_size = ret_ts->get_minimum_size();
                } else {
                    aeprintf("Pillar2c does not currently support tailcall return types that are not float or integer.\n");
                }
            }
#endif

            if(ret_size == 4) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_declaration(
                                     new declaration_declaration_specifiers_init_declarator_list(
                                      new declaration_specifiers_type_specifier(
                                       this_func_ret_type->m_sql->get_type_specifier()->clone()),
                                      new init_declarator_list_init_declarator(
                                       new init_declarator_declarator(
                                        this_func_ret_type->m_ad ?
                                            this_func_ret_type->m_ad->gen_declarator(fake_ret.str()) :
                                            new declarator_direct_declarator(
                                             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(fake_ret.str())))))),0));
            } else if(ret_size == 8) {
                std::stringstream fake_ret_type_name;
                fake_ret_type_name << "fake_ret_type_" << unique_ss.str();
                std::stringstream fake_ret_type;
                fake_ret_type << "typedef struct {\nunion " <<
                                 " {\n" << *(this_func_ret_type->m_sql->get_type_specifier()) <<
                                 " full; \nstruct " <<
                                 " {\nuint32_t eax_part;\nuint32_t edx_part;\n} parts" << unique_ss.str() <<
                                 ";\n} both" << unique_ss.str() <<
                                 ";\n} " << fake_ret_type_name.str() << ";\n";
                fd->insert_before_top_level(new external_declaration_emit_text(fake_ret_type.str()));
                std::stringstream fake_ret_decl;
                fake_ret_decl << fake_ret_type_name.str() << " " << fake_ret.str() << ";\n";
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                         new block_item_text(fake_ret_decl.str()));
            } else {
                aeprintf("Pillar2c does not currently implement tailcall return types of length %d\n",ret_size);
            }
        }

        tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                new block_item_statement(
                                 new statement_expression_statement(
                                  new expression_statement_expression(
                                   new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                     expr_gen(unary_expression,postfix_expression,
                                      new postfix_expression_postfix_expression_ptr_op_identifier(
                                       new postfix_expression_primary_expression(
                                        new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                       "func")),
                                     new assignment_operator_equal(),
                                     expr_gen(assignment_expression,postfix_expression,cem->claim_function()))))),0));

        tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                new block_item_statement(
                                 new statement_expression_statement(
                                  new expression_statement_expression(
                                   new expression_assignment_expression(
                                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                     expr_gen(unary_expression,postfix_expression,
                                      new postfix_expression_postfix_expression_ptr_op_identifier(
                                       new postfix_expression_primary_expression(
                                        new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                       "real_return")),
                                     new assignment_operator_equal(),
                                     expr_gen(assignment_expression,unary_expression,
                                      new unary_expression_unary_operator_cast_expression(
                                       new unary_operator_star(),
                                       expr_gen(cast_expression,postfix_expression,
                                        gen_pseudo_pe("fake_eip_target",fd)))))))),0));

        if(!topo_success) {
            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_expression_statement(
                                      new expression_statement_expression(
                                       new expression_assignment_expression(
                                        new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                         expr_gen(unary_expression,postfix_expression,
                                          new postfix_expression_postfix_expression_ptr_op_identifier(
                                           new postfix_expression_primary_expression(
                                            new primary_expression_identifier(g_scope_stack.find_or_add(callsite_tailcall_ptr_str.str()))),
                                           "argDwords")),
                                         new assignment_operator_equal(),
                                         expr_gen(assignment_expression,multiplicative_expression,
                                          new multiplicative_expression_multiplicative_expression_div_cast_expression(
                                           expr_gen(multiplicative_expression,primary_expression,
                                            new primary_expression_expression(
                                             new expression_assignment_expression(
                                              expr_gen(assignment_expression,additive_expression,
                                               new additive_expression_additive_expression_minus_multiplicative_expression(
                                                expr_gen(additive_expression,unary_expression,
                                                 new unary_expression_sizeof_type_name(
                                                  new type_name_specifier_qualifier_list(
                                                   new specifier_qualifier_list_type_specifier(
                                                    new type_specifier_TYPE_NAME(
                                                     g_scope_stack.find_or_add(callsite_tailcall_str.str())))))),
                                                expr_gen(multiplicative_expression,primary_expression,
                                                 new primary_expression_constant("12"))))))),
                                           expr_gen(cast_expression,primary_expression,
                                            new primary_expression_constant("4")))))))),0));
        }

        // if we are using copy-once topographical tailcalls
        if(topo_success) {
            std::map<unsigned,std::string>::iterator pre_iter;
            // For every argument we have to save to a temporary to break a cycle.
            for(pre_iter  = args_to_presave.begin();
                pre_iter != args_to_presave.end();
                ++pre_iter) {
                expression_type *arg_type;
                // get the type of that argument
                if(pre_iter->first < cem->m_func_metadata.m_params.size()) {
                    arg_type = cem->m_func_metadata.m_params[pre_iter->first]->get_type();
                } else {
                    arg_type = cem->m_args[pre_iter->first]->get_type();
                }
                auto_ptr<expression_type> apet(arg_type);

                // create a declaration of a temporary variable of that type
                declaration *gen_decl = apet->gen_declaration_init(pre_iter->second,cem->m_args[pre_iter->first]->clone());
                // add it to the translation sequence
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                         new block_item_declaration(
                                           gen_decl,0
                                         )
                                       );
            }

            unsigned topo_index;
            // iterate over the argument copying order in topo_order
            for(topo_index = 0; topo_index < topo_order.size(); ++topo_index) {
                // get the callee argument index
                unsigned arg_index = topo_order[topo_index];
                // No need to copy the task handle and previous pseudo frame since they aren't modified
                // if the destination location is the same as the current one which is true only when the size of the
                // parameters is the same.
                if(arg_index < get_num_p2c_added_params() && fd_param_size == ce_param_size) {
                    continue;
                }

                if(g_gcc_compatible && topo_index != 0) {
#if 1
                    tailcall_translation =
                        new block_item_list_block_item_list_block_item(tailcall_translation,
                          new block_item_text("MEMORY_BARRIER\n"));
#else
                    tailcall_translation =
                        new block_item_list_block_item_list_block_item(tailcall_translation,
                          new block_item_text("__asm__ __volatile__ (\"\" : : : \"memory\");\n"));
#endif
                }

                unsigned this_offset = ce_offsets[arg_index].offset + fd_ce_diff + REGISTER_PARAM_SIZE;
                std::stringstream offset_text;
                offset_text << this_offset;

                expression_type *arg_type;
                if(topo_index < cem->m_func_metadata.m_params.size()) {
                    arg_type = cem->m_func_metadata.m_params[arg_index]->get_type();
                } else {
                    arg_type = cem->m_args[arg_index]->get_type();
                }
                auto_ptr<expression_type> apet(arg_type);
                if(apet->m_ad) {
                    abstract_declarator *ad_to_delete = apet->m_ad;
                    apet->m_ad = apet->m_ad->add_pointer_star();
                    delete ad_to_delete;
                } else {
                    apet->m_ad = new abstract_declarator_pointer(new pointer_star());
                }

                assignment_expression * ae_to_use;
                pre_iter = args_to_presave.find(arg_index);
                if(pre_iter == args_to_presave.end()) {
                    ae_to_use = cem->m_args[arg_index]->clone();
                } else {
                    ae_to_use = expr_gen(assignment_expression,postfix_expression,
                          new postfix_expression_primary_expression(
                            new primary_expression_identifier(g_scope_stack.find_or_add(pre_iter->second))
                          )
                        );
                }

                tailcall_translation =
                            new block_item_list_block_item_list_block_item(tailcall_translation,
                              new block_item_statement(
                                new statement_expression_statement(
                                  new expression_statement_expression(
                                    new expression_assignment_expression(
                                      new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                        new unary_expression_unary_operator_cast_expression(
                                          new unary_operator_star(),
                                          new cast_expression_unary_expression(
                                            new unary_expression_postfix_expression(
                                              new postfix_expression_primary_expression(
                                                new primary_expression_expression(
                                                  new expression_assignment_expression(
                                                    expr_gen(assignment_expression,cast_expression,
                                                      new cast_expression_type_name_cast_expression(
                                                        apet->gen_type_name(new type_qualifier_volatile()),
                                                        new cast_expression_unary_expression(
                                                          new unary_expression_postfix_expression(
                                                            new postfix_expression_primary_expression(
                                                              new primary_expression_expression(
                                                                new expression_assignment_expression(
                                                                  expr_gen(assignment_expression,additive_expression,
                                                                    new additive_expression_additive_expression_plus_multiplicative_expression(
                                                                      expr_gen(additive_expression,cast_expression,
                                                                        new cast_expression_type_name_cast_expression(
                                                                          new type_name_specifier_qualifier_list_abstract_declarator(
                                                                            new specifier_qualifier_list_type_specifier(
                                                                              new type_specifier_CHAR()),
                                                                            new abstract_declarator_pointer(
                                                                              new pointer_star())),
                                                                          expr_gen(cast_expression,postfix_expression,
                                                                            gen_pseudo_pe("fake_eip_target",fd)))),
                                                                      expr_gen(multiplicative_expression,postfix_expression,
                                                                        new postfix_expression_primary_expression(
                                                                          new primary_expression_constant(offset_text.str())))))))))))))))))),
                                        new assignment_operator_equal(),
                                        ae_to_use)))),0));
            }
        } else {
            unsigned arg_index;
            for(arg_index = 0; arg_index < cem->m_args.size(); ++arg_index) {
                expression_type *arg_type;
                if(arg_index < cem->m_func_metadata.m_params.size()) {
                    arg_type = cem->m_func_metadata.m_params[arg_index]->get_type();
                } else {
                    arg_type = cem->m_args[arg_index]->get_type();
                }
                auto_ptr<expression_type> apet(arg_type);
                tailcall_translation =
                  new block_item_list_block_item_list_block_item(tailcall_translation,
                    new block_item_statement(
                      new statement_expression_statement(
                        new expression_statement_expression(
                          new expression_assignment_expression(
                            create_expression_for_arg(apet.get(),cem->m_args[arg_index],arg_index,te_ce,"arg","tailcall_",false,true /* use "->" rather than "." */)))),0));
            }
        }

        std::stringstream asm_str;
        if(g_gcc_compatible) {
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            std::stringstream real_label_str;
            real_label_str << "real_label_" << unique_ss.str();
#endif

            // Add start of inline assembly.
            asm_str << "__asm__ (";
            asm_str << "\"jmp ";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            asm_str << real_label_str.str().c_str();
#else
            asm_str << "1f";
#endif
            asm_str << "\\n\\t\"\n";
            asm_str << "\"";
            // Add tailcall site label.
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            asm_str << callsite_tailcall_label_str.str().c_str();
#else
            asm_str << "0";
#endif
            asm_str << ":\\n\\t\"\n";
            if(float_ret) {
                // If the return type is a float type then remove the pushed value on fp stack.
                asm_str << "\"fstp %%%%st(0)\\n\\t\"\n";
            }
            if(topo_success) {
                asm_str << "\"subl $" << ce_param_size << ", %%%%esp\\n\\t\"\n";
            } else {
                // Num arg dwords into ecx;
                asm_str << "\"movl (%%%%eax), %%%%ecx\\n\\t\"\n\"";
                // Loop label.
#ifdef UNIQUE_TAILCALL_ASM_LABELS
                asm_str << callsite_arg_copy_loop.str().c_str();
                asm_str << ":\\n\\t\"\n";
#else
                asm_str << "2:\\n\\t\"\n";
#endif
                // Push args.
                asm_str << "\"push (%%%%eax,%%%%ecx,4)\\n\\t\"\n";
                asm_str << "\"loop ";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
                asm_str << callsite_arg_copy_loop.str().c_str();
#else
                asm_str << "2b";
#endif
                asm_str << "\\n\\t\"\n";
                // Get address of real return eip
                asm_str << "\"movl (%%%%eax), %%%%ecx\\n\\t\"\n";
                asm_str << "\"leal (%%%%eax,%%%%ecx,4), %%%%eax\\n\\t\"\n";
                asm_str << "\"addl $4,%%%%eax\\n\\t\"\n";
            }
            // Simulated call = push real eip + jmp
            asm_str << "\"push (%%%%eax)\\n\\t\"\n";
            asm_str << "\"addl $4,%%%%eax\\n\\t\"\n";
            asm_str << "\"jmp  *(%%%%eax)\\n\\t\"\n";
            asm_str << "\"";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            asm_str << real_label_str.str().c_str();
#else
            asm_str << "1";
#endif
            asm_str << ":\\n\\t\"\n";
            // Move the tailcall structure pointer into eax
            // Move the tailcall stub into ecx
            asm_str << "\"leal ";
#ifdef UNIQUE_TAILCALL_ASM_LABELS
            asm_str << callsite_tailcall_label_str.str().c_str();
#else
            asm_str << "0b";
#endif
            asm_str << ",%%%%ecx\\n\\t\"\n";
            // Compute address of the return eip by subtract 4 from the address of the first added parameter.
            asm_str << "\"subl $4, %%%%edx\\n\\t\"\n";
            // Overwrite real return eip with tailcall stub.
            asm_str << "\"movl %%%%ecx, (%%%%edx)\\n\\t\"\n";
            // Final }
            if(ret_void) {
                asm_str << ":\n";
            } else {
                asm_str << "\"movl %%%%eax, %%0\"\n";
                asm_str << ": \"=g\" (";
                asm_str << fake_ret.str().c_str();
                asm_str << ")\n";
            }
            asm_str << ": \"a\" (";
            asm_str << callsite_tailcall_ptr_str.str().c_str();
            asm_str << "), \"d\" (&" << g_first_added_param_name << ")\n";
            // Final }
            asm_str << ");\n";

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(asm_str.str()),0));

            if(ret_void) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                        new block_item_statement(
                                         new statement_jump_statement(
                                          new jump_statement_return()),0));
            } else {
                std::stringstream ret_stmt;
                if(ret_size == 4) {
                    ret_stmt << "return " << fake_ret.str() << ";\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else if(ret_size == 8) {
                    ret_stmt << "return " << fake_ret.str() << ".both" << unique_ss.str() << ".full;\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }
        } else {
            asm_str.str("");
            asm_str.clear();
            // Add start of inline assembly.
            asm_str << "__asm {\n";
            // Move the tailcall structure pointer into eax
            asm_str << "mov eax, ";
            asm_str << callsite_tailcall_ptr_str.str().c_str();
            asm_str << "\n";
            if(!ret_void) {
                if(ret_size == 4) {
                    asm_str << "mov ";
                    asm_str << fake_ret.str().c_str();
                    asm_str << ", eax\n";
                } else if(ret_size == 8) {
                    asm_str << "mov ";
                    asm_str << fake_ret.str().c_str();
                    asm_str << ".eax_part, eax\n";
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }
            // Move the tailcall stub into ecx
            asm_str << "lea ecx, ";
            asm_str << callsite_tailcall_label_str.str().c_str();
            asm_str << "\n";
            // Move the address of the first param into edx
            asm_str << "lea edx, " << g_first_added_param_name << "\n";
            // Compute address of the return eip by subtract 4 from the address of the first added parameter.
            asm_str << "sub edx, 4 \n";
            // Overwrite real return eip with tailcall stub.
            asm_str << "mov dword ptr [edx], ecx \n";
            // Final }
            asm_str << "}\n";

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(asm_str.str()),0));

            if(ret_void) {
                tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                        new block_item_statement(
                                         new statement_jump_statement(
                                          new jump_statement_return()),0));
            } else {
                std::stringstream ret_stmt;
                if(ret_size == 4) {
                    ret_stmt << "return " << fake_ret.str() << ";\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else if(ret_size == 8) {
                    ret_stmt << "return " << fake_ret.str() << ".both" << unique_ss.str() << ".full;\n";
                    tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                             new block_item_text(ret_stmt.str()));
                } else {
                    aeprintf("Tailcall translation failed for ret_size = %d\n",ret_size);
                }
            }

            asm_str.str("");
            asm_str.clear();
            // Add start of inline assembly.
            asm_str << "__asm {\n";
            // Add tailcall site label.
            asm_str << callsite_tailcall_label_str.str().c_str();
            asm_str << ":\n";
            if(float_ret) {
                // If the return type is a float type then remove the pushed value on fp stack.
                asm_str << "fstp st(0)\n";
            }
            if(topo_success) {
                asm_str << "sub  esp, " << ce_param_size << "\n";
            } else {
                // Num arg dwords into ecx;
                asm_str << "mov ecx, [eax] \n";
                // Loop label.
                asm_str << callsite_arg_copy_loop.str().c_str();
                asm_str << ":\n";
                // Push args.
                asm_str << "push dword ptr [eax+ecx*4]\n";
                asm_str << "loop ";
                asm_str << callsite_arg_copy_loop.str().c_str();
                asm_str << "\n";
                // Get address of real return eip
                asm_str << "mov ecx, [eax] \n";
                asm_str << "lea eax, [eax+ecx*4+4] \n";
            }
            // Simulated call = push real eip + jmp
            asm_str << "push dword ptr [eax]\n";
            asm_str << "jmp  dword ptr [eax+4]\n";
            // Final }
            asm_str << "}\n";

            tailcall_translation = new block_item_list_block_item_list_block_item(tailcall_translation,
                                    new block_item_statement(
                                     new statement_UUASM(asm_str.str()),0));
        }
#endif // __x86_64__

    //    tailcall_translation->print();

        assert(stmt_parent);

        statement_compound_statement *new_node =
            new statement_compound_statement(
             new compound_statement_block_item_list(
              tailcall_translation));

        AST_node *stmt_gp = stmt_parent->get_parent();
        stmt_gp->replace(stmt_parent,new_node);

        basic_block *cur_bb = fd->get_cur_basic_block();
        if(cur_bb) {
            cur_bb->add_item(new_node);

            basic_block *ret_bb = stmt_parent->get_return_target();
            assert(ret_bb);

            add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

            fd->set_cur_basic_block(NULL);
        }

        delete stmt_parent;
        throw done(stmt_gp);
    }
    assert(0);
} // translate_tailcall

statement * gen_yield_check_statement(void) {
    additive_expression *task_handle_as_unsigned_pointer = NULL;

    if(g_use_th_param) {
        ii_ptr _pillar2c_task_handle = g_scope_stack.find_symbol(std::string("_pillar2c_task_handle"));
        if(!_pillar2c_task_handle) {
            aeprintf("Couldn't find symbol _pillar2c_task_handle.\n");
        }

        task_handle_as_unsigned_pointer =
          expr_gen(additive_expression,primary_expression,
               new primary_expression_expression(
                new expression_assignment_expression(
                 expr_gen(assignment_expression,cast_expression,
                             new cast_expression_type_name_cast_expression(
                              new type_name_specifier_qualifier_list_abstract_declarator(
                               new specifier_qualifier_list_type_specifier(
                                new type_specifier_UNSIGNED()),
                               new abstract_declarator_pointer(
                                new pointer_star())),
                              expr_gen(cast_expression,primary_expression,
                                 new primary_expression_identifier(
                                  _pillar2c_task_handle)))))));
    } else {
        task_handle_as_unsigned_pointer =
          expr_gen(additive_expression,primary_expression,
               new primary_expression_expression(
                new expression_assignment_expression(
                 expr_gen(assignment_expression,cast_expression,
                             new cast_expression_type_name_cast_expression(
                              new type_name_specifier_qualifier_list_abstract_declarator(
                               new specifier_qualifier_list_type_specifier(
                                new type_specifier_UNSIGNED()),
                               new abstract_declarator_pointer(
                                new pointer_star())),
                              expr_gen(cast_expression,postfix_expression,
                                 new postfix_expression_call_expression(
                                   new call_expression_postfix_expression_empty_paren(
                                     new postfix_expression_primary_expression(
                                     new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))))))));
    }

    cast_expression *task_thread_handle_addr =
      expr_gen(cast_expression,primary_expression,
        new primary_expression_expression(
          new expression_assignment_expression(
            expr_gen(assignment_expression,additive_expression,
              new additive_expression_additive_expression_plus_multiplicative_expression(
                task_handle_as_unsigned_pointer,
                expr_gen(multiplicative_expression,primary_expression,
                  new primary_expression_constant("2")))))));

    cast_expression *task_thread_handle =
      expr_gen(cast_expression,primary_expression,
        new primary_expression_expression(
          new expression_assignment_expression(
            expr_gen(assignment_expression,unary_expression,
              new unary_expression_unary_operator_cast_expression(
                new unary_operator_star(),
                task_thread_handle_addr)))));

    cast_expression *mcrt_thread_addr_addr =
      expr_gen(cast_expression,primary_expression,
         new primary_expression_expression(
           new expression_assignment_expression(
             expr_gen(assignment_expression,cast_expression,
               new cast_expression_type_name_cast_expression(
                 new type_name_specifier_qualifier_list_abstract_declarator(
                   new specifier_qualifier_list_type_specifier(
                     new type_specifier_UNSIGNED()),
                       new abstract_declarator_pointer(
                         new pointer_star())),
                         task_thread_handle)))));

    cast_expression *mcrt_thread_addr =
      expr_gen(cast_expression,primary_expression,
        new primary_expression_expression(
          new expression_assignment_expression(
            expr_gen(assignment_expression,unary_expression,
              new unary_expression_unary_operator_cast_expression(
                new unary_operator_star(),
                mcrt_thread_addr_addr)))));

    additive_expression *short_cast =
      expr_gen(additive_expression,primary_expression,
           new primary_expression_expression(
            new expression_assignment_expression(
             expr_gen(assignment_expression,cast_expression,
                         new cast_expression_type_name_cast_expression(
                          new type_name_specifier_qualifier_list_abstract_declarator(
                           new specifier_qualifier_list_type_specifier(
                            new type_specifier_SHORT()),
                           new abstract_declarator_pointer(
                            new pointer_star())),
                          mcrt_thread_addr)))));

    expression *doNotRun_addr =
      new expression_assignment_expression(
       expr_gen(assignment_expression,additive_expression,
                 new additive_expression_additive_expression_plus_multiplicative_expression(
                  short_cast,
                  new multiplicative_expression_cast_expression(
                   expr_gen(cast_expression,primary_expression,
                      new primary_expression_constant("59"))))));

    statement *yield_call =
        new statement_expression_statement(
          new expression_statement_expression(
            new expression_assignment_expression(
              expr_gen(assignment_expression,postfix_expression,
                new postfix_expression_call_expression(
                  new call_expression_postfix_expression_paren_argument_expression_list(
                    new postfix_expression_primary_expression(
                      new primary_expression_identifier(g_scope_stack.find_or_add("pillar2cYield"))),
                    gen_extra_args()))))));

    return
      new statement_selection_statement(
       new selection_statement_if(
        new expression_assignment_expression(
         expr_gen(assignment_expression,unary_expression,
                      new unary_expression_unary_operator_cast_expression(
                       new unary_operator_star(),
                       expr_gen(cast_expression,primary_expression,
                          new primary_expression_expression(doNotRun_addr))))),
        // invoke prtYieldUnmanaged via prtInvokeUnmanagedFunc
        yield_call));
} // gen_yield_check_statement

block_item * gen_yield_check(void) {
    return new block_item_statement(gen_yield_check_statement(),0);
} // gen_yield_check

statement * statement_compound_statement::append(block_item_list *bil) {
    m_s = m_s->append(bil);
    return this;
}

statement * statement::append(block_item_list *bil) {
    AST_node *parent = m_parent;

    // Make a compound statement out of this statement.
    compound_statement *new_cs =
      new compound_statement_block_item_list(
       new block_item_list_block_item(
        new block_item_statement(
         this,0)));
    new_cs->check_consistency();

    // Add the extra code to it.
    new_cs = new_cs->append(bil);
    new_cs->check_consistency();

    statement *new_node = new statement_compound_statement(new_cs);
    new_node->check_consistency();

    parent->replace(this,new_node);
    return new_node;
}

TranslateResult cast_expression_type_name_cast_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_tn,tr1);
    TRANSLATE(m_ce,tr2);

    if(tr2.m_once_ref) {
        tr1.m_once_ref = true;
    }
    return tr1;
}

std::string direct_declarator_paren_declarator::get_name(void) {
    std::list<ii_ptr > defines = m_d->get_enclosing_symbols();
    if(defines.size() == 1) {
        return (*(defines.begin()))->get_name();
    } else {
        // FIX FIX FIX
        aeprintf("direct_declarator_paren_declarator::get_name problem.\n");
    }
}

TranslateResult call_expression_postfix_expression_empty_paren::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    add_vse_continuations_to_cuts(fd);
    if(m_id_vec.size()) {
        add_to_statement_cut(m_id_vec);

        if(!fd->m_has_except_var) {
            fd->m_has_except_var = true;

            block_item_list *bil =
                new block_item_list_block_item(
                    new block_item_text(std::string("void *_pillar2c_except_var;\n"))
                );

            fd->prepend_bil(bil);
        }
    }

    TRANSLATE(m_pe,tr);

    return tr;
}

bool parameter_list_parameter_declaration::is_void(void) {
    return m_pd->is_void();
}

bool declaration_specifiers_type_specifier::is_void(void) {
    return m_ts->is_void();
}

bool declaration_declaration_specifiers_init_declarator_list::declares_name(const char *name) {
    return m_idl->declares_name(name);
}

std::list<ii_ptr > direct_declarator_paren_declarator::get_enclosing_symbols(void) {
    return m_d->get_enclosing_symbols();
}

void statement_PRT_NOYIELD_compound_statement::print(void) const {
    if(!m_post_translate) {
        aeprintf("Should never emit a Pillar construct, noyield.\n");
    } else {
        m_s->print();
    }
}

void statement_PRT_VSE_compound_statement::print(void) const {
    if(!m_post_translate) {
        aeprintf("Should never emit a Pillar construct, vse.\n");
    } else {
        std::string local_cont_name  = m_ii->get_continuation_var_string();
        std::string local_cont_label = m_ii->get_continuation_label_string();

        oprintf("{\n");
        oprintf("__try {\n");
        if(g_use_th_param) {
            oprintf("prtPushVseForTask(_pillar2c_task_handle, & _pillar2c_RaiseException_continuation_target, & %s);\n", local_cont_name.c_str());
        } else {
            oprintf("prtPushVseForTask(prtGetTaskHandle(), & _pillar2c_RaiseException_continuation_target, & %s);\n", local_cont_name.c_str());
        }
        compound_statement_block_item_list *csbil = dynamic_cast<compound_statement_block_item_list *>(m_s);
        if(csbil) {
            csbil->get_block_item_list()->print();
        }
        oprintf("}\n");
        oprintf("__finally {\n");
        if(g_use_th_param) {
            oprintf("prtPopVseForTask(_pillar2c_task_handle);\n");
        } else {
            oprintf("prtPopVseForTask(prtGetTaskHandle());\n");
        }
        oprintf("}\n");
        oprintf("}\n");
    }
}

/*
 * Given the direct_declarator for a function prototype, go up the AST until you find the declaration.
 */
declaration * get_declaration_from_prototype(AST_node *dd) {
    return search_up_for_type<declaration>(dd);
} // get_declaration_from_prototype

void get_func_metadata_from_type(type_specifier *ts,call_expression_metadata &cem);

void id_info::get_func_metadata(call_expression_metadata &cem) {
#if 0
    if(get_string() == "try_lock") {
        printf("%p\n",m_fd);
        if(m_func_decl) {
            m_func_decl->print();
            printf("\n");
        }
    }
#endif
   if(get_string() == "__noop") {
        cem.m_pe_function = NULL;
        cem.m_ret = new expression_type;
        cem.m_ret->m_sql = new specifier_qualifier_list_type_specifier(new type_specifier_VOID());
        cem.m_ret->m_ad  = NULL;
        return;
    }

    if(m_fd) {
        if(m_func_decl) {
            declaration *protodecl = get_declaration_from_prototype(m_func_decl);
            if(protodecl) {
                // FIX FIX FIX...is there a better way to do this?
                // both prototype and implementation found...only the prototype may have updated signature...implementation may be processed later
                check_vector<parameter_declaration *> proto_params;
                m_func_decl->vectorize_params(proto_params,cem.m_func_metadata.m_ellipsis);
                m_fd->get_func_metadata(cem);
                if(proto_params.size() > cem.m_func_metadata.m_params.size()) {
                    cem.m_func_metadata.m_params = proto_params;
                }

                declaration_specifiers *ds = get_declaration_from_prototype(m_func_decl)->get_declaration_specifiers();
                assert(ds);
                cem.m_func_metadata.m_noreturn = ds->has_noreturn();
            } else {
                m_fd->get_func_metadata(cem);
            }
        } else {
            m_fd->get_func_metadata(cem);
        }
    } else if(m_func_decl) {
         direct_declarator *fv_parent = NULL;
        if(m_function_var) {
            fv_parent = dynamic_cast<direct_declarator*>(m_func_decl->get_parent());
        }
        if(fv_parent) {
            fv_parent->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
            declaration *fvd = get_declaration_from_prototype(m_func_decl);
            if(fvd) {
                declaration_specifiers *ds = fvd->get_declaration_specifiers();
                assert(ds);
                cem.m_ret = fvd->get_return_type();
                cem.m_func_metadata.m_noreturn = ds->has_noreturn();
            } else {
                parameter_declaration *pd = search_up_for_type<parameter_declaration>(m_func_decl);
                if(pd) {
                    declaration_specifiers *ds = pd->get_declaration_specifiers();
                    assert(ds);
                    cem.m_ret = pd->get_return_type();
                    cem.m_func_metadata.m_noreturn = ds->has_noreturn();
                } else {
                    aeprintf("A function variable doesn't seem to have a declaration or a parameter declaration.\n");
                }
            }
        } else {
            m_func_decl->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
            cem.m_ret = get_return_type();

            declaration_specifiers *ds = get_declaration_from_prototype(m_func_decl)->get_declaration_specifiers();
            assert(ds);
            cem.m_func_metadata.m_noreturn = ds->has_noreturn();
        }
    } else if(m_var) {
        if(type_or_lsi.m_type) {
            get_func_metadata_from_type(type_or_lsi.m_type,cem);
        } else {
            print();
            aeprintf("Don't know how to get function metadata for this symbol => %s.\n",m_id.c_str());
        }
    } else if(m_param) {
        if(type_or_lsi.m_type) {
            get_func_metadata_from_type(type_or_lsi.m_type,cem);
        } else {
            print();
            aeprintf("Don't know how to get function metadata for this symbol => %s.\n",m_id.c_str());
        }
    } else {
        print();
        aeprintf("Don't know how to get function metadata for this symbol => %s.\n",m_id.c_str());
    }
}

void direct_declarator_direct_declarator_parameter_type_list::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    m_ptl->vectorize(params,ellipsis);
}

specifier_qualifier_list * declaration_specifiers_type_specifier::gen_specifier_qualifier_list(void) {
    return new specifier_qualifier_list_type_specifier((type_specifier*)m_ts->clone());
}

specifier_qualifier_list * declaration_specifiers_type_specifier_declaration_specifiers::gen_specifier_qualifier_list(void) {
    specifier_qualifier_list *other = m_ds->gen_specifier_qualifier_list();
    if(other) {
        if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
            // use one internal type of "long long"
            if(other->is_this_long()) {
                type_specifier *new_ts = new type_specifier_LONG_LONG();
                specifier_qualifier_list *new_sql = other->remove_first();
                delete other;

                if(new_sql) {
                    return new specifier_qualifier_list_type_specifier_specifier_qualifier_list(new_ts,new_sql);
                } else {
                    return new specifier_qualifier_list_type_specifier(new_ts);
                }
            }
            // convert to one internal type for "long double"
            if(other->is_this_double()) {
                type_specifier *new_ts = new type_specifier_LONG_DOUBLE();
                specifier_qualifier_list *new_sql = other->remove_first();
                delete other;

                if(new_sql) {
                    return new specifier_qualifier_list_type_specifier_specifier_qualifier_list(new_ts,new_sql);
                } else {
                    return new specifier_qualifier_list_type_specifier(new_ts);
                }
            }
            // simplify "long int" to just "long"
            if(other->is_this_int()) {
                specifier_qualifier_list *new_sql = other->remove_first();
                delete other;

                if(new_sql) {
                    return new specifier_qualifier_list_type_specifier_specifier_qualifier_list(m_ts->clone(),new_sql);
                } else {
                    return new specifier_qualifier_list_type_specifier(m_ts->clone());
                }
            }
        }
        return
          new specifier_qualifier_list_type_specifier_specifier_qualifier_list(
              (type_specifier*)m_ts->clone(),
              other
          );
    } else {
        return
          new specifier_qualifier_list_type_specifier(
              (type_specifier*)m_ts->clone()
          );
    }
}

specifier_qualifier_list * declaration_specifiers_type_qualifier_declaration_specifiers::gen_specifier_qualifier_list(void) {
    specifier_qualifier_list *other = m_ds->gen_specifier_qualifier_list();
    if(other) {
        return
          new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
              (type_qualifier*)m_tq->clone(),
              other
          );
    } else {
        return
          new specifier_qualifier_list_type_qualifier(
              (type_qualifier*)m_tq->clone()
          );
    }
}

specifier_qualifier_list * declaration_specifiers_type_qualifier::gen_specifier_qualifier_list(void) {
    return new specifier_qualifier_list_type_qualifier((type_qualifier*)m_tq->clone());
}

struct_declaration * parameter_declaration_declaration_specifiers_abstract_declarator::gen_struct_declaration(unsigned arg_num, bool is_var_arg_param) {
    std::stringstream buf;
    buf << "arg" << arg_num;

    assert(!is_var_arg_param);

    specifier_qualifier_list *from_type, *sql;
    from_type = m_ds->gen_specifier_qualifier_list();
    if(m_ad->is_pointer()) {
        sql = from_type;
    } else {
        sql = (specifier_qualifier_list*)from_type->param_clone();
        delete from_type;
    }

    return
      new struct_declaration_specifier_qualifier_list_struct_declarator_list(
        sql,
        new struct_declarator_list_struct_declarator(
          m_ad->gen_struct_declarator(buf.str()))      );
}

type_specifier * type_specifier_struct_or_union_specifier::clone(void) const {
    type_specifier_struct_or_union_specifier *copy = new type_specifier_struct_or_union_specifier((struct_or_union_specifier*)m_sous->clone());
    copy->clone_copy(this);
    return copy;
}

type_specifier * type_specifier_enum_specifier::clone(void) const {
    type_specifier_enum_specifier * copy = new type_specifier_enum_specifier((enum_specifier*)m_es->clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * struct_or_union_specifier_struct_or_union_identifier::clone(void) const {
    struct_or_union_specifier_struct_or_union_identifier * copy = new struct_or_union_specifier_struct_or_union_identifier(
               (struct_or_union*)m_sou->clone(),
               m_id);
    copy->clone_copy(this);
    return copy;
}

bool must_convert_array_to_pointer(direct_declarator *dd) {
    direct_declarator_direct_declarator_empty_brace *ddddeb = dynamic_cast<direct_declarator_direct_declarator_empty_brace*>(dd);
    direct_declarator_direct_declarator_assignment_expression *ddddae = dynamic_cast<direct_declarator_direct_declarator_assignment_expression*>(dd);
    if(ddddeb || ddddae) {
        return true;
    } else {
        return false;
    }
}

struct_declarator * declarator_pointer_direct_declarator::gen_struct_declarator(std::string arg_name) {
    bool convert = must_convert_array_to_pointer(m_dd);

    if(convert) {
        return new struct_declarator_declarator(
            new declarator_pointer_direct_declarator(
             new pointer_star_pointer( (pointer*)m_p->clone() ),
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    } else {
        return new struct_declarator_declarator(
            new declarator_pointer_direct_declarator(
             (pointer*)m_p->clone(),
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    }
}

struct_declarator * declarator_direct_declarator::gen_struct_declarator(std::string arg_name) {
    bool convert = must_convert_array_to_pointer(m_dd);

    if(convert) {
        return new struct_declarator_declarator(
            new declarator_pointer_direct_declarator(
             new pointer_star(),
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    } else {
        return new struct_declarator_declarator(
            new declarator_direct_declarator(
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    }
}

struct_declarator * declarator_call_conv_specifier_direct_declarator::gen_struct_declarator(std::string arg_name) {
    bool convert = must_convert_array_to_pointer(m_dd);

    if(convert) {
        return new struct_declarator_declarator(
            new declarator_call_conv_specifier_pointer_direct_declarator(
             m_ccs->clone(),
             new pointer_star(),
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    } else {
        return new struct_declarator_declarator(
            new declarator_call_conv_specifier_direct_declarator(
             m_ccs->clone(),
             (direct_declarator*)m_dd->clone_for_struct_decl(arg_name,convert)));
    }
}

struct_declaration * assignment_expression_conditional_expression::gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd) {
    std::stringstream arg_str;
    arg_str << "arg" << arg_num;

    auto_ptr<expression_type> et(m_ce->get_type());
    if(!et.get()) {
        printf("Could not determine the type for the following expression in function %s:\n\t",fd.c_str());
        m_ce->print();
        printf("\n");
        exit(-1);
    }
    declarator *decl = NULL;
    if(et->m_ad) {
        is_var_arg_param = false;
        decl = et->m_ad->gen_declarator(arg_str.str());
    } else {
        decl = new declarator_direct_declarator(
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(arg_str.str())));
    }

    specifier_qualifier_list *sql = NULL;
    if(is_var_arg_param) {
        sql = (specifier_qualifier_list*)et->m_sql->vararg_clone();
    } else {
        if(decl->is_pointer()) {
            sql = (specifier_qualifier_list*)et->m_sql->clone();
        } else {
            sql = (specifier_qualifier_list*)et->m_sql->param_clone();
        }
    }

    return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
             sql,
             new struct_declarator_list_struct_declarator(
              new struct_declarator_declarator(
               decl)));
}

struct_declaration * assignment_expression_postfix_expression::gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd) {
    std::stringstream arg_str;
    arg_str << "arg" << arg_num;

    auto_ptr<expression_type> et(m_pe->get_type());
    if(!et.get()) {
        printf("Could not determine the type for the following expression in function %s:\n\t",fd.c_str());
        m_pe->print();
        printf("\n");
        exit(-1);
    }
    declarator *decl = NULL;
    if(et->m_ad) {
        is_var_arg_param = false;
        decl = et->m_ad->gen_declarator(arg_str.str());
    } else {
        decl = new declarator_direct_declarator(
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(arg_str.str())));
    }

    specifier_qualifier_list *sql = NULL;
    if(is_var_arg_param) {
        sql = (specifier_qualifier_list*)et->m_sql->vararg_clone();
    } else {
        if(decl->is_pointer()) {
            sql = (specifier_qualifier_list*)et->m_sql->clone();
        } else {
            sql = (specifier_qualifier_list*)et->m_sql->param_clone();
        }
    }

    return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
             sql,
             new struct_declarator_list_struct_declarator(
              new struct_declarator_declarator(
               decl)));
}

struct_declaration * assignment_expression_mainline::gen_struct_declaration(unsigned arg_num, bool is_var_arg_param, const std::string &fd) {
    std::stringstream arg_str;
    arg_str << "arg" << arg_num;

    auto_ptr<expression_type> et(m_pe->get_type());
    if(!et.get()) {
        printf("Could not determine the type for the following expression in function %s:\n\t",fd.c_str());
        m_pe->print();
        printf("\n");
        exit(-1);
    }
    declarator *decl = NULL;
    if(et->m_ad) {
        is_var_arg_param = false;
        decl = et->m_ad->gen_declarator(arg_str.str());
    } else {
        decl = new declarator_direct_declarator(
                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(arg_str.str())));
    }

    specifier_qualifier_list *sql = NULL;
    if(is_var_arg_param) {
        sql = (specifier_qualifier_list*)et->m_sql->vararg_clone();
    } else {
        if(decl->is_pointer()) {
            sql = (specifier_qualifier_list*)et->m_sql->clone();
        } else {
            sql = (specifier_qualifier_list*)et->m_sql->param_clone();
        }
    }

    return new struct_declaration_specifier_qualifier_list_struct_declarator_list(
             sql,
             new struct_declarator_list_struct_declarator(
              new struct_declarator_declarator(
               decl)));
}

specifier_qualifier_list * specifier_qualifier_list_type_qualifier_specifier_qualifier_list::clone(void) {
    specifier_qualifier_list_type_qualifier_specifier_qualifier_list * copy = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
            (type_qualifier*)m_tq->clone(),
            (specifier_qualifier_list*)m_ql->clone());
    copy->clone_copy(this);
    return copy;
}

specifier_qualifier_list * specifier_qualifier_list_type_qualifier::clone(void) {
    specifier_qualifier_list_type_qualifier * copy = new specifier_qualifier_list_type_qualifier(
            (type_qualifier*)m_tq->clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * specifier_qualifier_list_type_qualifier_specifier_qualifier_list::vararg_clone(void) {
    specifier_qualifier_list_type_qualifier_specifier_qualifier_list * copy = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
            (type_qualifier*)m_tq->clone(),
            (specifier_qualifier_list*)m_ql->vararg_clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * specifier_qualifier_list_type_qualifier::vararg_clone(void) {
    specifier_qualifier_list_type_qualifier * copy = new specifier_qualifier_list_type_qualifier(
            (type_qualifier*)m_tq->clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * specifier_qualifier_list_type_qualifier_specifier_qualifier_list::param_clone(void) {
    specifier_qualifier_list_type_qualifier_specifier_qualifier_list * copy = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
            (type_qualifier*)m_tq->clone(),
            (specifier_qualifier_list*)m_ql->param_clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * specifier_qualifier_list_type_qualifier::param_clone(void) {
    specifier_qualifier_list_type_qualifier * copy = new specifier_qualifier_list_type_qualifier(
            (type_qualifier*)m_tq->clone());
    copy->clone_copy(this);
    return copy;
}

expression_type * primary_expression_expression::get_type(void) {
    return m_e->get_type();
}

expression_type::~expression_type() {
    delete m_sql;
    delete m_ad;
}

expression_type * primary_expression_string::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
                  new type_qualifier_const(),
                  new specifier_qualifier_list_type_specifier(
                   new type_specifier_CHAR()
                  )
                 );
    ret->m_ad  = new abstract_declarator_pointer(
                  new pointer_star()
                 );

    return ret;
}

expression_type * primary_expression_constant_int::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_INT()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_unsigned::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_UNSIGNED()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_long::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_LONG()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_ulong::get_type(void) {
    expression_type *ret = new expression_type;

    // FIX FIX FIX is this right?
    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_LONG()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_ulonglong::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_INT64()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_float::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_FLOAT()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_double::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_DOUBLE()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_constant_long_double::get_type(void) {
    expression_type *ret = new expression_type;

    // FIX FIX FIX something better here?
    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_DOUBLE()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * primary_expression_identifier::get_type(void) {
    if(m_ii->is_param()) {
        return m_ii->get_parameter_declaration()->get_type();
    } else if(m_ii->is_function_var()) {
#ifdef SINGLE_DECLARATOR
        declarator *d = m_ii->get_declarator();
        assert(d);
#else
//        assert(m_ii->get_declarator().size() == 1);
        declarator *d= m_ii->get_last_declarator();
        assert(d);
#endif

        declaration *decl = NULL;
        AST_node *cur_node = d;

        while(!decl) {
            cur_node = cur_node->get_parent();
            if(!cur_node) break;
            decl = dynamic_cast<declaration *>(cur_node);
        }
        if(!cur_node) {
            aeprintf("Couldn't find the declaration for a variable.\n");
        } else {
            expression_type *ret = new expression_type;

            ret->m_sql = decl->get_declaration_specifiers()->gen_specifier_qualifier_list();
            ret->m_ad  = d->gen_abstract_declarator_for_type();

            return ret;
        }
    } else if(m_ii->is_var()) {
#ifdef SINGLE_DECLARATOR
        declarator *d = m_ii->get_declarator();
        assert(d);
#else
//        assert(m_ii->get_declarator().size() == 1);
        declarator *d= m_ii->get_last_declarator();
        assert(d);
#endif

        declaration *decl = NULL;
        AST_node *cur_node = d;

        while(!decl) {
            cur_node = cur_node->get_parent();
            if(!cur_node) break;
            decl = dynamic_cast<declaration *>(cur_node);
        }
        if(!cur_node) {
            aeprintf("Couldn't find the declaration for a variable.\n");
        } else {
            expression_type *ret = new expression_type;

            ret->m_sql = decl->get_declaration_specifiers()->gen_specifier_qualifier_list();
            ret->m_ad  = d->gen_abstract_declarator_for_type();

            return ret;
        }
    } else if(m_ii->is_continuation()) {
        type_specifier *ts = m_ii->get_type();
        if(!ts) {
            aeprintf("continuation is defined for symbol but type is absent.\n");
        }
        type_specifier_continuation *tsc = dynamic_cast<type_specifier_continuation*>(ts);
        if(!tsc) {
            aeprintf("Type defined for continuation symbol but is of non-continuation type.\n");
        }

        expression_type *ret = new expression_type;

        ret->m_sql = new specifier_qualifier_list_type_specifier(tsc->clone());
        ret->m_ad  = NULL;

        return ret;
    } else if(m_ii->is_function()) {
#ifdef SINGLE_DECLARATOR
        declarator *d = m_ii->get_declarator();
#else
        assert(m_ii->get_declarator().size() <= 1);
        declarator *d= m_ii->get_first_declarator();
#endif
        if(!d) {
            function_definition *this_fd = m_ii->get_func_definition();
            assert(this_fd);

            expression_type *ret = new expression_type;

            ret->m_sql = this_fd->get_declaration_specifiers()->gen_specifier_qualifier_list();
            ret->m_ad  = this_fd->get_declarator()->gen_abstract_declarator_for_type();

            return ret;
        } else {
            AST_node *cur_node = d;
            declaration *decl = NULL;

            while(!decl) {
                cur_node = cur_node->get_parent();
                if(!cur_node) break;
                decl = dynamic_cast<declaration *>(cur_node);
            }
            if(!cur_node) {
                aeprintf("Couldn't find the declaration for a function.\n");
            } else {
                expression_type *ret = new expression_type;

                ret->m_sql = decl->get_declaration_specifiers()->gen_specifier_qualifier_list();
                ret->m_ad  = d->gen_abstract_declarator_for_type();

                return ret;
            }
        }
    } else if(m_ii->is_enum_label()) {
        primary_expression_constant_int peci("");
        return peci.get_type();
    } else if(m_ii->get_string() == "__func__" || m_ii->get_string() == "__FUNCTION__" || m_ii->get_string() == "__PRETTY_FUNCTION__") {
        expression_type *ret = new expression_type;

        // give these things a type of "char *"
        ret->m_sql = new specifier_qualifier_list_type_specifier(new type_specifier_CHAR());
        ret->m_ad  = new abstract_declarator_pointer(new pointer_star());

        return ret;
    } else {
        return NULL;
    }
}

expression_type * primary_expression_identifier::get_return_type(void) {
    if(m_ii->is_function()) {
        return m_ii->get_return_type();
    } else if(m_ii->is_function_var()) {
        return m_ii->get_return_type();
    } else if(m_ii->is_var()) {
        type_specifier *ts = m_ii->get_type()->get_base_type();
        if(!ts) {
            aeprintf("type not found for variable in primary_expression_identifier::get_return_type.\n");
        }
        type_specifier_TYPE_NAME *tstn = dynamic_cast<type_specifier_TYPE_NAME *>(ts);
        if(tstn) {
            ii_ptr ii = tstn->get_id_info();
            if(ii->is_function_var()) {
                direct_declarator *ddfd = ii->get_func_decl();
                if(ddfd) {
                    declaration *the_d = NULL;
                    AST_node *cur_node = ddfd;
                    while(cur_node && !the_d) {
                        cur_node = cur_node->get_parent();
                        the_d = dynamic_cast<declaration*>(cur_node);
                    }
                    if(the_d) {
                        declaration_specifiers *the_ds = the_d->get_declaration_specifiers();
                        expression_type *ret = new expression_type;

                        ret->m_sql = the_ds->gen_specifier_qualifier_list();
                        // FIX FIX FIX...this won't always be NULL will it?
                        ret->m_ad  = NULL;

                        return ret;
                    } else {
                        aeprintf("get_return_type\n");
                    }
                } else {
                    aeprintf("get_return_type\n");
                }
            } else {
                aeprintf("get_return_type\n");
            }
        } else {
            aeprintf("get_return_type\n");
        }
    } else {
        if(m_ii->get_string() == "__noop") {
            expression_type *ret = new expression_type;

            ret->m_sql = new specifier_qualifier_list_type_specifier(
                          new type_specifier_VOID()
                         );
            ret->m_ad  = NULL;

            return ret;
        } else if(m_ii->get_string() == "__builtin_offsetof") {
            primary_expression_constant_int peci("");
            return peci.get_type();
        } else {
            aeprintf("get_return_type\n");
        }
    }
}

expression_type * parameter_declaration_declaration_specifiers::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = m_ds->gen_specifier_qualifier_list();
    ret->m_ad  = NULL;

    return ret;
}

expression_type * parameter_declaration_declaration_specifiers_abstract_declarator::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = m_ds->gen_specifier_qualifier_list();
    ret->m_ad  = m_ad->clone();

    return ret;
}

expression_type * parameter_declaration_declaration_specifiers_declarator::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = m_ds->gen_specifier_qualifier_list();
    ret->m_ad  = m_d->gen_abstract_declarator_for_type();

    return ret;
}

expression_type * id_info::get_return_type(void) {
    if(m_fd) {
        return m_fd->get_return_type();
    } else if(m_func_decl) {
        expression_type *ret = new expression_type;

        declaration *decl = search_up_for_type<declaration>(m_func_decl);
        if(decl) {
            ret->m_sql = decl->get_declaration_specifiers()->gen_specifier_qualifier_list();
        } else {
            parameter_declaration *pd = search_up_for_type<parameter_declaration>(m_func_decl);
            if(pd) {
                ret->m_sql = pd->get_declaration_specifiers()->gen_specifier_qualifier_list();
            } else {
                aeprintf("Couldn't find a declaration or a parameter declaration for a function prototype.\n");
            }
        }

        declarator *d = search_up_for_type<declarator>(m_func_decl);
        if(d) {
            ret->m_ad = d->gen_abstract_declarator_for_type();
        } else {
            aeprintf("Couldn't find the declarator for a function prototype.\n");
        }

        return ret;
    } else if(m_param) {
        expression_type *ret = new expression_type;

        assert(type_or_lsi.m_type);
        parameter_declaration *pd = search_up_for_type<parameter_declaration>(type_or_lsi.m_type);
        if(pd) {
            ret->m_sql = pd->get_declaration_specifiers()->gen_specifier_qualifier_list();
        } else {
            aeprintf("Couldn't find a parameter declaration for a symbol labeled as a parameter.\n");
        }

        declarator *d = search_up_for_type<declarator>(type_or_lsi.m_type);
        if(d) {
            ret->m_ad = d->gen_abstract_declarator_for_type();
        } else {
            aeprintf("Couldn't find the declarator for a function prototype.\n");
        }

        return ret;
    } else if(m_var) {
        expression_type *ret = new expression_type;

        assert(type_or_lsi.m_type);
        declaration *pd = search_up_for_type<declaration>(type_or_lsi.m_type);
        if(pd) {
            ret->m_sql = pd->get_declaration_specifiers()->gen_specifier_qualifier_list();
        } else {
            aeprintf("Couldn't find a declaration for a symbol labeled as a variable.\n");
        }

        declaration_declaration_specifiers_init_declarator_list *ddsidl = dynamic_cast<declaration_declaration_specifiers_init_declarator_list*>(pd);
        if(ddsidl) {
            init_declarator_list *idl = ddsidl->get_init_declarator_list();
            declarator *d = idl->get_declarator_with_name(get_name());
            if(d) {
                ret->m_ad = d->gen_abstract_declarator_for_type();
            } else {
                aeprintf("Couldn't find the declarator for a function prototype.\n");
            }
        } else {
            aeprintf("Couldn't find the init declarator for a symbol labeled as a variable.\n");
        }

        return ret;
    } else {
        print();
        printf("\n");
        aeprintf("Don't know how to get the expression type for symbol %s.\n",m_id.c_str());
    }
}

expression_type * declaration_declaration_specifiers::get_return_type(void) {
    assert(is_function());

    expression_type *ret = new expression_type;

    ret->m_sql = m_ds->gen_specifier_qualifier_list();
    ret->m_ad  = NULL;

    return ret;
}

expression_type * declaration_declaration_specifiers_init_declarator_list::get_return_type(void) {
//    assert(is_function());

    expression_type *ret = new expression_type;

    ret->m_sql = m_ds->gen_specifier_qualifier_list();
    init_declarator_list_init_declarator *idlid = dynamic_cast<init_declarator_list_init_declarator *>(m_idl);
    if(idlid) {
        ret->m_ad = idlid->get_init_declarator()->get_declarator()->gen_abstract_declarator();
    } else {
        aeprintf("Don't know how to generate an abstract declarator for a non-init_declarator_list_init_declarator.\n");
    }

    return ret;
}

// --------------------------------------------------------------------------

abstract_declarator * declarator_pointer_call_conv_specifier_direct_declarator::gen_abstract_declarator_for_type(void) {
    if(m_dd->is_array()) {
        return new abstract_declarator_pointer(new pointer_star_pointer((pointer*)m_p->clone()));
    } else {
        return new abstract_declarator_pointer((pointer*)m_p->clone());
    }
}

abstract_declarator * declarator_call_conv_specifier_pointer_direct_declarator::gen_abstract_declarator_for_type(void) {
    if(m_dd->is_array()) {
        return new abstract_declarator_pointer(new pointer_star_pointer((pointer*)m_p->clone()));
    } else {
        return new abstract_declarator_pointer((pointer*)m_p->clone());
    }
}

abstract_declarator * declarator_call_conv_specifier_direct_declarator::gen_abstract_declarator_for_type(void) {
    if(m_dd->is_array()) {
        return new abstract_declarator_pointer(new pointer_star());
    } else {
        direct_abstract_declarator *dad = m_dd->gen_direct_abstract_declarator();
        if(dad) {
            return new abstract_declarator_direct_abstract_declarator(dad);
        } else {
            return NULL;
        }
    }
}

abstract_declarator * declarator_pointer_direct_declarator::gen_abstract_declarator(void) {
    if(m_dd->is_array()) {
        return new abstract_declarator_pointer(new pointer_star_pointer((pointer*)m_p->clone()));
    } else {
        return new abstract_declarator_pointer((pointer*)m_p->clone());
    }
}

abstract_declarator * declarator_direct_declarator::gen_abstract_declarator(void) {
    return m_dd->gen_abstract_declarator();
#if 0
    if(m_dd->is_array()) {
        return new abstract_declarator_pointer(new pointer_star());
    } else {
        // no such conversion possible
        return NULL;
    }
#endif
}
// --------------------------------------------------------------------------

expression_type * cast_expression_type_name_cast_expression::get_type(void) {
    return m_tn->get_type();
}

expression_type * type_name_specifier_qualifier_list::get_type(void) {
    expression_type * ret = new expression_type;
    ret->m_sql = (specifier_qualifier_list*)m_sql->clone();
    return ret;
}

expression_type * type_name_specifier_qualifier_list_abstract_declarator::get_type(void) {
    expression_type * ret = new expression_type;
    ret->m_sql = (specifier_qualifier_list*)m_sql->clone();
    ret->m_ad  = (abstract_declarator*)m_ad->clone();
    return ret;
}

expression_type * unary_expression_sizeof_unary_expression::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_INT()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * unary_expression_sizeof_type_name::get_type(void) {
    expression_type *ret = new expression_type;

    ret->m_sql = new specifier_qualifier_list_type_specifier(
                  new type_specifier_INT()
                 );
    ret->m_ad  = NULL;

    return ret;
}

expression_type * unary_expression_unary_operator_cast_expression::get_type(void) {
    expression_type *m_ce_type = m_ce->get_type();

    if(dynamic_cast<unary_operator_and*>(m_uo)) {
#if 0
        expression_type *ret = new expression_type;

        ret->m_sql = (specifier_qualifier_list*)m_ce_type->m_sql->clone();

        if(m_ce_type->m_ad) {
            ret->m_ad = m_ce_type->m_ad->add_pointer_star();
        } else {
            ret->m_ad = new abstract_declarator_pointer(new pointer_star());
        }

        delete m_ce_type;
        return ret;
#else
        if(m_ce_type->m_ad) {
            m_ce_type->m_ad = m_ce_type->m_ad->add_pointer_star();
        } else {
            m_ce_type->m_ad = new abstract_declarator_pointer(new pointer_star());
        }

        return m_ce_type;
#endif
    } else if(dynamic_cast<unary_operator_star*>(m_uo)) {
#if 0
        expression_type *ret = new expression_type;

        ret->m_sql = (specifier_qualifier_list*)m_ce_type->m_sql->clone();

        assert(m_ce_type->m_ad);
        ret->m_ad  = m_ce_type->m_ad->remove_pointer_star();

        delete m_ce_type;
        return ret;
#else
        expression_type *m_base_type = m_ce_type->get_base_type();

        if(!m_base_type->m_ad) {
            aeprintf("Non-pointer type dereferenced in unary_expression_unary_operator_cast_expression::get_type, line %d\n",get_line_number());
        }
        abstract_declarator *old_ad = m_base_type->m_ad;
        m_base_type->m_ad = old_ad->remove_pointer_star();
        delete old_ad;
        delete m_ce_type;
        return m_base_type;
#endif
    } else {
        return m_ce_type;
    }
}

expression_type * postfix_expression_postfix_expression_dot_identifier::get_type(void) {
    auto_ptr<expression_type> pe_type(m_pe->get_type());

    Scope *field_scope;

    if(pe_type->is_struct(field_scope)) {
        //check_vector<Scope *> child_scopes = field_scope->get_child_scopes();
        map_str_ii::iterator miter;
        for(miter  = field_scope->begin();
            miter != field_scope->end();
            miter++) {

            ii_ptr ii = miter->second;
            if(!ii->is_var()) continue;

#ifdef SINGLE_DECLARATOR
            declarator *iid = ii->get_declarator();
            assert(iid);
#else
            assert(ii->get_declarator().size() == 1);
            declarator *iid = ii->get_first_declarator();
            assert(iid);
#endif

            if(iid->declares_name(m_id.c_str())) {
                type_specifier *ts = ii->get_type();
                if(!ts) {
                    aeprintf("type not found in postfix_expression_postfix_expression_dot_identifier::get_type.\n");
                }
                specifier_qualifier_list *sql = dynamic_cast<specifier_qualifier_list*>(ts->get_parent());
                assert(sql);

                expression_type *ret = new expression_type;

                ret->m_sql = (specifier_qualifier_list*)sql->clone();
                ret->m_ad  = iid->gen_abstract_declarator();

                return ret;
            }
        }
        aeprintf("postfix_expression_postfix_expression_dot_identifier::get_type\n");
    } else {
        aeprintf("postfix_expression_postfix_expression_dot_identifier::get_type\n");
    }
}

PILLAR2C_CALLCONV postfix_expression_postfix_expression_dot_identifier::get_call_cc(void) const {
    auto_ptr<expression_type> pe_type(m_pe->get_type());

    Scope *field_scope;

    if(pe_type->is_struct(field_scope)) {
        //check_vector<Scope *> child_scopes = field_scope->get_child_scopes();
        map_str_ii::iterator miter;
        for(miter  = field_scope->begin();
            miter != field_scope->end();
            miter++) {

            ii_ptr ii = miter->second;
            if(!ii->is_var()) continue;

#ifdef SINGLE_DECLARATOR
            declarator *iid = ii->get_declarator();
            assert(iid);
#else
            assert(ii->get_declarator().size() == 1);
            declarator *iid = ii->get_first_declarator();
            assert(iid);
#endif

            if(iid->declares_name(m_id.c_str())) {
                return iid->get_call_conv();
            }
        }
        aeprintf("get_call_cc\n");
    } else {
        aeprintf("get_call_cc\n");
    }
}

expression_type * postfix_expression_postfix_expression_ptr_op_identifier::get_return_type(void) {
    auto_ptr<expression_type> apet_res(get_type());
    auto_ptr<expression_type> apet(apet_res->get_base_type());
    if(apet->m_ad->is_function()) {
        expression_type *ret = new expression_type;

        ret->m_sql = apet->m_sql->clone();
        ret->m_ad  = NULL;

        return ret;
    } else {
        aeprintf("Internal error: postfix_expression_postfix_expression_ptr_op_identifier::get_return_type on non-function type.\n");
    }
}

expression_type * postfix_expression_postfix_expression_ptr_op_identifier::get_type(void) {
    auto_ptr<expression_type> pe_type(m_pe->get_type());

    Scope *field_scope;

    if(pe_type->is_struct(field_scope)) {
        map_str_ii::iterator miter;
        for(miter  = field_scope->begin();
            miter != field_scope->end();
            miter++) {

            ii_ptr ii = miter->second;
            if(!ii->is_var()) continue;

#ifdef SINGLE_DECLARATOR
            declarator *iid = ii->get_declarator();
            assert(iid);
#else
            assert(ii->get_declarator().size() == 1);
            declarator *iid = ii->get_first_declarator();
            assert(iid);
#endif

            if(iid->declares_name(m_id.c_str())) {
                type_specifier *ts = ii->get_type();
                if(!ts) {
                    aeprintf("type not found in postfix_expression_postfix_expression_dot_identifier::get_type.\n");
                }
                specifier_qualifier_list *sql = dynamic_cast<specifier_qualifier_list*>(ts->get_parent());
                assert(sql);

                expression_type *ret = new expression_type;

                ret->m_sql = (specifier_qualifier_list*)sql->clone();
                ret->m_ad  = iid->gen_abstract_declarator();

                return ret;
            }
        }
        print();
        printf("\n");
        aeprintf("Field %s is not a member of the struct.\n",m_id.c_str());
//        aeprintf("Field %s is not a member of the struct at line %d in function %s.\n",m_id.c_str(),get_line_number(),find_enclosing_function()->get_symbol()->get_name());
    } else {
        print();
        printf("\n");
        aeprintf("Tried to use the -> operator on a non-struct type.\n");
//        aeprintf("Tried to use the -> operator on a non-struct type at line %d in function %s.\n",get_line_number(),find_enclosing_function()->get_symbol()->get_name());
    }
}

PILLAR2C_CALLCONV postfix_expression_postfix_expression_ptr_op_identifier::get_call_cc(void) const {
    auto_ptr<expression_type> pe_type(m_pe->get_type());

    Scope *field_scope;

    if(pe_type->is_struct(field_scope)) {
        //check_vector<Scope *> child_scopes = field_scope->get_child_scopes();
        map_str_ii::iterator miter;
        for(miter  = field_scope->begin();
            miter != field_scope->end();
            miter++) {

            ii_ptr ii = miter->second;
            if(!ii->is_var()) continue;

#ifdef SINGLE_DECLARATOR
            declarator *iid = ii->get_declarator();
            assert(iid);
#else
            assert(ii->get_declarator().size() == 1);
            declarator *iid = ii->get_first_declarator();
            assert(iid);
#endif

            if(iid->declares_name(m_id.c_str())) {
                return iid->get_call_conv();
            }
        }
        aeprintf("get_call_cc\n");
    } else {
        aeprintf("get_call_cc\n");
    }
}

bool expression_type::is_struct(Scope *&struct_scope) {
    return m_sql->is_struct(struct_scope);
}

bool type_specifier_struct_or_union_specifier::is_struct(Scope *&struct_scope) {
    struct_or_union_specifier_struct_or_union_identifier *soussoui = dynamic_cast<struct_or_union_specifier_struct_or_union_identifier *>(m_sous);
    struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list *soussouisdl = dynamic_cast<struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list *>(m_sous);
    if(soussoui) {
        std::string struct_name  = soussoui->get_name();
        ii_ptr  ii = g_scope_stack.find_symbol_bottom(struct_name);
        assert(ii);
        assert(ii->is_struct_enum());
        struct_scope = ii->get_struct_scope();
    } else if(soussouisdl) {
        std::string struct_name  = soussouisdl->get_name();
        ii_ptr  ii = g_scope_stack.find_symbol_bottom(struct_name);
        assert(ii);
        assert(ii->is_struct_enum());
        struct_scope = ii->get_struct_scope();
    } else {
        struct_scope = m_sous->get_scope();
    }

    assert(struct_scope);
    return true;
}

pointer * pointer_star_type_qualifier_list::clone(void) const {
    pointer_star_type_qualifier_list *copy = new pointer_star_type_qualifier_list((type_qualifier_list*)m_tql->clone());
    copy->clone_copy(this);
    return copy;
}

std::list<std::pair<ii_ptr ,declarator *> > struct_declarator_list_struct_declarator::add_to_symbol_table() const {
    std::list<std::pair<ii_ptr ,declarator *> > ret;
    declarator *d = m_sd->get_declarator();
    if(d) {
        ret.push_back(std::pair<ii_ptr,declarator*>(m_sd->add_to_symbol_table(),d));
    }
    return ret;
}

std::list<std::pair<ii_ptr ,declarator *> > struct_declarator_list_struct_declarator_list_struct_declarator::add_to_symbol_table() const {
    std::list<std::pair<ii_ptr ,declarator *> > ret = m_sdl->add_to_symbol_table();
    declarator *d = m_sd->get_declarator();
    if(d) {
        ret.push_back(std::pair<ii_ptr,declarator*>(m_sd->add_to_symbol_table(),d));
    }
    return ret;
}

expression_type * postfix_expression_postfix_expression_brace_expression::get_type(void) {
    auto_ptr<expression_type> ret(m_pe->get_type());
    expression_type *ret_base = ret->get_base_type();
    if(!ret_base->m_ad) {
        aeprintf("postfix_expression_postfix_expression_brace_expression::get_type() has NULL abstract_declarator at line %d\n",get_line_number());
    }
    pointer *p = ret_base->m_ad->get_pointer();
    assert(p);
    abstract_declarator *one_less_pointer = ret_base->m_ad->remove_pointer_star();
    delete ret_base->m_ad;
    ret_base->m_ad = one_less_pointer;
    return ret_base;
}

void abstract_declarator_pointer::add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
    abstract_declarator_call_conv_specifier_pointer * new_node =
       new abstract_declarator_call_conv_specifier_pointer(
        gen_call_conv_specifier(cc),
        m_p);
    m_parent->replace(this,new_node);
    m_p = NULL;
    delete this;
}

TranslateResult direct_abstract_declarator_empty_paren::translate_pillar(function_definition *fd) {
    return TranslateResult();
}

TranslateResult direct_abstract_declarator_direct_abstract_declarator_empty_parens::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_dad,tr);

    if(!g_intel64) {
        m_dad->add_explicit_call_conv(m_dad->get_call_conv());
    }

#if 1
    if(get_call_conv() == ST_PDECL) {
//    if(cc_to_man_unman(get_call_conv()) == MU_MANAGED) {
        parameter_list *extra_params = gen_extra_params();
        direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list *new_node =
          new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
            m_dad,
            new parameter_type_list_parameter_list(
              extra_params
            )
          );
        m_parent->replace(this,new_node);
        m_dad = NULL;
        delete this;
    }
#endif

    return tr;
}

void abstract_declarator_pointer_direct_abstract_declarator::add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
   abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator * new_node = new abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(gen_call_conv_specifier(cc),m_p,m_dad);
   m_parent->replace(this,new_node);
   m_p = NULL;
   m_dad = NULL;
   delete this;
}

compound_statement * AST_node::get_enclosing_compound_statement(void) {
    compound_statement *cs = dynamic_cast<compound_statement*>(this);
    if(cs) return cs;

    if(m_parent) {
        return m_parent->get_enclosing_compound_statement();
    } else {
        return NULL;
    }
}

std::list<block_item *> initializer_assignment_expression::gen_initializer_block_item(decl_init_wrapper &diw) {
    unary_expression *ue = diw.gen_unary_expression();

    block_item * new_block_item =
        new block_item_statement(
         new statement_expression_statement(
          new expression_statement_expression(
           new expression_assignment_expression(
            new assignment_expression_unary_expression_assignment_operator_assignment_expression(
             ue,
             new assignment_operator_equal(),
             m_ae)))),0);
    std::list<block_item*> ret_list;
    ret_list.push_back(new_block_item);
    m_ae = NULL;
    return ret_list;
}

std::list<block_item *> initializer_initializer_list::gen_initializer_block_item(decl_init_wrapper &diw) {
    return m_il->gen_initializer_block_item(diw);
}

std::list<block_item *> initializer_initializer_list_comma::gen_initializer_block_item(decl_init_wrapper &diw) {
    return m_il->gen_initializer_block_item(diw);
}

postfix_expression * decl_init_wrapper::gen_postfix_expression(void) {
    postfix_expression *pe = NULL;
    // do something with designation if present
    if(m_designation) {
        designation *save = m_designation;
        m_designation = NULL;
        pe = save->gen_postfix_expression_for_init(*this);
        m_designation = save;
        return pe;
    } else {
        pe = m_d->gen_postfix_expression_for_init(m_index);
    }

    return pe;
}

 unary_expression * decl_init_wrapper::gen_unary_expression(void) {
    return new unary_expression_postfix_expression(gen_postfix_expression());
}

struct_or_union_STRUCT_declspec::~struct_or_union_STRUCT_declspec(void) {
     delete m_ds;
}

struct_or_union_UNION_declspec::~struct_or_union_UNION_declspec(void) {
     delete m_ds;
}

void struct_or_union_STRUCT_declspec::print(void) const {
    oprintf("struct ");
    m_ds->print();
}

void struct_or_union_UNION_declspec::print(void) const {
    oprintf("union ");
    m_ds->print();
}

void uudeclspec_list_uudeclspec::print(void) const {
    oprintf("__declspec(");
    m_ds->print();
    oprintf(")");
}

void uudeclspec_list_uudeclspec_list_uudeclspec::print(void) const {
    m_ul->print();
    oprintf(" __declspec(");
    m_ds->print();
    oprintf(")");
}

uudeclspec_list_uudeclspec * uudeclspec_list_uudeclspec::clone(void) const {
    uudeclspec_list_uudeclspec * copy = new uudeclspec_list_uudeclspec((declspec_specifier*)m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

uudeclspec_list_uudeclspec_list_uudeclspec * uudeclspec_list_uudeclspec_list_uudeclspec::clone(void) const {
    uudeclspec_list_uudeclspec_list_uudeclspec * copy = new uudeclspec_list_uudeclspec_list_uudeclspec(m_ul->clone(),(declspec_specifier*)m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

struct_or_union_STRUCT_declspec * struct_or_union_STRUCT_declspec::clone(void) const {
    struct_or_union_STRUCT_declspec *copy = new struct_or_union_STRUCT_declspec((uudeclspec_list*)m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

struct_or_union_UNION_declspec * struct_or_union_UNION_declspec::clone(void) const {
    struct_or_union_UNION_declspec *copy = new struct_or_union_UNION_declspec((uudeclspec_list*)m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

PILLAR2C_CALLCONV cast_expression_type_name_cast_expression::get_call_conv_down(void) {
    return m_tn->get_call_conv_down();
}

PILLAR2C_CALLCONV type_name_specifier_qualifier_list_abstract_declarator::get_call_conv_down(void) {
    return fix_cc_default(m_ad->get_call_conv());
}

PILLAR2C_CALLCONV abstract_declarator_direct_abstract_declarator::get_call_conv(void) {
    return m_dad->get_call_conv_down();
}

PILLAR2C_CALLCONV id_info::get_function_cc(void) {
    if(m_cc == ST_NOT_DEFINED) {
        if(type_or_lsi.m_type) {
            m_cc = type_or_lsi.m_type->get_call_conv_down();
        } else {
            return ST_NOT_DEFINED;
//            aeprintf("get_function_cc failure since cc not defined and type not known.\n");
        }
    }
    return m_cc;
}

void init_declarator_declarator_initializer::sub_destroyed(AST_node *node) {
    if(node == (AST_node *)m_i) {
        init_declarator_declarator *new_node = new init_declarator_declarator(m_d);
        delete m_i;
        m_i = NULL;
        m_d = NULL;
        m_parent->replace(this,new_node);
    } else {
        decl_init_wrapper diw(m_d);

        std::list<block_item *> new_list = m_i->gen_initializer_block_item(diw);
        assert(new_list.size() == 1);
        block_item *bi = new_list.front();
        replace_block_item(bi);
    }
}

block_item_list * gen_pillar2c_pcall_target_args_decl(call_expression *ce) {
    std::stringstream var_buf;
    var_buf << "pillar2c_pcall_target_args_" << ce->get_unique();

    block_item_list * bil =
        new block_item_list_block_item(
          new block_item_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("pillar2c_pcall_target_args"))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_buf.str())))))),0));

    return bil;
}

block_item_list * gen_pillar2c_pcall_args_decl(call_expression *ce) {
    std::stringstream type_buf;
    type_buf << "PrtPcallArgs_" << ce->get_unique();

    std::stringstream var_buf;
    var_buf << "prt_pcall_args_" << ce->get_unique();

    block_item_list * bil =
        new block_item_list_block_item(
          new block_item_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(type_buf.str()))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_buf.str())))))),0));

    return bil;
}

#define auto_expr_gen_type_pair(x,y) \
    if(start == typeid(x)) { \
        return new x##_##y((y*)auto_expr_gen(typeid(y),end,node)); \
    }

#define auto_expr_gen_mainline(x) \
    if(start == typeid(x)) { \
       return new x##_##mainline(node); \
    }

template <class T>
AST_node * auto_expr_gen(const std::type_info &start, const std::type_info &end, T * node) {
    if(start == end) {
        return node;
    }
    if(g_short_mainline == 2) {
        auto_expr_gen_mainline(assignment_expression)
        auto_expr_gen_mainline(conditional_expression)
        auto_expr_gen_mainline(logical_or_expression)
        auto_expr_gen_mainline(logical_and_expression)
        auto_expr_gen_mainline(inclusive_or_expression)
        auto_expr_gen_mainline(exclusive_or_expression)
        auto_expr_gen_mainline(and_expression)
        auto_expr_gen_mainline(equality_expression)
        auto_expr_gen_mainline(relational_expression)
        auto_expr_gen_mainline(shift_expression)
        auto_expr_gen_mainline(additive_expression)
        auto_expr_gen_mainline(multiplicative_expression)
        auto_expr_gen_mainline(cast_expression)
    } else {
        auto_expr_gen_type_pair(assignment_expression,conditional_expression)
        auto_expr_gen_type_pair(conditional_expression,logical_or_expression)
        auto_expr_gen_type_pair(logical_or_expression,logical_and_expression)
        auto_expr_gen_type_pair(logical_and_expression,inclusive_or_expression)
        auto_expr_gen_type_pair(inclusive_or_expression,exclusive_or_expression)
        auto_expr_gen_type_pair(exclusive_or_expression,and_expression)
        auto_expr_gen_type_pair(and_expression,equality_expression)
        auto_expr_gen_type_pair(equality_expression,relational_expression)
        auto_expr_gen_type_pair(relational_expression,shift_expression)
        auto_expr_gen_type_pair(shift_expression,additive_expression)
        auto_expr_gen_type_pair(additive_expression,multiplicative_expression)
        auto_expr_gen_type_pair(multiplicative_expression,cast_expression)
        auto_expr_gen_type_pair(cast_expression,unary_expression)
    }
    auto_expr_gen_type_pair(unary_expression,postfix_expression)
    auto_expr_gen_type_pair(postfix_expression,primary_expression)
    assert(0);
    return NULL;
}

TranslateResult statement_pcall_call_expression::translate_pillar(function_definition *fd) {
    base_translate(fd);

    unsigned index;

    TranslateResult tr;
    TRANSLATE(m_ce,tr);

    if(g_pillar2c_debug_level > 2) {
        printf("//statement_pcall_call_expression::translate_pillar\n");
    }

    // Get the function that this function call takes place in.
    assert(fd);
    if(g_pillar2c_debug_level > 2) {
        printf("// fd = %p, name = %s\n",fd,fd->get_symbol()->get_name());
        printf("// Parent CC = %s, Callee CC = %s\n",cc_to_str(fd->get_function_cc()),cc_to_str(m_ce->get_call_cc()));
    }

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV  callee_cc = m_ce->get_call_cc();
    // See if that target is managed or not.
    MAN_UNMAN callee_managed = cc_to_man_unman(callee_cc);
    if(callee_managed != MU_MANAGED) {
        aeprintf("PCALL target not a managed function.\n");
    }

    // Get the function expression and a vector of function arguments.
    auto_ptr<call_expression_metadata> cem(m_ce->get_call_metadata());

    unsigned p2c_param_num = get_num_p2c_added_params();
    if(cem->m_args.size() != cem->m_func_metadata.m_params.size() - p2c_param_num) {
        aeprintf("params should include pillar2c args while args should not.\n");
    } else {
        for(index = 0; index < cem->m_args.size(); ++index) {
            cem->m_func_metadata.m_params[index] = cem->m_func_metadata.m_params[index + p2c_param_num];
        }
        for(index = 0; index < p2c_param_num; ++index) {
            cem->m_func_metadata.m_params.pop_back();
        }
        assert(cem->m_args.size() == cem->m_func_metadata.m_params.size());
    }
    size_t callee_num_args = cem->m_args.size();

    std::string stub_name = "prtPcall";
    ii_ptr stub_symbol  = g_scope_stack.find_symbol(stub_name);
    if(!stub_symbol) {
        aeprintf("Pillar stub %s not found in symbol table.\n",stub_name.c_str());
    }

    std::stringstream callsite_str;
    callsite_str << "PrtPcallArgs_" << m_ce->get_unique();

    std::stringstream callsite_prt_pcall_args_buf;
    callsite_prt_pcall_args_buf << "prt_pcall_args_" << m_ce->get_unique();
//    callsite_prt_pcall_args_buf << "prt_arguments.prt_pcall_args_" << m_ce;

    if(cem->m_args.size()) {
        std::list<external_declaration *> spec_struct = gen_specific_callsite_prt_args(3,fd->get_symbol()->get_string(),callsite_str.str(),*cem);
//        external_declaration *spec_struct = gen_specific_callsite_prt_args(callsite_str,cem);
//        spec_struct->print();
        fd->insert_before_top_level(spec_struct);
        if(g_prt_args_in_pseudo) {
            fd->add_prt_arg_list(m_ce->get_unique(), callsite_str.str(), callsite_prt_pcall_args_buf.str());
        } else {
            fd->prepend_bil(gen_pillar2c_pcall_args_decl(m_ce));
        }
    }

    assignment_expression *pillar2c_pcall_function_expression =
      expr_gen(assignment_expression,cast_expression,
        new cast_expression_type_name_cast_expression(
          new type_name_specifier_qualifier_list(
            new specifier_qualifier_list_type_specifier(
              new type_specifier_TYPE_NAME(g_scope_stack.find_symbol("PrtCodeAddress")))),
          expr_gen(cast_expression,primary_expression,
            new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_pcall_target")))));

    argument_expression_list *pillar2c_pcall_func_arg = new argument_expression_list_assignment_expression(pillar2c_pcall_function_expression);

    std::stringstream stub_args_name;
    stub_args_name << "pillar2c_pcall_target_args_" << m_ce->get_unique();

    assignment_expression * pillar2c_pcall_arg_start_assignment_expression = NULL;
    pillar2c_pcall_arg_start_assignment_expression =
            expr_gen(assignment_expression,unary_expression,
               new unary_expression_unary_operator_cast_expression (
                new unary_operator_and(),
                new cast_expression_unary_expression(
                 new unary_expression_postfix_expression(
                  new postfix_expression_primary_expression(
                   new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))))));

    argument_expression_list *pillar2c_pcall_arg_start =
        new argument_expression_list_argument_expression_list_assignment_expression(pillar2c_pcall_func_arg,pillar2c_pcall_arg_start_assignment_expression);

    assignment_expression *pillar2c_pcall_arg_size =
      expr_gen(assignment_expression,primary_expression,new primary_expression_constant("3"));

    assignment_expression * affinity_expression =
      expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));

    assignment_expression *stub_call = NULL;
    stub_call =
      expr_gen(assignment_expression,postfix_expression,
               new postfix_expression_call_expression(
                new call_expression_postfix_expression_paren_argument_expression_list(
                 // Postfix arg to call_expression.
                 new postfix_expression_primary_expression(
                  new primary_expression_identifier(stub_symbol)),
                 // Argument expression list arg to call_expression.
                 new argument_expression_list_argument_expression_list_assignment_expression(
                  new argument_expression_list_argument_expression_list_assignment_expression(
                   new argument_expression_list_argument_expression_list_assignment_expression(
                    pillar2c_pcall_arg_start,
                    // The third arg to the stub.
                    pillar2c_pcall_arg_size),
                   // The last arg to the stub.
                   affinity_expression),
                   expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"))))));

    expression *main_parent_list = NULL;

    assignment_expression * function_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "func")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression,postfix_expression,cem->claim_function()));

    // Create a basic expression for the function.
    main_parent_list = new expression_assignment_expression(function_expr_list);

    std::stringstream arg_prefix;
    arg_prefix << "prt_arguments.";
    if(g_prt_args_in_pseudo) {
        arg_prefix << "prt_args_" << m_ce->get_unique() << ".";
    }
    arg_prefix << "prt_pcall_args_";

    callsite_prt_pcall_args_buf.str("");
    callsite_prt_pcall_args_buf.clear();
    callsite_prt_pcall_args_buf << arg_prefix.str() << m_ce->get_unique();

    assignment_expression * arg_size_expr_list   = NULL;
    assignment_expression * arg_start_alloc_list = NULL;
    assignment_expression * arg_start_copy_list  = NULL;
    assignment_expression * arg_start_expr_list  = NULL;

    if(callee_num_args) {
        postfix_expression *pcall_args_expr = NULL;
        if(g_prt_args_in_pseudo) {
            pcall_args_expr = gen_pseudo_pe(callsite_prt_pcall_args_buf.str(),this);
        } else {
            pcall_args_expr =
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(callsite_prt_pcall_args_buf.str())));
        }

        arg_size_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argSize")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression,multiplicative_expression,
                       new multiplicative_expression_multiplicative_expression_div_cast_expression(
                        new multiplicative_expression_cast_expression(
                         new cast_expression_unary_expression(
                          new unary_expression_sizeof_unary_expression(
                           new unary_expression_postfix_expression(
                            new postfix_expression_primary_expression(
                             new primary_expression_expression(
                              new expression_assignment_expression(
                               expr_gen(assignment_expression,postfix_expression,pcall_args_expr)))))))),
                        new cast_expression_unary_expression(
                         new unary_expression_postfix_expression(
                          new postfix_expression_primary_expression(
                           new primary_expression_constant(register_size_const)))))));

        if(g_prt_args_in_pseudo) {
            pcall_args_expr = gen_pseudo_pe(callsite_prt_pcall_args_buf.str(),this);
        } else {
            pcall_args_expr =
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(callsite_prt_pcall_args_buf.str())));
        }

        arg_start_alloc_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argStart")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression ,postfix_expression,
               new postfix_expression_call_expression(
                 new call_expression_postfix_expression_paren_argument_expression_list(
                   new postfix_expression_primary_expression(
                     new primary_expression_identifier(g_scope_stack.find_symbol("malloc_pillar2c_register"))),
                   new argument_expression_list_assignment_expression(
                     expr_gen(assignment_expression,postfix_expression,
                     new postfix_expression_postfix_expression_dot_identifier(
                       new postfix_expression_primary_expression(
                         new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
                           "argSize")))))));

        arg_start_copy_list =
           expr_gen(assignment_expression,postfix_expression,
             new postfix_expression_call_expression(
               new call_expression_postfix_expression_paren_argument_expression_list(
                 new postfix_expression_primary_expression(
                   new primary_expression_identifier(g_scope_stack.find_symbol("memcpy_pillar2c_register"))
                 ),
                 new argument_expression_list_argument_expression_list_assignment_expression(
                   new argument_expression_list_argument_expression_list_assignment_expression(
                     new argument_expression_list_assignment_expression(
                       expr_gen(assignment_expression,postfix_expression,
                         new postfix_expression_postfix_expression_dot_identifier(
                           new postfix_expression_primary_expression(
                             new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
                               "argStart"))  // arg 1
                     ),
                     expr_gen(assignment_expression,unary_expression,
                         new unary_expression_unary_operator_cast_expression (
                         new unary_operator_and(),
                          new cast_expression_unary_expression(
                           new unary_expression_postfix_expression(pcall_args_expr)))) // arg 2
                   ),
                   expr_gen(assignment_expression,postfix_expression,
                     new postfix_expression_postfix_expression_dot_identifier(
                       new postfix_expression_primary_expression(
                         new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
                           "argSize")) // arg 3
                 )
               )
             )
          );
    } else {
        arg_size_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argSize")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0")));

        arg_start_expr_list =
           new assignment_expression_unary_expression_assignment_operator_assignment_expression(
            new unary_expression_postfix_expression(
             new postfix_expression_postfix_expression_dot_identifier(
              new postfix_expression_primary_expression(
               new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str()))),
              "argStart")),
            new assignment_operator_equal(),
            expr_gen(assignment_expression,unary_expression,
                           new unary_expression_postfix_expression(
                            new postfix_expression_primary_expression(
                             new primary_expression_constant("0")))));
    }
    main_parent_list = new expression_expression_assignment_expression(main_parent_list,arg_size_expr_list);

    // Add additional args and create an expression assignment AST node.
    for(index=0; index < cem->m_args.size(); ++index) {
        if(index < cem->m_func_metadata.m_params.size()) {
            auto_ptr<expression_type> apet(cem->m_func_metadata.m_params[index]->get_type());
            main_parent_list = new expression_expression_assignment_expression(
                             main_parent_list,
                             create_expression_for_arg(apet.get(),cem->m_args[index],index,m_ce,"arg",arg_prefix.str().c_str(),false));
        } else {
            auto_ptr<expression_type> apet(cem->m_args[index]->get_type());
            main_parent_list = new expression_expression_assignment_expression(
                             main_parent_list,
                             create_expression_for_arg(apet.get(),cem->m_args[index],index,m_ce,"arg",arg_prefix.str().c_str(),false));
        }
    }

    if(arg_start_expr_list) {
        main_parent_list = new expression_expression_assignment_expression(main_parent_list,arg_start_expr_list);
    } else {
        if(!arg_start_alloc_list || !arg_start_copy_list) {
            aeprintf("Error while translating pcall.");
        }
        main_parent_list = new expression_expression_assignment_expression(main_parent_list,arg_start_alloc_list);
        main_parent_list = new expression_expression_assignment_expression(main_parent_list,arg_start_copy_list);
    }

    // Add the stub call itself.
    main_parent_list = new expression_expression_assignment_expression(main_parent_list,stub_call);

    statement_expression_statement *new_node =
        new statement_expression_statement(
          new expression_statement_expression(
            new expression_assignment_expression(
              expr_gen(assignment_expression,primary_expression,new primary_expression_expression(main_parent_list)))));

    fd->prepend_bil(gen_pillar2c_pcall_target_args_decl(m_ce));

    if(g_pillar2c_debug_level > 2) {
        printf("// CALL to be inserted.\n#if 0\n");
        new_node->print();
        printf("\n#endif\n// Insert CALL\n");
    }
    m_parent->replace(this,new_node);

    delete this;

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        cur_bb->add_item(new_node);
    }

    return tr;
}

bool declaration_declaration_specifiers::declares_name(const char *name) {
    return m_ds->declares_name(name);
}

bool declaration_specifiers_type_specifier::declares_name(const char *name) {
    return m_ts->declares_name(name);
}

bool type_specifier_struct_or_union_specifier::declares_name(const char *name) {
    return m_sous->declares_name(name);
}

void primary_expression_identifier::get_used_refs(std::set<unsigned> &used_ref_indices) {
    const char *rfn = m_ii->get_qualified_ref_field_name();
    if(rfn) {
        if(m_ii->get_ref_param_in_place()) {
            return;
        }
        if(m_ii->has_ref_index()) {
            used_ref_indices.insert(m_ii->get_ref_index());
        }
    }
}

void primary_expression_identifier::replace_refs_with_pseudo_expression(void) {
    const char *rfn = m_ii->get_qualified_ref_field_name();
    if(rfn) {
        if(m_ii->has_ref_index()) {
            AST_node *node_to_replace = dynamic_cast<postfix_expression*>(m_parent);
            if(!node_to_replace) {
                aeprintf("primary_expression_identifier::replace_refs_with_pseudo_expression parent not postfix_expression.\n");
            }
            AST_node *new_node =
                new postfix_expression_postfix_expression_dot_identifier(
                  new postfix_expression_postfix_expression_dot_identifier(
                    gen_pseudo_pe("prt_refs_and_array",this),
                    "prt_refs"),
                  rfn);
            if(m_ii->is_volatile()) {
				type_name *the_cast;
				the_cast = new type_name_specifier_qualifier_list_abstract_declarator(
								new specifier_qualifier_list_type_specifier(new type_specifier_VOID()),
								new abstract_declarator_pointer(new pointer_star()));

				unary_expression_unary_operator_cast_expression *ueuoce = search_up_for_type<unary_expression_unary_operator_cast_expression>(node_to_replace);
				if (ueuoce && dynamic_cast<unary_operator_and*>(ueuoce->get_uo()) != NULL) {
					node_to_replace = ueuoce;
                    new_node = new unary_expression_postfix_expression(
						        new postfix_expression_primary_expression(
                                 new primary_expression_expression(
                                  new expression_assignment_expression(
                                   expr_gen(assignment_expression,cast_expression,
                                    new cast_expression_type_name_cast_expression(
                                     the_cast,
                                     expr_gen(cast_expression,postfix_expression,
									  new postfix_expression_primary_expression(
                                       new primary_expression_expression(
                                        new expression_assignment_expression(
                                         expr_gen(assignment_expression,unary_expression,
										  new unary_expression_unary_operator_cast_expression(
										   new unary_operator_and(),
										   expr_gen(cast_expression,postfix_expression,new_node)))))))))))));
				} else {
    				assignment_expression_unary_expression_assignment_operator_assignment_expression *assign_node = search_up_for_type<assignment_expression_unary_expression_assignment_operator_assignment_expression>(node_to_replace);
#ifndef USE_IS_LVALUE
		            LRB_VALUE lrb_res = node_to_replace->get_parent()->get_lrb_value(node_to_replace,NULL);
					bool res_lvalue;
					if(lrb_res == LRB_LVALUE || lrb_res == LRB_LRVALUE) {
						res_lvalue = true;
					} else {
						res_lvalue = false;
					}
#else
	                bool res_lvalue = node_to_replace->get_parent()->is_lvalue(node_to_replace,NULL);
#endif
					if (assign_node &&
						assign_node->is_part_of_lhs(node_to_replace) &&
						res_lvalue) {
						assign_node->add_volatile_void_rhs_cast();
					} else {
                        new_node = new postfix_expression_primary_expression(
                                    new primary_expression_expression(
                                     new expression_assignment_expression(
                                      expr_gen(assignment_expression,cast_expression,
                                       new cast_expression_type_name_cast_expression(
                                        the_cast,
                                        expr_gen(cast_expression,postfix_expression,new_node))))));
					}
				}
            }
            AST_node *parent = node_to_replace->get_parent();
            parent->replace(node_to_replace,new_node);
            delete node_to_replace;
            throw done(parent);
        }
    }
}

void primary_expression_identifier::cast_off_volatile(void) {
    std::string name = m_ii->get_string();
#ifdef TODD_DEBUG
	if(name == "pLsrAllocFrontier") {
		printf("Got here1\n");
	}
#endif
#if 0
    if(name == "v536147_baseZCGHCzziIOzziHandlezziInternalszietaX3V_tslam_code" ||
       name == "v540900_ws3x9_tslam_code" ||
       name == "v545604_eta2X3t_tslam_code" ||
       name == "v545305_eta1X2L_tslam_code") {
        printf("break\n");
    }
#endif
//  if(m_ii->volatile_added() && get_parent()->get_lrb_value(this,NULL) != LRB_LVALUE) {
    if(m_ii->volatile_added()) {
#if 0
        if(m_ii->is_function()) {
            printf("cast_off_volatile for function %s\n",find_enclosing_function()->get_symbol()->get_name());
        }
#endif
#ifdef TODD_DEBUG
		if(name == "pLsrAllocFrontier") {
			printf("Got here2\n");
		}
#endif
        postfix_expression *parent = dynamic_cast<postfix_expression*>(m_parent);
        if(!parent) {
            aeprintf("primary_expression_identifier::cast_off_volatile parent not postfix_expression.\n");
        }
//      parent->print();
//      printf("\n");

        //aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        if(m_ii->is_function()) {
            if(is_call_context()) {
                return;
            } else {
//              printf("cast_off_volatile for function %s in function %s\n",m_ii->get_name(),find_enclosing_function()->get_symbol()->get_name());
                function_definition *fd = m_ii->get_func_definition();

//              auto_ptr<expression_type> apet(fd->get_return_type());
                auto_ptr<expression_type> apet(fd->get_type());
#if 0
                apet->m_sql->print();
                printf("\n");
                if(apet->m_ad) {
                    apet->m_ad->print();
                    printf("\n");
                }
#endif
                apet->remove_volatile();
#if 0
                apet->m_sql->print();
                printf("\n");
                if(apet->m_ad) {
                    apet->m_ad->print();
                    printf("\n");
                }
#endif

                primary_expression *new_node =
                    new primary_expression_expression(
                     new expression_assignment_expression(
                      expr_gen(assignment_expression,cast_expression,
                       new cast_expression_type_name_cast_expression(
                        apet->gen_type_name(NULL),
                        expr_gen(cast_expression,primary_expression,this)))));

                parent->replace(this,new_node);

#if 0
                parent->print();
                printf("\n");
#endif

                return;
            }
        }

        auto_ptr<expression_type> apet(m_ii->get_return_type());

        if(apet->is_pointer()) {
    		assignment_expression_unary_expression_assignment_operator_assignment_expression *assign_node = search_up_for_type<assignment_expression_unary_expression_assignment_operator_assignment_expression>(this);
#ifndef USE_IS_LVALUE
		    LRB_VALUE lrb_res = get_parent()->get_lrb_value(this, NULL);
			bool res_lvalue;
			if(lrb_res == LRB_LVALUE || lrb_res == LRB_LRVALUE) {
				res_lvalue = true;
			} else {
				res_lvalue = false;
			}
#else
	        bool res_lvalue = get_parent()->is_lvalue(this, NULL);
#endif
			if (assign_node &&
				assign_node->is_part_of_lhs(this) &&
				res_lvalue) {
				assign_node->add_rhs_cast(apet->gen_type_name(NULL));
			} else {
				apet->remove_volatile();

				primary_expression *new_node =
					new primary_expression_expression(
					 new expression_assignment_expression(
					  expr_gen(assignment_expression,cast_expression,
					   new cast_expression_type_name_cast_expression(
						apet->gen_type_name(NULL),
						expr_gen(cast_expression,primary_expression,this)))));

				parent->replace(this,new_node);
			}

    //      parent->print();
    //      printf("\n");

    //      throw done(this);
        } else {
            apet->remove_volatile();
            apet->add_pointer_star();

            primary_expression *new_node =
                new primary_expression_expression(
                 new expression_assignment_expression(
                  expr_gen(assignment_expression,unary_expression,
                   new unary_expression_unary_operator_cast_expression(
                    new unary_operator_star(),
                     new cast_expression_type_name_cast_expression(
                      apet->gen_type_name(NULL),
                      expr_gen(cast_expression,primary_expression,
                       new primary_expression_expression(
                        new expression_assignment_expression(
                         expr_gen(assignment_expression,unary_expression,
                          new unary_expression_unary_operator_cast_expression(
                           new unary_operator_and(),
                           expr_gen(cast_expression,primary_expression,this)))))))))));

            parent->replace(this,new_node);
        }
    }
}

void primary_expression_identifier::modify_ref(unsigned ref_id, ii_ptr hoist_ii) {
    if(m_ii->get_ref_index() == ref_id) {
        m_ii = hoist_ii;
    }
}

TranslateResult iteration_statement_while::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);

    m_loop_body             = new basic_block(NULL);
    m_conditional           = new basic_block(NULL);
    m_break_target          = new basic_block(NULL);

    add_flow_graph_edge(cur_bb, m_conditional, EDGE_FALLTHROUGH);
    fd->set_cur_basic_block(m_conditional);

    TRANSLATE(m_e,tr1);
//    m_conditional->add_item(m_e);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_conditional) {
        add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
        add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
    } else {
        aeprintf("Basic block shouldn't change in while conditional.\n");
    }

    fd->set_cur_basic_block(m_loop_body);

    TRANSLATE(m_s,tr2);
    if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
    }

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_conditional, EDGE_LOOP);
    }

    fd->set_cur_basic_block(m_break_target);

    return TranslateResult();
}

TranslateResult iteration_statement_do::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    bool expression_constant_zero = m_e->is_constant_zero();
    if(expression_constant_zero && !m_s->contains_loop_specific()) {
        AST_node *parent = get_parent();
        AST_node *grandparent = parent->get_parent();
        grandparent->replace(parent,m_s);
        TRANSLATE(m_s,tr1);
        m_s = NULL;
        delete parent;
        throw done(grandparent);
    } else {
        basic_block *cur_bb     = fd->get_cur_basic_block();
        assert(cur_bb);

        m_loop_body             = new basic_block(NULL);
        m_conditional           = new basic_block(NULL);
        m_break_target          = new basic_block(NULL);

        add_flow_graph_edge(cur_bb, m_loop_body, EDGE_LOOP);

        fd->set_cur_basic_block(m_loop_body);

        TRANSLATE(m_s,tr1);
        if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
            m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
        }

        cur_bb = fd->get_cur_basic_block();
        if(cur_bb) {
            add_flow_graph_edge(cur_bb, m_conditional, EDGE_FALLTHROUGH);
        }

        fd->set_cur_basic_block(m_conditional);

        TRANSLATE(m_e,tr2);
//        m_conditional->add_item(m_e);

        cur_bb = fd->get_cur_basic_block();
        if(cur_bb == m_conditional) {
            add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
            if(!expression_constant_zero) {
                add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
            }
        } else {
            aeprintf("Basic block shouldn't change in while conditional.\n");
        }

        fd->set_cur_basic_block(m_break_target);
    }

    return TranslateResult();
}

TranslateResult iteration_statement_for_eses::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;

    TRANSLATE(m_es1,tr1);

    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);
//    cur_bb->add_item(m_es1);

    m_loop_body             = new basic_block(NULL);
    m_conditional           = new basic_block(NULL);
    m_break_target          = new basic_block(NULL);

    add_flow_graph_edge(cur_bb, m_conditional, EDGE_FALLTHROUGH);
    fd->set_cur_basic_block(m_conditional);

    TRANSLATE(m_es2,tr2);
//    m_conditional->add_item(m_es2);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_conditional) {
        add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
        add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
    } else {
        aeprintf("Basic block shouldn't change in while conditional.\n");
    }

    fd->set_cur_basic_block(m_loop_body);

    TRANSLATE(m_s,tr3);
    if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
    }

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_conditional, EDGE_LOOP);
    }

    fd->set_cur_basic_block(m_break_target);


    return TranslateResult();
}

TranslateResult iteration_statement_for_esese::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3, tr4;

    TRANSLATE(m_es1,tr1);

    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);
//    cur_bb->add_item(m_es1);

    m_loop_body             = new basic_block(NULL);
    m_conditional           = new basic_block(NULL);
    m_break_target          = new basic_block(NULL);
    m_post_loop             = new basic_block(NULL);

    add_flow_graph_edge(cur_bb, m_conditional, EDGE_FALLTHROUGH);

    fd->set_cur_basic_block(m_post_loop);
    TRANSLATE(m_e,tr2);
//    m_post_loop->add_item(m_e);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_post_loop) {
        add_flow_graph_edge(m_post_loop,m_conditional, EDGE_FALLTHROUGH);
    } else {
        aeprintf("Basic block shouldn't change in post loop.\n");
    }

    fd->set_cur_basic_block(m_conditional);
    TRANSLATE(m_es2,tr3);
//    m_conditional->add_item(m_es2);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_conditional) {
        add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
        add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
    } else {
        aeprintf("Basic block shouldn't change in while conditional.\n");
    }

    fd->set_cur_basic_block(m_loop_body);

    TRANSLATE(m_s,tr4);
    if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
    }

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_post_loop, EDGE_LOOP);
    }

    fd->set_cur_basic_block(m_break_target);


    return TranslateResult();
}

TranslateResult iteration_statement_for_des::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;

    TRANSLATE(m_d,tr1);

    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);
//    cur_bb->add_item(m_d);

    m_loop_body             = new basic_block(NULL);
    m_conditional           = new basic_block(NULL);
    m_break_target          = new basic_block(NULL);

    add_flow_graph_edge(cur_bb, m_conditional, EDGE_FALLTHROUGH);
    fd->set_cur_basic_block(m_conditional);

    TRANSLATE(m_es,tr2);
//    m_conditional->add_item(m_es);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_conditional) {
        add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
        add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
    } else {
        aeprintf("Basic block shouldn't change in while conditional.\n");
    }

    fd->set_cur_basic_block(m_loop_body);

    TRANSLATE(m_s,tr3);
    if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
    }

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_conditional, EDGE_LOOP);
    }

    fd->set_cur_basic_block(m_break_target);

    return TranslateResult();
}

TranslateResult iteration_statement_for_dese::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3, tr4;

    TRANSLATE(m_d,tr1);

    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);
//    cur_bb->add_item(m_d);

    m_loop_body             = new basic_block(NULL);
    m_conditional           = new basic_block(NULL);
    m_break_target          = new basic_block(NULL);
    m_post_loop             = new basic_block(NULL);

    add_flow_graph_edge(cur_bb,m_conditional, EDGE_FALLTHROUGH);

    fd->set_cur_basic_block(m_post_loop);
    TRANSLATE(m_e,tr2);
//    m_post_loop->add_item(m_e);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_post_loop) {
        add_flow_graph_edge(m_post_loop,m_conditional, EDGE_FALLTHROUGH);
    } else {
        aeprintf("Basic block shouldn't change in post loop.\n");
    }

    fd->set_cur_basic_block(m_conditional);
    TRANSLATE(m_es,tr3);
//    m_conditional->add_item(m_es);

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb == m_conditional) {
        add_flow_graph_edge(m_conditional, m_break_target, EDGE_CONDITIONAL);
        add_flow_graph_edge(m_conditional, m_loop_body, EDGE_CONDITIONAL);
    } else {
        aeprintf("Basic block shouldn't change in while conditional.\n");
    }

    fd->set_cur_basic_block(m_loop_body);

    TRANSLATE(m_s,tr4);
    if(g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        m_s = m_s->append(new block_item_list_block_item(gen_yield_check()));
    }

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_post_loop, EDGE_LOOP);
    }

    fd->set_cur_basic_block(m_break_target);

    return TranslateResult();
}

bool id_info::is_ultimate_prt_ref(void) {
    if(m_ref_field_name != "") return true;
    if(type_or_lsi.m_type) {
        return type_or_lsi.m_type->is_ultimate_prt_ref();
    } else {
        return false;
    }
}

type_specifier * id_info::get_base_type(void) {
    if(type_or_lsi.m_type  && !m_function_var) {
        return type_or_lsi.m_type->get_base_type();
    } else {
        return NULL;
    }
}

type_specifier_PRT_REF * id_info::get_ultimate_prt_ref(void) {
    if(type_or_lsi.m_type) {
        return type_or_lsi.m_type->get_ultimate_prt_ref();
    } else {
        return NULL;
    }
}

unsigned id_info::get_minimum_size(void) {
    if(m_typedef) {
        if(type_or_lsi.m_type) {
            declaration *thised = search_up_for_type<declaration>(type_or_lsi.m_type);
            if(thised) {
                auto_ptr<expression_type> apet(thised->get_type());
                return apet->get_minimum_size();
            } else {
                aeprintf("Could not find the declaration for a typedef in get_param_size size for type %s.\n",get_name());
            }
        } else {
            aeprintf("Could not get minimum size for type %s.\n",get_name());
        }
    } else {
        aeprintf("Could not get minimum size for type %s.\n",get_name());
    }
}

unsigned id_info::get_param_size(void) {
    if(m_typedef) {
        if(type_or_lsi.m_type) {
            declaration *thised = search_up_for_type<declaration>(type_or_lsi.m_type);
            if(thised) {
                auto_ptr<expression_type> apet(thised->get_type());
                return apet->get_param_size();
            } else {
                aeprintf("Could not find the declaration for a typedef in get_param_size size for type %s.\n",get_name());
            }
        } else {
            aeprintf("Could not get minimum size for type %s.\n",get_name());
        }
    } else {
        aeprintf("Could not get minimum size for type %s.\n",get_name());
    }
}

TranslateResult labeled_statement_identifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    m_ii = g_scope_stack.find_symbol(m_id);
    assert(m_ii);

    m_ii->set_labeled_statement(this);

    basic_block *new_bb = m_ii->get_block_for_label();
    if(!new_bb) {
        new_bb = new basic_block(NULL);
        m_ii->set_block_for_label(new_bb);
    } else {
        unsigned i;
        for(i = 0; i < new_bb->m_can_follow.size(); ++i) {
            if(new_bb->m_can_follow[i]->get_edge_type(new_bb) == EDGE_GOTO) {
                m_reference_count++;
            }
        }

//        new_bb->set_first_item(this);
//        new_bb->add_item(this);
    }
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, new_bb, EDGE_FALLTHROUGH);
    }
    fd->set_cur_basic_block(new_bb);

    TRANSLATE(m_s,tr);

    return tr;
}

TranslateResult labeled_statement_continuation::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    basic_block *new_bb = m_ii->get_block_for_continuation();
    if(!new_bb) {
        new_bb = new basic_block(NULL);
        m_ii->set_block_for_continuation(new_bb);
    } else {
//        new_bb->set_first_item(this);
//        new_bb->add_item(this);
    }
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
//        aeprintf("Cannot fall through into a continuation in function %s.\n",fd->get_symbol()->get_name());
    }
    fd->set_cur_basic_block(new_bb);

    continuation_point *cp = new continuation_point(new_bb);
    fd->m_continuations.push_back(cp);
    new_bb->m_live_refs_here.push_back(cp);

    TRANSLATE(m_s,tr);

    if(!have_declared_continuation_target) {
        have_declared_continuation_target = true;
        std::stringstream ct_decl;
        if(g_use_try_except) {
//            ct_decl << "void _pillar2c_RaiseException(int *x) { RaiseException(1,0,1,&x); }\n\n";
            ct_decl << "void _pillar2c_RaiseException_continuation_target(void);\n";
        } else {
            ct_decl << "void _pillar2c_continuation_target(void);\n";
        }


        external_declaration *continuation_target = new external_declaration_emit_text(ct_decl.str());
        fd->insert_before_top_level(continuation_target);
    }

    std::string cont_decl_name  = m_ii->get_continuation_type_string();
    std::string local_cont_name = m_ii->get_continuation_var_string();
    std::string cont_label_name = m_ii->get_continuation_label_string();

    check_vector<type_specifier*> cont_vec;
    m_ct->get_types(cont_vec);
    check_vector<ii_ptr > flat_id;
    unsigned flat_index;
    if(m_il) {
        m_il->flatten(flat_id);
    }
    if(!g_old_continuations && cont_vec.size() != flat_id.size()) {
        aeprintf("Continuation definition arg size mismatch.\n");
    }

    std::stringstream cont_decl_str;
    cont_decl_str << "typedef struct {\nPrtCodeAddress eip;\nPrtVseHandle vsh;\n";
    if(!g_use_try_except) {
        cont_decl_str << "jmp_buf cont_jump_buf;\n";
    }

    for(flat_index = 0; flat_index < flat_id.size(); ++flat_index) {
        type_specifier *ts = flat_id[flat_index]->get_type();
        assert(ts);
        cont_decl_str << *ts << " " << flat_id[flat_index]->get_string() << ";\n";
    }
    cont_decl_str << "} " << cont_decl_name << ";\n";

    external_declaration *cont_decl = new external_declaration_emit_text(cont_decl_str.str());
    fd->insert_before_top_level(cont_decl);

    std::stringstream cont_init;
    // fill in the eip part of the continuation here
    if(g_use_try_except) {
        cont_init << local_cont_name << ".eip = (PrtCodeAddress)_pillar2c_RaiseException_continuation_target;\n";
    } else {
        cont_init << local_cont_name << ".eip = (PrtCodeAddress)_pillar2c_continuation_target;\n";
    }
    // fill in the vsh part of the continuation here
    cont_init << local_cont_name << ".vsh = prtGetVsh();\n";
    if(!g_use_try_except) {
        cont_init << "if(_setjmp(" << local_cont_name << ".cont_jump_buf" << ")) {\ngoto " << cont_label_name << ";\n}\n";
    }

    fd->prepend_bil(new block_item_list_block_item(new block_item_text(cont_init.str())));

    block_item_list *local_cont_decl =
          new block_item_list_block_item(
            new block_item_declaration(
              new declaration_declaration_specifiers_init_declarator_list(
                new declaration_specifiers_type_specifier(
                  new type_specifier_TYPE_NAME(
                    g_scope_stack.find_or_add(cont_decl_name))),
                new init_declarator_list_init_declarator(
                  new init_declarator_declarator(
                    new declarator_direct_declarator(
                      new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(local_cont_name)))))),0));

    fd->prepend_bil(local_cont_decl);

    labeled_statement_identifier *lsi;
    if(flat_id.size()) {
        block_item_list *new_bil = NULL;
        for(flat_index = 0; flat_index < flat_id.size(); ++flat_index) {
            block_item_statement *new_bis =
                  new block_item_statement(
                    new statement_expression_statement(
                      new expression_statement_expression(
                        new expression_assignment_expression(
                          new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                            expr_gen(unary_expression,primary_expression,
                              new primary_expression_identifier(flat_id[flat_index])),
                            new assignment_operator_equal(),
                            expr_gen(assignment_expression, postfix_expression,
                              new postfix_expression_postfix_expression_dot_identifier(
                                new postfix_expression_primary_expression(
                                  new primary_expression_identifier(g_scope_stack.find_or_add(local_cont_name))),
                                flat_id[flat_index]->get_name())))))),0);

            if(!new_bil) {
                new_bil = new block_item_list_block_item(new_bis);
            } else {
                new_bil = new block_item_list_block_item_list_block_item(new_bil,new_bis);
            }
        }

        new_bil = new block_item_list_block_item_list_block_item(new_bil,new block_item_statement(m_s,0));
        compound_statement_block_item_list *new_cs = new compound_statement_block_item_list(new_bil);
        lsi = new labeled_statement_identifier(cont_label_name,new statement_compound_statement(new_cs),true);
    } else {
        lsi = new labeled_statement_identifier(cont_label_name,m_s);
    }

    lsi->add_reference();

    m_parent->replace(this,lsi);

    m_s  = NULL;
    delete this;

//    aeprintf("Implementation of labeled_statement_continuation::translate_pillar needs to be completed.\n");
    return tr;
}

TranslateResult selection_statement_if::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    TRANSLATE(m_e,tr1);

    basic_block *new_bb_if      = new basic_block(m_s);
    basic_block *new_bb_post_if = new basic_block(NULL);

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
//        cur_bb->add_item(m_e);
    }

    bool nz_const = false;
    bool z_const  = false;

    primary_expression_constant_int *pe_const = (primary_expression_constant_int*)m_e->is_mainline(typeid(primary_expression_constant_int));
    if(pe_const) {
        nz_const = pe_const->is_constant_nonzero();
        z_const  = pe_const->is_constant_zero();
    }

    if(! z_const) {
        add_flow_graph_edge(cur_bb, new_bb_if, EDGE_CONDITIONAL);
    }

    if(! nz_const) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_CONDITIONAL);
    }

    fd->set_cur_basic_block(new_bb_if);
    TRANSLATE(m_s,tr2);
    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    if(new_bb_post_if->m_can_follow.size()) {
        fd->set_cur_basic_block(new_bb_post_if);
    } else {
        delete new_bb_post_if;
    }

    return TranslateResult();
}

TranslateResult selection_statement_if_else::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;

    TRANSLATE(m_e,tr1);

    basic_block *new_bb_if      = new basic_block(m_s1);
    basic_block *new_bb_else    = new basic_block(m_s2);
    basic_block *new_bb_post_if = new basic_block(NULL);

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
//        cur_bb->add_item(m_e);
    }

    bool nz_const = false;
    bool z_const  = false;

    primary_expression_constant_int *pe_const = (primary_expression_constant_int*)m_e->is_mainline(typeid(primary_expression_constant_int));
    if(pe_const) {
        nz_const = pe_const->is_constant_nonzero();
        z_const  = pe_const->is_constant_zero();
    }

    if(! z_const) {
        add_flow_graph_edge(cur_bb, new_bb_if, EDGE_CONDITIONAL);
    }

    if(! nz_const) {
        add_flow_graph_edge(cur_bb, new_bb_else, EDGE_CONDITIONAL);
    }

    fd->set_cur_basic_block(new_bb_if);

    TRANSLATE(m_s1,tr2);

    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    fd->set_cur_basic_block(new_bb_else);

    TRANSLATE(m_s2,tr3);

    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    if(new_bb_post_if->m_can_follow.size()) {
        fd->set_cur_basic_block(new_bb_post_if);
    } else {
        delete new_bb_post_if;
    }

    return TranslateResult();
}

TranslateResult selection_statement_if_builtin::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    TRANSLATE(m_e,tr1);

    basic_block *new_bb_if      = new basic_block(m_s);
    basic_block *new_bb_post_if = new basic_block(NULL);

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
//        cur_bb->add_item(m_e);
    }

    bool nz_const = false;
    bool z_const  = false;

    primary_expression_constant_int *pe_const = (primary_expression_constant_int*)m_e->is_mainline(typeid(primary_expression_constant_int));
    if(pe_const) {
        nz_const = pe_const->is_constant_nonzero();
        z_const  = pe_const->is_constant_zero();
    }

    if(! z_const) {
        add_flow_graph_edge(cur_bb, new_bb_if, EDGE_CONDITIONAL, strcmp(m_constant,"0") != 0 ? BB_FREQ_COMMON : BB_FREQ_RARE);
    }

    if(! nz_const) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    fd->set_cur_basic_block(new_bb_if);
    TRANSLATE(m_s,tr2);
    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    if(new_bb_post_if->m_can_follow.size()) {
        fd->set_cur_basic_block(new_bb_post_if);
    } else {
        delete new_bb_post_if;
    }

    return TranslateResult();
}

TranslateResult selection_statement_if_else_builtin::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2, tr3;

    TRANSLATE(m_e,tr1);

    basic_block *new_bb_if      = new basic_block(m_s1);
    basic_block *new_bb_else    = new basic_block(m_s2);
    basic_block *new_bb_post_if = new basic_block(NULL);

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
//        cur_bb->add_item(m_e);
    }

    bool nz_const = false;
    bool z_const  = false;

    primary_expression_constant_int *pe_const = (primary_expression_constant_int*)m_e->is_mainline(typeid(primary_expression_constant_int));
    if(pe_const) {
        nz_const = pe_const->is_constant_nonzero();
        z_const  = pe_const->is_constant_zero();
    }

    if(! z_const) {
        add_flow_graph_edge(cur_bb, new_bb_if, EDGE_CONDITIONAL, strcmp(m_constant,"0") != 0 ? BB_FREQ_COMMON : BB_FREQ_RARE);
    }

    if(! nz_const) {
        add_flow_graph_edge(cur_bb, new_bb_else, EDGE_CONDITIONAL, strcmp(m_constant,"0") != 0 ? BB_FREQ_RARE : BB_FREQ_COMMON);
    }

    fd->set_cur_basic_block(new_bb_if);

    TRANSLATE(m_s1,tr2);

    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    fd->set_cur_basic_block(new_bb_else);

    TRANSLATE(m_s2,tr3);

    if((cur_bb = fd->get_cur_basic_block())) {
        add_flow_graph_edge(cur_bb, new_bb_post_if, EDGE_FALLTHROUGH);
    }

    if(new_bb_post_if->m_can_follow.size()) {
        fd->set_cur_basic_block(new_bb_post_if);
    } else {
        delete new_bb_post_if;
    }

    return TranslateResult();
}

TranslateResult selection_statement_switch::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    TRANSLATE(m_e,tr1);

    m_break_target = new basic_block(NULL);
    m_switch_block = fd->get_cur_basic_block();

    fd->set_cur_basic_block(NULL);

    m_num_cases = m_s->count_cases();
    if(!m_has_default) {
        ++m_num_cases;
    }

    TRANSLATE(m_s,tr2);

    basic_block *temp = NULL;
    if((temp = fd->get_cur_basic_block())) {
        add_flow_graph_edge(temp, m_break_target, EDGE_FALLTHROUGH);
    }

    if(!m_has_default) {
        add_flow_graph_edge(m_switch_block, m_break_target, EDGE_CONDITIONAL);
    }

    fd->set_cur_basic_block(m_break_target);

    return TranslateResult();
}

selection_statement_switch * get_enclosing_switch(AST_node *node) {
    if(!node) return NULL;

    selection_statement_switch *res;
    if((res = dynamic_cast<selection_statement_switch*>(node))) {
        return res;
    } else {
        return get_enclosing_switch(node->get_parent());
    }
}

TranslateResult labeled_statement_default::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    basic_block *new_bb = new basic_block(NULL);
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, new_bb, EDGE_FALLTHROUGH);
    }

    basic_block *cur_switch_block = get_switch_block();
    assert(cur_switch_block);
    selection_statement_switch *sss = get_enclosing_switch(this->get_parent());
    assert(sss);
    add_flow_graph_edge(cur_switch_block, new_bb, EDGE_CONDITIONAL);

    fd->set_cur_basic_block(new_bb);

    found_default();

    TRANSLATE(m_s,tr);

    return tr;
}

TranslateResult labeled_statement_case::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;

    TRANSLATE(m_ce,tr1);

    basic_block *new_bb     = new basic_block(NULL);
    basic_block *cur_bb     = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, new_bb, EDGE_FALLTHROUGH);
    }

    basic_block *cur_switch_block = get_switch_block();
    assert(cur_switch_block);
    selection_statement_switch *sss = get_enclosing_switch(this->get_parent());
    assert(sss);
    add_flow_graph_edge(cur_switch_block, new_bb, EDGE_CONDITIONAL);

    fd->set_cur_basic_block(new_bb);

    TRANSLATE(m_s,tr2);

    return tr2;
}

TranslateResult jump_statement_break::translate_pillar(function_definition *fd) {
    basic_block *cur_bb     = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();
//    cur_bb->add_item(this);

    basic_block *break_target = get_break_target();
    assert(break_target);

    add_flow_graph_edge(cur_bb, break_target, EDGE_BREAK);

    fd->set_cur_basic_block(NULL);

    return TranslateResult();
}

TranslateResult jump_statement_return::translate_pillar(function_definition *fd) {
    basic_block *cur_bb     = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();
//    cur_bb->add_item(this);

    basic_block *ret_bb     = get_return_target();
    assert(ret_bb);

    add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

    fd->set_cur_basic_block(NULL);

    return TranslateResult();
}

TranslateResult jump_statement_return_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    TRANSLATE(m_e,tr);

    basic_block *cur_bb     = fd->get_cur_basic_block();
    if(!cur_bb) return tr;
//    cur_bb->add_item(this);

    basic_block *ret_bb     = get_return_target();
    assert(ret_bb);

    add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

    fd->set_cur_basic_block(NULL);

    return tr;
}

TranslateResult jump_statement_return_mre::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_e,tr);

    return tr;
}

#ifdef COMMON_ITER
void iteration_statement::translate_pillar(function_definition *fd) {
    basic_block *cur_bb     = fd->get_cur_basic_block();
    assert(cur_bb);

    m_continue_target       = new basic_block;
    m_break_target          = new basic_block;

    add_flow_graph_edge(cur_bb, m_continue_target);

    fd->set_cur_basic_block(m_continue_target);

    translate_pillar_iteration_statement();

    cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        add_flow_graph_edge(cur_bb, m_break_target);
        add_flow_graph_edge(cur_bb, m_continue_target);
    }

    fd->set_cur_basic_block(m_break_target);
}
#endif

TranslateResult jump_statement_goto::translate_pillar(function_definition *fd) {
    if(g_prettify_code) {
        statement_jump_statement *sjs = dynamic_cast<statement_jump_statement *>(get_parent());
        if(sjs) {
            block_item_statement *bis = dynamic_cast<block_item_statement *>(sjs->get_parent());
            if(bis) {
                block_item_list_block_item_list_block_item *bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(bis->get_parent());
                if(bilbilbi) {
                    if(bilbilbi->get_block_item() == bis) {
                        block_item_list_block_item_list_block_item *bilbilbi_parent = dynamic_cast<block_item_list_block_item_list_block_item *>(bilbilbi->get_parent());
                        if(bilbilbi_parent) {
                            if(bilbilbi_parent->get_block_item_list() == bilbilbi) {
                                block_item * next_block_item = bilbilbi_parent->get_block_item();
                                if(next_block_item->is_label(m_id.c_str())) {
                                    block_item_list * deleted_nodes_bil = bilbilbi->claim_block_item_list();
                                    bilbilbi_parent->replace(bilbilbi,deleted_nodes_bil);
                                    delete bilbilbi;
                                    throw done(bilbilbi_parent);
                                    return TranslateResult();
                                }
                            } else {
                                aeprintf("Don't think we should get here.\n");
                            }
                        }
                    } else {
                        aeprintf("Don't think we should get here.\n");
                    }
                } else {
                    block_item_list_block_item *bilbi = dynamic_cast<block_item_list_block_item *>(bis->get_parent());
                    if(bilbi) {
                        block_item_list_block_item_list_block_item *bilbilbi_parent = dynamic_cast<block_item_list_block_item_list_block_item *>(bilbi->get_parent());
                        if(bilbilbi_parent) {
                            if(bilbilbi_parent->get_block_item_list() == bilbi) {
                                block_item * next_block_item = bilbilbi_parent->get_block_item();
                                if(next_block_item->is_label(m_id.c_str())) {
                                    AST_node *redo_it = bilbilbi_parent->get_parent();
                                    bilbi->remove_and_delete();
                                    throw redo(redo_it);
                                    return TranslateResult();
                                }
                            } else {
                                aeprintf("Don't think we should get here.\n");
                            }
                        }
                    }
                }
            }
        }
    }

    assert(fd);
    if(m_is_backwards && g_gen_backward_yields && cc_to_man_unman(fd->get_function_cc())==MU_MANAGED && !in_no_yield_block() && !fd->is_gc_safe()) {
        insert_before_statement(new block_item_list_block_item(gen_yield_check()));
    }

    basic_block *cur_bb = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();

//    cur_bb->add_item(this);

    ii_ptr ii = g_scope_stack.find_symbol(m_id);
    assert(ii);

    labeled_statement_identifier *lsi = ii->get_labeled_statement();
    if(lsi) {
        lsi->add_reference();
    }

    basic_block *goto_bb = ii->get_block_for_label();
    if(!goto_bb) {
        goto_bb = new basic_block(NULL);
        ii->set_block_for_label(goto_bb);
    }

    add_flow_graph_edge(cur_bb, goto_bb, EDGE_GOTO, BB_FREQ_COMMON, this);

    fd->set_cur_basic_block(NULL);

    return TranslateResult();
}

TranslateResult jump_statement_continue::translate_pillar(function_definition *fd) {
    basic_block *cur_bb     = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();
//    cur_bb->add_item(this);

    basic_block *continue_target = get_continue_target();
    assert(continue_target);

    add_flow_graph_edge(cur_bb, continue_target, EDGE_CONTINUE);

    fd->set_cur_basic_block(NULL);

    return TranslateResult();
}

bool return_value_not_used(call_expression *ce) {
    CHECK_DECL(postfix_expression_call_expression,pece,ce);
    CHECK_DECL(unary_expression_postfix_expression,uepe,pece);
    CHECK_DECL(cast_expression_unary_expression,ceue,uepe);
    CHECK_DECL(multiplicative_expression_cast_expression,mece,ceue);
    CHECK_DECL(additive_expression_multiplicative_expression,aeme,mece);
    CHECK_DECL(shift_expression_additive_expression,seae,aeme);
    CHECK_DECL(relational_expression_shift_expression,rese,seae);
    CHECK_DECL(equality_expression_relational_expression,eere,rese);
    CHECK_DECL(and_expression_equality_expression,aeee,eere);
    CHECK_DECL(exclusive_or_expression_and_expression,eoeae,aeee);
    CHECK_DECL(inclusive_or_expression_exclusive_or_expression,ioeeoe,eoeae);
    CHECK_DECL(logical_and_expression_inclusive_or_expression,laeioe,ioeeoe);
    CHECK_DECL(logical_or_expression_logical_and_expression,loelae,laeioe);
    CHECK_DECL(conditional_expression_logical_or_expression,celoe,loelae);
    CHECK_DECL(assignment_expression_conditional_expression,aece,celoe);
    CHECK_DECL(expression_assignment_expression,eae,aece);
    CHECK_DECL(expression_statement_expression,ese,eae);
    CHECK_DECL(statement_expression_statement,ses,ese);
    if(ses) return true;
    else    return false;
}

void ref_call::update_state_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
    std::pair<std::map<void*,ref_map>::iterator, bool> insert_res = call_ref_maps.insert(std::pair<void*,ref_map>(&m_ref_indices,ref_map()));
    std::pair<std::map<void*,ref_map>::iterator, bool> insert_var = call_ref_maps.insert(std::pair<void*,ref_map>(&m_var_indices,ref_map()));
    update_state_internal(insert_res.first->second,insert_var.first->second,rm,vars,disable_opts);
}

void ref_call::final_backtrace_region(std::map<void*,ref_map> &call_ref_maps, unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare,const std::map<unsigned,std::string> &hoists) {
    std::pair<std::map<void*,ref_map>::iterator, bool> insert_res = call_ref_maps.insert(std::pair<void*,ref_map>(this,ref_map(num_total_refs)));
    final_backtrace_internal(insert_res.first->second,num_total_refs,old_new_ref_map,condensed_refs,orig_id_index,func_params,active_rare,hoists,true);
}

void ref_call::mark_callsite_refs_region(std::map<void*,ref_map> &call_ref_maps, ref_map &rm, ref_map &vars, bool bb_rare) {
    std::pair<std::map<void*,ref_map>::iterator, bool> insert_res = call_ref_maps.insert(std::pair<void*,ref_map>(&m_ref_indices,ref_map()));
    assert(!insert_res.second);
    std::pair<std::map<void*,ref_map>::iterator, bool> insert_res_vars = call_ref_maps.insert(std::pair<void*,ref_map>(&m_var_indices,ref_map()));
    assert(!insert_res_vars.second);
    mark_callsite_refs_internal(insert_res.first->second,rm,insert_res_vars.first->second,vars,bb_rare);
}

void ref_call::final_backtrace(unsigned num_total_refs,
                               unsigned *old_new_ref_map,
                               unsigned &condensed_refs,
                               ii_ptr *orig_id_index,
                               const std::string &func_params,
                               const ref_map &active_rare,
                               const std::map<unsigned,std::string> &hoists, bool ref_params_in_pseudo) {
    final_backtrace_internal(m_ref_indices,num_total_refs,old_new_ref_map,condensed_refs,orig_id_index,func_params,active_rare,hoists,ref_params_in_pseudo);
}

bool spill_rares(const std::map<unsigned,unsigned> &rare_map, expression * &main_parent_list, ii_ptr *orig_id_index, const std::map<unsigned,std::string> &hoists, AST_node *node) {
    std::map<unsigned,unsigned>::const_iterator rare_iter;
    bool spilled_something = false;

    for(rare_iter  = rare_map.begin();
        rare_iter != rare_map.end();
      ++rare_iter) {
        spilled_something = true;

        std::stringstream index_buf;
        index_buf << rare_iter->second;

        main_parent_list = expression_expression_assignment_expression::new_recursive(
                          main_parent_list,
                          new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                            new unary_expression_postfix_expression(
                              new postfix_expression_postfix_expression_brace_expression(
                                gen_pseudo_pe("prt_refs_and_array.ref_array_struct.ref_array",node),
                                new expression_assignment_expression(
                                  expr_gen(assignment_expression,primary_expression,new primary_expression_constant(index_buf.str()))))),
                            new assignment_operator_equal(),
                            expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(orig_id_index[rare_iter->first]))));
    }

    std::map<unsigned,std::string>::const_iterator hoist_iter;
    for(hoist_iter  = hoists.begin();
        hoist_iter != hoists.end();
      ++hoist_iter) {
        spilled_something = true;

        main_parent_list = new expression_expression_assignment_expression(
                          main_parent_list,
                          new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                            new unary_expression_postfix_expression(
                              gen_pseudo_pe(orig_id_index[(*hoist_iter).first]->get_ref_field_name(),node)
                            ),
                            new assignment_operator_equal(),
                            expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add((*hoist_iter).second)))
                          )
                        );
    }

    return spilled_something;
}

void restore_rares(call_expression *m_node,
                   assignment_expression *call_expr,
                   const std::map<unsigned,unsigned> &rare_map,
                   expression * &main_parent_list,
                   ii_ptr *orig_id_index,
                   const std::map<unsigned,std::string> &hoists,
                   function_definition *fd) {
    std::map<unsigned,unsigned>::const_iterator rare_iter;

    auto_ptr<expression_type> ret_type(m_node->get_return_type());
    if(ret_type->is_void() || return_value_not_used(m_node)) {
        main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list, call_expr);

#if 0
        if(g_gc_at_call) {
            main_parent_list = gen_gc_at_call(main_parent_list,fd);
        }
#endif

        for(rare_iter  = rare_map.begin();
            rare_iter != rare_map.end();
          ++rare_iter) {
            std::stringstream index_buf;
            index_buf << rare_iter->second;

            main_parent_list = new expression_expression_assignment_expression(
                              main_parent_list,
                              new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                expr_gen(unary_expression,primary_expression,new primary_expression_identifier(orig_id_index[rare_iter->first])),
                                new assignment_operator_equal(),
                                expr_gen(assignment_expression,postfix_expression,new postfix_expression_postfix_expression_brace_expression(
                                  gen_pseudo_pe("prt_refs_and_array.ref_array_struct.ref_array",fd),
                                  new expression_assignment_expression(
                                    expr_gen(assignment_expression,primary_expression,new primary_expression_constant(index_buf.str())))))));
        }

        std::map<unsigned,std::string>::const_iterator hoist_iter;
        for(hoist_iter  = hoists.begin();
            hoist_iter != hoists.end();
          ++hoist_iter) {
            main_parent_list = new expression_expression_assignment_expression(
                              main_parent_list,
                              new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add((*hoist_iter).second))),
                                new assignment_operator_equal(),
                                expr_gen(assignment_expression,postfix_expression,
                                  gen_pseudo_pe(orig_id_index[(*hoist_iter).first]->get_ref_field_name(),fd)
                                )
                              )
                            );
        }
    } else {
        std::stringstream var_str;
        var_str << "_pillar2c_temp_" << m_node->get_unique();

        declarator *var_decl = NULL;
        if(ret_type->m_ad) {
            var_decl = ret_type->m_ad->gen_declarator(var_str.str());
        } else {
            var_decl = new declarator_direct_declarator(
                         new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str()))
                       );
        }

        block_item_list * bil =
            new block_item_list_block_item(
              new block_item_declaration(
                new declaration_declaration_specifiers_init_declarator_list(
                  new declaration_specifiers_type_specifier(
                    (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                  new init_declarator_list_init_declarator(
                    new init_declarator_declarator(
                      var_decl))),0));

        fd->prepend_bil(bil);

//        m_node->claim();

        main_parent_list =
            expression_expression_assignment_expression::new_recursive(main_parent_list,
              new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                new assignment_operator_equal(),
                call_expr
//                expr_gen(assignment_expression,postfix_expression,new postfix_expression_call_expression(m_node))
              )
            );

#if 0
        if(g_gc_at_call) {
            main_parent_list = gen_gc_at_call(main_parent_list,fd);
        }
#endif

        for(rare_iter  = rare_map.begin();
            rare_iter != rare_map.end();
          ++rare_iter) {
            std::stringstream index_buf;
            index_buf << rare_iter->second;

            main_parent_list = new expression_expression_assignment_expression(
                              main_parent_list,
                              new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                expr_gen(unary_expression,primary_expression,new primary_expression_identifier(orig_id_index[rare_iter->first])),
                                new assignment_operator_equal(),
                                expr_gen(assignment_expression,postfix_expression,new postfix_expression_postfix_expression_brace_expression(
                                  gen_pseudo_pe("prt_refs_and_array.ref_array_struct.ref_array",fd),
                                  new expression_assignment_expression(
                                    expr_gen(assignment_expression,primary_expression,new primary_expression_constant(index_buf.str())))))));

        }

        std::map<unsigned,std::string>::const_iterator hoist_iter;
        for(hoist_iter  = hoists.begin();
            hoist_iter != hoists.end();
          ++hoist_iter) {
            main_parent_list = new expression_expression_assignment_expression(
                              main_parent_list,
                              new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add((*hoist_iter).second))),
                                new assignment_operator_equal(),
                                expr_gen(assignment_expression,postfix_expression,
                                  gen_pseudo_pe(orig_id_index[(*hoist_iter).first]->get_ref_field_name(),fd))));
        }

        main_parent_list = expression_expression_assignment_expression::new_recursive(
                          main_parent_list,
                          expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str())))
                        );
    }
}

void ref_call::final_backtrace_internal(
                               ref_map &map_for_this_call,
                               unsigned num_total_refs,
                               unsigned *old_new_ref_map,
                               unsigned &condensed_refs,
                               ii_ptr *orig_id_index,
                               const std::string &func_params,
                               const ref_map &active_rare,
                               const std::map<unsigned,std::string> &hoists,
                               bool ref_params_in_pseudo) {
    unsigned index;
    std::stringstream ref_mask_name;
    if(!m_node) {
        aeprintf("m_node NULL in ref_call::final_backtrace_internal.\n");
    }
    function_definition *enclosing_fd = m_node->find_enclosing_function();
    if(!enclosing_fd) {
        m_node->print();
        printf("\n");
        aeprintf("Could not find the enclosing function for the m_node.\n");
        enclosing_fd = m_node->find_enclosing_function(); // so debugger can step through it
    }
    ii_ptr enclosing_fd_ii = enclosing_fd->get_symbol();
    if(!enclosing_fd_ii) {
        aeprintf("Could not find the enclosing function symbol information for the m_node.\n");
    }

    ref_mask_name << "ref_mask_" << m_node->get_unique(enclosing_fd_ii->get_string());
    AST_node *m_node_parent = m_node->get_parent();

    std::set<unsigned> used_refs_in_args, new_indices_args;
    m_node->get_used_refs(used_refs_in_args);

    std::set<unsigned>::iterator arg_iter;
    for(arg_iter  = used_refs_in_args.begin();
        arg_iter != used_refs_in_args.end();
      ++arg_iter) {
        if(*arg_iter < num_total_refs) {
            if(orig_id_index[*arg_iter]->get_ref_param_in_place()) {
                aeprintf("The parameter position of a ref staying in place was seen.\n");
            }
            if(old_new_ref_map[*arg_iter] != (unsigned)-1) {
                new_indices_args.insert(old_new_ref_map[*arg_iter]);
            }
        } else {
            aeprintf("Got a used ref index greater than the number of total refs.\n");
        }
    }

    assert(old_new_ref_map);
    if(condensed_refs+1 > UINT_MAX) {
        aeprintf("Too many refs in this method.\n");
    }

    std::stringstream ref_decl;
    std::map<unsigned,unsigned> rare_map;
    std::map<unsigned,unsigned>::iterator rare_iter;

    check_vector<unsigned> ref_param_offsets;

    for(index = 0; index < num_total_refs; ++index) {
        if(map_for_this_call[index] == RVALUE && !ref_params_in_pseudo && orig_id_index[index]->is_param()) {
            unsigned push_index = orig_id_index[index]->get_ref_index();
            if(!(push_index > (REGISTER_PARAM_SIZE * get_num_p2c_added_params()))) {
                orig_id_index[index]->get_ref_index();
                aeprintf("Ref param index not greater than the p2c added parameters.\n");
            }
            ref_param_offsets.push_back(push_index);
        }
    }

    gen_ref_info *temp_vec = new gen_ref_info[num_total_refs];
    memset(temp_vec,0,sizeof(gen_ref_info) * condensed_refs);
    for(index = 0; index < num_total_refs; ++index) {
        // If we aren't putting ref params in the pseudo-frame then ignore this ref index.
        if(!ref_params_in_pseudo && orig_id_index[index]->is_param()) {
            continue;
        }
        // the index can be rvalue and the old new ref map not have an index mapped if the ref is only used at rare callsites where we'll spill/refill rather than maintain it in the pseudo-frame
        if(map_for_this_call[index] == RVALUE && old_new_ref_map[index] != (unsigned)-1) {
            assert(old_new_ref_map[index] < condensed_refs);
            type_specifier_PRT_REF *ref_type = dynamic_cast<type_specifier_PRT_REF*>(orig_id_index[index]->get_ultimate_prt_ref());
            if(ref_type) {
                unsigned new_ref_map_index = old_new_ref_map[index];
                assert(temp_vec[new_ref_map_index].active == 0);
                temp_vec[new_ref_map_index].active = 1;
                temp_vec[new_ref_map_index].tag    = ref_type->get_gen_ref_tag();
                temp_vec[new_ref_map_index].id     = ref_type->get_gen_ref_id();
            } else {
                aeprintf("ref_call::final_backtrace should always find a PRT_REF type_specifier for the ref symbols.\n");
            }
        }
    }

    unsigned extra_spills = 0;

    for(index = 0; index < num_total_refs; ++index) {
        // If we aren't putting ref params in the pseudo-frame then ignore this ref index.
        if(!ref_params_in_pseudo && orig_id_index[index]->is_param()) {
            continue;
        }
        if(active_rare[index] && map_for_this_call[index] == RVALUE) {
            assert(old_new_ref_map[index] == (unsigned)-1);

            type_specifier_PRT_REF *ref_type = dynamic_cast<type_specifier_PRT_REF*>(orig_id_index[index]->get_ultimate_prt_ref());
            if(ref_type) {
                unsigned j;
                for(j = 0; j < condensed_refs; ++j) {
                    if(temp_vec[j].active == 0 && new_indices_args.find(j) == new_indices_args.end()) break;
                }
                if(j == condensed_refs) {
                    unsigned spill_offset = condensed_refs + (extra_spills++);
                    temp_vec[spill_offset].active = 1;
                    temp_vec[spill_offset].tag    = ref_type->get_gen_ref_tag();
                    temp_vec[spill_offset].id     = ref_type->get_gen_ref_id();
                    rare_map.insert(std::pair<unsigned,unsigned>(index,spill_offset));
                } else {
                    temp_vec[j].active = 1;
                    temp_vec[j].tag    = ref_type->get_gen_ref_tag();
                    temp_vec[j].id     = ref_type->get_gen_ref_id();
                    rare_map.insert(std::pair<unsigned,unsigned>(index,j));
                }
            } else {
                aeprintf("ref_call::final_backtrace should always find a PRT_REF type_specifier for the ref symbols.\n");
            }
        }
    }

    condensed_refs += extra_spills;

    unsigned gen_ref_size = condensed_refs + ref_param_offsets.size();

#ifdef MULTITHREAD
    pthread_mutex_lock(&g_generic_mutex);
#endif
    if(gen_ref_size) {
        std::pair<std::set<unsigned>::iterator,bool> ins_res = g_gen_ref_lengths.insert(gen_ref_size);
		if(two_phase && ins_res.second) {
			std::stringstream buf;
			buf << "typedef struct {\nunsigned length;\n_pillar2c_gen_ref_info refs[" << gen_ref_size << "];\n} _pillar2c_gen_ref_" << gen_ref_size << ";\n";
		    external_declaration *ed = new external_declaration_emit_text(buf.str());
	        m_node->insert_before_top_level(ed);
		}
    }
#ifdef MULTITHREAD
    pthread_mutex_unlock(&g_generic_mutex);
#endif

    if(gen_ref_size) {
        ref_decl << "_pillar2c_gen_ref_" << gen_ref_size << " "
                    << ref_mask_name.str() << " = {" << gen_ref_size;
        if(condensed_refs || ref_param_offsets.size()) {
            ref_decl << ",{";
        }
        for(index = 0; index < condensed_refs; ++index) {
            if(index) {
                ref_decl << ",";
            }

            ref_decl << "{";
            ref_decl << temp_vec[index].active << ",";
            ref_decl << temp_vec[index].tag    << ",";
            ref_decl << temp_vec[index].id     << "}";
        }
        for(index = 0; index < ref_param_offsets.size(); ++index) {
            if(index || condensed_refs) {
                ref_decl << ",";
            }

            ref_decl << "{";
            ref_decl << ref_param_offsets[index] << ",";
            ref_decl << 0 << ",";
            ref_decl << 0 << "}";
//            ref_decl << NULL << "}";
        }
        if(condensed_refs || ref_param_offsets.size()) {
            ref_decl << "}";
        }

        ref_decl << "};\n";

        external_declaration *ed = new external_declaration_emit_text(ref_decl.str());
        m_node->insert_before_top_level(ed);
    }

    delete [] temp_vec;

    // Get the function that this function call takes place in.
    function_definition *fd = m_node->find_enclosing_function();
    assert(fd);

    // Get the calling convention of the target.
    PILLAR2C_CALLCONV callee_cc;
    // See if that target is managed or not.
    MAN_UNMAN callee_managed;

    std::string func_name = m_node->get_func_name();

    if(func_name == "gc_heap_slot_write_barrier_indirect_prt" ||
       func_name == "gc_heap_slot_write_interior_indirect_prt" ||
       func_name == "gc_cas_write_barrier_indirect_prt" ||
       func_name == "gc_cas_write_interior_indirect_prt") {
        callee_cc = ST_PDECL;
        callee_managed = MU_MANAGED;
        m_args_already_added = true;
    } else {
        callee_cc      = m_node->get_call_cc();
        callee_managed = cc_to_man_unman(callee_cc);
    }

    // If this is a call from managed to unmanaged or vice versa then
    // insert the appropriate stub.
    if(cc_to_man_unman(fd->get_function_cc()) != callee_managed) {
        assert(!fd->is_gc_safe());
        ++g_unsafe_calls;

#ifdef __x86_64__
        if(!g_vse_added) {
            g_vse_added = true;
            g_scope_stack.find_or_add("_pillar2c_m2u_vse");
            m_node->insert_before_top_level(
               new external_declaration_emit_text(
                  "typedef struct {\n"
                  "char prt_reserved[PILLAR_VSE_SIZE];\n"
                  "void (*realM2uUnwinder)(void *,void *);\n"
                  "void *latest_pseudo_frame;\n"
                  "void *rip_estimate;\n"
                  "} _pillar2c_m2u_vse;\n"
                  "void * _pillar2c_get_next_rip_addr(void);\n"
               ));
        }

        expression *inclusive_stmt = search_up_for_type<expression>(m_node);
        initializer_assignment_expression *iae = NULL;
        if(!inclusive_stmt) {
            iae = search_up_for_type<initializer_assignment_expression>(m_node);
            if(!iae) {
                aeprintf("Couldn't find inclusive statement to add set of ref_mask_ptr.\n");
            }
        }

        AST_node *inc_stmt_parent = NULL;
        if(inclusive_stmt) {
            inc_stmt_parent = inclusive_stmt->get_parent();
        } else {
            inc_stmt_parent = iae->get_parent();
        }

        auto_ptr<expression_type> ret_type(m_node->get_return_type());
        std::stringstream var_str;
        std::stringstream vse_str;

        expression *new_expr = NULL;
        bool ret_needed = !ret_type->is_void();

        ii_ptr to_unmanaged_symbol = NULL;
        to_unmanaged_symbol = g_scope_stack.find_symbol("enterUnmanagedCode");
        if(!to_unmanaged_symbol) {
            aeprintf("Pillar function enterUnmanagedCode not found in symbol table.\n");
        }
        ii_ptr reenter_managed_symbol = NULL;
        reenter_managed_symbol = g_scope_stack.find_symbol("reenterManagedCode");
        if(!reenter_managed_symbol) {
            aeprintf("Pillar function reenterManagedCode not found in symbol table.\n");
        }

        unary_expression *ue = NULL;
        if(gen_ref_size) {
            ue = new unary_expression_unary_operator_cast_expression(
                    new unary_operator_and(),
                        expr_gen(cast_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(ref_mask_name.str()))));
        } else {
            ue = expr_gen(unary_expression,primary_expression,new primary_expression_constant("0"));
        }

        assignment_expression *ref_mask_list =
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               new unary_expression_postfix_expression(
                 gen_pseudo_pe("ref_mask_ptr",m_node)),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,unary_expression,ue));

        if(g_log_m2u) {
            char *string_lit;
            if(func_name == "") {
                string_lit = strdup("\"function_pointer\"");
            } else {
                std::string with_quotes = "\"" + func_name + "\"";
                string_lit = strdup(with_quotes.c_str());
            }

            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                expr_gen(assignment_expression,postfix_expression,
                new postfix_expression_call_expression(
                    new call_expression_postfix_expression_paren_argument_expression_list (
                    new postfix_expression_primary_expression(
                        new primary_expression_identifier(g_scope_stack.find_or_add("__pillar2c_log_m2u"))),
                    new argument_expression_list_assignment_expression(
                        expr_gen(assignment_expression,primary_expression,
                        new primary_expression_string(string_lit)))))));
        }

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,ref_mask_list);

        vse_str << "_pillar2c_vse_" << m_node->get_unique();

        declarator *vse_decl = new declarator_direct_declarator(
                                 new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(vse_str.str())));

        block_item_list * vse_bil =
            new block_item_list_block_item(
                new block_item_declaration(
                  new declaration_declaration_specifiers_init_declarator_list(
                    new declaration_specifiers_type_specifier(
                      new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("_pillar2c_m2u_vse"))),
                    new init_declarator_list_init_declarator(
                      new init_declarator_declarator(
                        vse_decl))),0));

        inc_stmt_parent->prepend_bil(vse_bil);

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               new unary_expression_postfix_expression(
                 new postfix_expression_postfix_expression_dot_identifier(
                   new postfix_expression_primary_expression(
                     new primary_expression_identifier(g_scope_stack.find_or_add(vse_str.str().c_str()))),
                   "realM2uUnwinder")),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add("pillar2c_m2u_unwinder")))));

        argument_expression_list *enter_unmanaged_arg = NULL;

        if(g_use_th_param) {
            enter_unmanaged_arg = argument_expression_list::new_recursive(enter_unmanaged_arg,
                                    expr_gen(assignment_expression,primary_expression,
                                       new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle"))));
        } else {
            enter_unmanaged_arg = argument_expression_list::new_recursive(enter_unmanaged_arg,
                                    expr_gen(assignment_expression,postfix_expression,
                                       new postfix_expression_call_expression(
                                         new call_expression_postfix_expression_empty_paren(
                                           new postfix_expression_primary_expression(
                                             new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));
        }

        enter_unmanaged_arg = argument_expression_list::new_recursive(enter_unmanaged_arg,
                                expr_gen(assignment_expression,cast_expression,
                                  new cast_expression_type_name_cast_expression(
                                    new type_name_specifier_qualifier_list(
                                      new specifier_qualifier_list_type_specifier(
                                        new type_specifier_TYPE_NAME(g_scope_stack.find_or_add("PrtVseHandle")))),
                                    new cast_expression_unary_expression(
                                      new unary_expression_unary_operator_cast_expression(
                                        new unary_operator_and(),
                                          expr_gen(cast_expression,primary_expression,
                                            new primary_expression_identifier(g_scope_stack.find_or_add(vse_str.str().c_str()))))))));

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               new unary_expression_postfix_expression(
                 new postfix_expression_postfix_expression_dot_identifier(
                   new postfix_expression_primary_expression(
                     new primary_expression_identifier(g_scope_stack.find_or_add(vse_str.str().c_str()))),
                   "latest_pseudo_frame")),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,cast_expression,
                new cast_expression_unary_expression(
                 new unary_expression_unary_operator_cast_expression(
                  new unary_operator_and(),
                  expr_gen(cast_expression,primary_expression,
                     new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME))))))));

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               new unary_expression_postfix_expression(
                 new postfix_expression_postfix_expression_dot_identifier(
                   new postfix_expression_primary_expression(
                     new primary_expression_identifier(g_scope_stack.find_or_add(vse_str.str().c_str()))),
                   "rip_estimate")),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,postfix_expression,
                 new postfix_expression_call_expression(
                   new call_expression_postfix_expression_empty_paren(
                     new postfix_expression_primary_expression(
                       new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_get_next_rip_addr"))))))));

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
               expr_gen(assignment_expression,postfix_expression,
                 new postfix_expression_call_expression(
                   new call_expression_postfix_expression_paren_argument_expression_list(
                     new postfix_expression_primary_expression(
                       new primary_expression_identifier(to_unmanaged_symbol)),
                     enter_unmanaged_arg))));

        if(inclusive_stmt) {
            if (ret_needed) {
                var_str << "_pillar2c_temp_" << m_node->get_unique();

                declarator *var_decl = NULL;
                if(ret_type->m_ad) {
                    var_decl = ret_type->m_ad->gen_declarator(var_str.str());
                } else {
                    var_decl = new declarator_direct_declarator(
                                 new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str())));
                }

                block_item_list * bil =
                    new block_item_list_block_item(
                      new block_item_declaration(
                        new declaration_declaration_specifiers_init_declarator_list(
                          new declaration_specifiers_type_specifier(
                            (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                          new init_declarator_list_init_declarator(
                            new init_declarator_declarator(
                              var_decl))),0));

                inc_stmt_parent->prepend_bil(bil);

                new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                               expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                               new assignment_operator_equal(),
                               expr_gen(assignment_expression,primary_expression,
                                 new primary_expression_expression(inclusive_stmt))));
            } else {
                new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                               expr_gen(assignment_expression,primary_expression,
                                 new primary_expression_expression(inclusive_stmt)));
            }

            argument_expression_list *reenter_managed_arg = NULL;

            if(g_use_th_param) {
                reenter_managed_arg = argument_expression_list::new_recursive(reenter_managed_arg,
                                        expr_gen(assignment_expression,primary_expression,
                                           new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle"))));
            } else {
                reenter_managed_arg = argument_expression_list::new_recursive(reenter_managed_arg,
                                        expr_gen(assignment_expression,postfix_expression,
                                           new postfix_expression_call_expression(
                                             new call_expression_postfix_expression_empty_paren(
                                               new postfix_expression_primary_expression(
                                                 new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));
            }

            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                   expr_gen(assignment_expression,postfix_expression,
                     new postfix_expression_call_expression(
                       new call_expression_postfix_expression_paren_argument_expression_list(
                         new postfix_expression_primary_expression(
                           new primary_expression_identifier(reenter_managed_symbol)),
                         reenter_managed_arg))));

            if (ret_needed) {
                new_expr = expression_expression_assignment_expression::new_recursive(
                     new_expr,
                     expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))));
            }

            inc_stmt_parent->replace(inclusive_stmt,new_expr);
        } else {
            assignment_expression *iae_ae = iae->claim_assignment_expression();
            assert(ret_needed);

            var_str << "_pillar2c_temp_" << m_node->get_unique();

            declarator *var_decl = NULL;
            if(ret_type->m_ad) {
                var_decl = ret_type->m_ad->gen_declarator(var_str.str());
            } else {
                var_decl = new declarator_direct_declarator(
                                new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str())));
            }

            block_item_list * bil =
                new block_item_list_block_item(
                    new block_item_declaration(
                    new declaration_declaration_specifiers_init_declarator_list(
                        new declaration_specifiers_type_specifier(
                        (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                        new init_declarator_list_init_declarator(
                        new init_declarator_declarator(
                            var_decl))),0));

            inc_stmt_parent->prepend_bil(bil);

            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                            new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                            expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                            new assignment_operator_equal(),
                            expr_gen(assignment_expression,primary_expression,
                                new primary_expression_expression(
                                  new expression_assignment_expression(
                                    iae_ae)))));

            argument_expression_list *reenter_managed_arg = NULL;

            if(g_use_th_param) {
                reenter_managed_arg = argument_expression_list::new_recursive(reenter_managed_arg,
                                        expr_gen(assignment_expression,primary_expression,
                                           new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle"))));
            } else {
                reenter_managed_arg = argument_expression_list::new_recursive(reenter_managed_arg,
                                        expr_gen(assignment_expression,postfix_expression,
                                           new postfix_expression_call_expression(
                                             new call_expression_postfix_expression_empty_paren(
                                               new postfix_expression_primary_expression(
                                                 new primary_expression_identifier(g_scope_stack.find_or_add("prtGetTaskHandle")))))));
            }

            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                   expr_gen(assignment_expression,postfix_expression,
                     new postfix_expression_call_expression(
                       new call_expression_postfix_expression_paren_argument_expression_list(
                         new postfix_expression_primary_expression(
                           new primary_expression_identifier(reenter_managed_symbol)),
                         reenter_managed_arg))));

            new_expr = expression_expression_assignment_expression::new_recursive(
                    new_expr,
                    expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))));

            inc_stmt_parent->replace(iae,
                new initializer_assignment_expression(
                  expr_gen(assignment_expression,primary_expression,
                    new primary_expression_expression(new_expr))));

            delete iae;
        }

        return;
#else  // __x86_64__
        // Get the function expression and a vector of function arguments.
        auto_ptr<call_expression_metadata> cem(m_node->get_call_metadata());

        size_t callee_num_args = cem->m_args.size();

        ii_ptr stub_symbol = NULL;
        std::string stub_name;
        // Determine the name of the Pillar stub to invoke.
        if(callee_managed == MU_MANAGED) {
            stub_name = "prtInvokeManagedFunc";
        } else {
            stub_name = gen_and_insert_m2u_with_ret(m_node,fd,*cem->m_ret);
        }

        stub_symbol = g_scope_stack.find_symbol(stub_name);
        if(!stub_symbol) {
            aeprintf("Pillar stub %s not found in symbol table.\n",stub_name.c_str());
        }

        // The 4th parameter to the transition stub is a Pillar call type.
        ii_ptr prt_call_type = NULL;
        if(callee_cc == ST_PDECL || callee_cc == ST_STDCALL) {
            prt_call_type = g_scope_stack.find_symbol("PrtCcStdcall");
            if(!prt_call_type) {
                aeprintf("Pillar stub PrtCcStdcall not found in symbol table.\n");
            }
        } else if (callee_cc == ST_PCDECL || callee_cc == ST_CDECL) {
            prt_call_type = g_scope_stack.find_symbol("PrtCcCdecl");
            if(!prt_call_type) {
                aeprintf("Pillar stub PrtCcCdecl not found in symbol table.\n");
            }
        } else assert(0);

        assignment_expression * arg_start_assignment_expression = NULL;
        assignment_expression * arg_size_expression = NULL;
        assignment_expression * cc_expression = NULL;
        assignment_expression * task_handle_arg = NULL;
        assignment_expression * pseudo_frame_arg = NULL;
        assignment_expression * function_expression = NULL;

        function_expression = expr_gen(assignment_expression,postfix_expression,cem->claim_function());

        if(!callee_num_args) {
            arg_start_assignment_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));
        }

        cc_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(prt_call_type));

        if(callee_managed == MU_UNMANAGED) {
            if(g_use_th_param) {
                task_handle_arg  = expr_gen(assignment_expression,primary_expression,
                                     new primary_expression_identifier(g_scope_stack.find_or_add("_pillar2c_task_handle")));
            }

            pseudo_frame_arg = expr_gen(assignment_expression,unary_expression,
                                        new unary_expression_unary_operator_cast_expression(
                                         new unary_operator_and(),
                                         expr_gen(cast_expression,primary_expression,
                                          new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME)))));
        }

        argument_expression_list *func_arg = NULL;

        if(task_handle_arg) {
            func_arg = argument_expression_list::new_recursive(func_arg,task_handle_arg);
        }
        if(pseudo_frame_arg) {
            func_arg = argument_expression_list::new_recursive(func_arg,pseudo_frame_arg);
        }
        func_arg = argument_expression_list::new_recursive(func_arg,function_expression);

        std::stringstream callsite_str;
        callsite_str << "PrtArgs_" << m_node->get_unique();

        if(cem->m_args.size()) {
            std::list<external_declaration *> spec_struct = gen_specific_callsite_prt_args(4,fd->get_symbol()->get_string(),callsite_str.str(),*cem);
            fd->insert_before_top_level(spec_struct);
            if(g_prt_args_in_pseudo) {
                std::stringstream type_buf;
                type_buf << "PrtArgs_" << m_node->get_unique();

                std::stringstream var_buf;
                var_buf << "prt_args_" << m_node->get_unique();

                fd->add_prt_arg_list(m_node->get_unique(), type_buf.str(), var_buf.str());
            } else {
                fd->prepend_bil(generate_prt_args_decl(m_node));
            }
        }

        std::stringstream stub_args_name;
        stub_args_name << "prt_arguments.prt_args_" << m_node->get_unique();

        if(callee_num_args) {
            if(g_prt_args_in_pseudo) {
                arg_start_assignment_expression = expr_gen(assignment_expression,unary_expression,
                       new unary_expression_unary_operator_cast_expression (
                        new unary_operator_and(),
                        expr_gen(cast_expression,postfix_expression,
                          gen_pseudo_pe(stub_args_name.str(),m_node))));

                arg_size_expression = expr_gen(assignment_expression,multiplicative_expression,
                   new multiplicative_expression_multiplicative_expression_div_cast_expression(
                    new multiplicative_expression_cast_expression(
                     new cast_expression_unary_expression(
                      new unary_expression_sizeof_unary_expression(
                       new unary_expression_postfix_expression(
                        new postfix_expression_primary_expression(
                         new primary_expression_expression(
                          new expression_assignment_expression(
                           expr_gen(assignment_expression,primary_expression,
                             gen_pseudo_pe(stub_args_name.str(),m_node))))))))),
                    expr_gen(cast_expression,primary_expression,new primary_expression_constant(register_size_const))));
            } else {
                arg_start_assignment_expression = expr_gen(assignment_expression,unary_expression,
                       new unary_expression_unary_operator_cast_expression (
                        new unary_operator_and(),
                        expr_gen(cast_expression,primary_expression,
                           new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))));

                arg_size_expression = expr_gen(assignment_expression,multiplicative_expression,
                   new multiplicative_expression_multiplicative_expression_div_cast_expression(
                    new multiplicative_expression_cast_expression(
                     new cast_expression_unary_expression(
                      new unary_expression_sizeof_unary_expression(
                       new unary_expression_postfix_expression(
                        new postfix_expression_primary_expression(
                         new primary_expression_expression(
                          new expression_assignment_expression(
                           expr_gen(assignment_expression,primary_expression,
                                new primary_expression_identifier(g_scope_stack.find_or_add(stub_args_name.str())))))))))),
                    expr_gen(cast_expression,primary_expression,new primary_expression_constant(register_size_const))));
            }
        } else {
            arg_size_expression = expr_gen(assignment_expression,primary_expression,new primary_expression_constant("0"));
        }

        argument_expression_list *arg_start_arg =
            new argument_expression_list_argument_expression_list_assignment_expression(func_arg,arg_start_assignment_expression);

        call_expression *stub_call_expr = NULL;

        assignment_expression *stub_call = NULL;
        stub_call = expr_gen(assignment_expression,postfix_expression,
                          new postfix_expression_call_expression(
                           stub_call_expr = new call_expression_postfix_expression_paren_argument_expression_list(
                            // Postfix arg to call_expression.
                            new postfix_expression_primary_expression(
                             new primary_expression_identifier(stub_symbol)),
                            // Argument expression list arg to call_expression.
                            new argument_expression_list_argument_expression_list_assignment_expression(
                             new argument_expression_list_argument_expression_list_assignment_expression(
                              arg_start_arg,
                              // The third arg to the stub.
                              arg_size_expression
                             ),
                             // The last arg to the stub.
                             cc_expression))));

        expression *main_parent_list = NULL;
        if(g_log_m2u) {
            char *string_lit;
            if(func_name == "") {
                string_lit = strdup("\"function_pointer\"");
            } else {
                std::string with_quotes = "\"" + func_name + "\"";
                string_lit = strdup(with_quotes.c_str());
            }

            main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                expr_gen(assignment_expression,postfix_expression,
                new postfix_expression_call_expression(
                    new call_expression_postfix_expression_paren_argument_expression_list (
                    new postfix_expression_primary_expression(
                        new primary_expression_identifier(g_scope_stack.find_or_add("__pillar2c_log_m2u"))),
                    new argument_expression_list_assignment_expression(
                        expr_gen(assignment_expression,primary_expression,
                        new primary_expression_string(string_lit)))))));
        }

        if(cem->m_args.size() > 0) {
            std::stringstream arg_prefix;
            arg_prefix << "prt_arguments.";
            if(g_prt_args_in_pseudo) {
                arg_prefix << "prt_args_" << m_node->get_unique() << ".";
            }
            arg_prefix << "prt_args_";

            check_vector<assignment_expression*> claimed_aes = m_node->claim_args();

            unsigned index;
            // Add additional args and create an expression assignment AST node.
            for(index=0; index < cem->m_args.size(); ++index) {
                if(index < cem->m_func_metadata.m_params.size()) {
                    auto_ptr<expression_type> apet(cem->m_func_metadata.m_params[index]->get_type());
                    main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                      create_expression_for_arg(apet.get(),claimed_aes[index],index,m_node,"arg",arg_prefix.str().c_str(),true));
                } else {
                    auto_ptr<expression_type> apet(cem->m_args[index]->get_type());
                    main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,
                      create_expression_for_arg(apet.get(),claimed_aes[index],index,m_node,"arg",arg_prefix.str().c_str(),true));
                }
            }

            bool spilled_something = spill_rares(rare_map, main_parent_list, orig_id_index, hoists, m_node);

            if(spilled_something) {
                restore_rares(m_node, stub_call, rare_map, main_parent_list, orig_id_index, hoists, m_node->find_enclosing_function());
            } else {
                // Add the stub call itself.
                main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,stub_call);
            }
        } else {
            bool spilled_something = spill_rares(rare_map, main_parent_list, orig_id_index, hoists, m_node_parent);

            if(spilled_something) {
                restore_rares(m_node, stub_call, rare_map, main_parent_list, orig_id_index, hoists, m_node_parent->find_enclosing_function());
            } else {
                // Add the stub call itself.
                main_parent_list = expression_expression_assignment_expression::new_recursive(main_parent_list,stub_call);
            }
        }

        postfix_expression_primary_expression *pepe = NULL;
        pepe = new postfix_expression_primary_expression(
                 new primary_expression_expression(main_parent_list)
               );

        if(g_pillar2c_debug_level > 2) {
            printf("// CALL to be inserted.\n#if 0\n");
            pepe->print();
            printf("\n#endif\n// Insert CALL\n");
        }
        m_node_parent->get_parent()->replace(m_node_parent,pepe);

        delete m_node_parent;

        m_node = stub_call_expr;
#endif // __x86_64__
    } else {
        // calling convention match
        if(callee_managed == MU_MANAGED) {
            // no translations for pcdecl
            if(callee_cc == ST_PDECL && !m_args_already_added) {
                std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE>::iterator iter;
                iter = g_pillar_runtime_funcs.find(m_node->get_func_name());
                if(iter == g_pillar_runtime_funcs.end()) {
                    // one managed function calling another. add the two extra args
                    argument_expression_list *ael = gen_extra_args();
                    m_node = m_node->prepend_arg_list(ael);
                } else {
                    if(iter->second == PILLAR_RUNTIME_FUNC_NO_DIRECT_CALL) {
                       aeprintf("Direct call to %s not allowed.\n",iter->first.c_str());
                    }
                    // Handle write barrier conversion.
                    if(iter->first == "gc_heap_slot_write_barrier_indirect") {
                        argument_expression_list *ael = gen_extra_args();
                        m_node = m_node->append_arg_list(ael);
                        // now just change the function name
                        m_node->change_func_name(std::string("gc_heap_slot_write_barrier_indirect_prt"));
                    } else if(iter->first == "gc_heap_slot_write_interior_indirect") {
                        argument_expression_list *ael = gen_extra_args();
                        m_node = m_node->append_arg_list(ael);
                        // now just change the function name
                        m_node->change_func_name(std::string("gc_heap_slot_write_interior_indirect_prt"));
                    } else if(iter->first == "gc_cas_write_barrier_indirect") {
                        argument_expression_list *ael = gen_extra_args();
                        m_node = m_node->append_arg_list(ael);
                        // now just change the function name
                        m_node->change_func_name(std::string("gc_cas_write_barrier_indirect_prt"));
                    } else if(iter->first == "gc_cas_write_interior_indirect") {
                        argument_expression_list *ael = gen_extra_args();
                        m_node = m_node->append_arg_list(ael);
                        // now just change the function name
                        m_node->change_func_name(std::string("gc_cas_write_interior_indirect_prt"));
                    } else if(iter->first == "prtYield") {
                        // the pillar2c write barrier takes the extra args
                        argument_expression_list *ael = gen_extra_args();
                        m_node = m_node->prepend_arg_list(ael);
                        // now just change the function name
                        m_node->change_func_name(std::string("pillar2cYield"));
                    }
                }
            }

            expression *new_expr = NULL;

            bool spilled_something = spill_rares(rare_map, new_expr, orig_id_index, hoists, m_node);

            m_node->claim();

            if(spilled_something) {
                restore_rares(m_node, expr_gen(assignment_expression,postfix_expression,new postfix_expression_call_expression(m_node)), rare_map, new_expr, orig_id_index, hoists, m_node_parent->find_enclosing_function());
            } else {
                new_expr =
                    expression_expression_assignment_expression::new_recursive(new_expr,
                     expr_gen(assignment_expression,postfix_expression,new postfix_expression_call_expression(m_node)));
            }

            postfix_expression_primary_expression *call_pepe =
                new postfix_expression_primary_expression(
                 new primary_expression_expression(new_expr)
                );

            m_node_parent->get_parent()->replace(m_node_parent,call_pepe);

            delete m_node_parent;
        } else {
            aeprintf("Should never get here.\n");
        }
    }

    expression *inclusive_stmt = search_up_for_type<expression>(m_node);
    initializer_assignment_expression *iae = NULL;
    if(!inclusive_stmt) {
        iae = search_up_for_type<initializer_assignment_expression>(m_node);
        if(!iae) {
            aeprintf("Couldn't find inclusive statement to add set of ref_mask_ptr.\n");
        }
    }

    AST_node *inc_stmt_parent = NULL;
    if(inclusive_stmt) {
        inc_stmt_parent = inclusive_stmt->get_parent();
    } else {
        inc_stmt_parent = iae->get_parent();
    }

    expression * new_expr = NULL;

    if(m_call_context) {
        std::stringstream ref_temp_str;
        ref_temp_str << "_pillar2c_ref_temp_" << m_node->get_unique();

        block_item_list *ref_temp_decl =
            new block_item_list_block_item(
              new block_item_declaration(
                new declaration_declaration_specifiers_init_declarator_list(
                  new declaration_specifiers_type_specifier(
                    new type_specifier_VOID()),
                  new init_declarator_list_init_declarator(
                    new init_declarator_declarator(
                      new declarator_pointer_direct_declarator(
                        new pointer_star(),
                        new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(ref_temp_str.str())))))),0));

        inc_stmt_parent->prepend_bil(ref_temp_decl);

        assignment_expression *save_ref_mask =
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               expr_gen(unary_expression,primary_expression,
                 new primary_expression_identifier(g_scope_stack.find_or_add(ref_temp_str.str()))),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,postfix_expression,
                 gen_pseudo_pe("ref_mask_ptr",m_node)));

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,save_ref_mask);
    }

    unary_expression *ue = NULL;
    if(gen_ref_size) {
        ue = new unary_expression_unary_operator_cast_expression(
                new unary_operator_and(),
                    expr_gen(cast_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(ref_mask_name.str()))));
    } else {
        ue = expr_gen(unary_expression,primary_expression,new primary_expression_constant("0"));
    }

    assignment_expression *ref_mask_list =
         new assignment_expression_unary_expression_assignment_operator_assignment_expression(
           new unary_expression_postfix_expression(
             gen_pseudo_pe("ref_mask_ptr",m_node)),
           new assignment_operator_equal(),
           expr_gen(assignment_expression,unary_expression,ue));

    new_expr = expression_expression_assignment_expression::new_recursive(new_expr,ref_mask_list);

    auto_ptr<expression_type> ret_type(m_node->get_return_type());
    std::stringstream var_str;

    if(m_call_context) {
        bool save_func_ret = !ret_type->is_void();
//        bool save_func_ret = !ret_type->is_void() && !return_value_not_used(m_node);

        if (save_func_ret) {
            var_str << "_pillar2c_temp_" << m_node->get_unique();

            declarator *var_decl = NULL;
            if(ret_type->m_ad) {
                var_decl = ret_type->m_ad->gen_declarator(var_str.str());
            } else {
                var_decl = new declarator_direct_declarator(
                             new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(var_str.str())));
            }

            block_item_list * bil =
                new block_item_list_block_item(
                  new block_item_declaration(
                    new declaration_declaration_specifiers_init_declarator_list(
                      new declaration_specifiers_type_specifier(
                        (type_specifier*)ret_type->m_sql->get_type_specifier()->clone()),
                      new init_declarator_list_init_declarator(
                        new init_declarator_declarator(
                          var_decl))),0));

            inc_stmt_parent->prepend_bil(bil);

            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                         new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                           expr_gen(unary_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))),
                           new assignment_operator_equal(),
                           expr_gen(assignment_expression,primary_expression,
                             new primary_expression_expression(inclusive_stmt))));
        } else {
            new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                     expr_gen(assignment_expression,primary_expression,
                       new primary_expression_expression(inclusive_stmt)));
        }

        std::stringstream ref_temp_str;
        ref_temp_str << "_pillar2c_ref_temp_" << m_node->get_unique();

        assignment_expression *restore_ref_mask =
             new assignment_expression_unary_expression_assignment_operator_assignment_expression(
               expr_gen(unary_expression,postfix_expression,
                 gen_pseudo_pe("ref_mask_ptr",m_node)),
               new assignment_operator_equal(),
               expr_gen(assignment_expression,primary_expression,
                 new primary_expression_identifier(g_scope_stack.find_or_add(ref_temp_str.str()))));

        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,restore_ref_mask);

        if(save_func_ret) {
            new_expr = expression_expression_assignment_expression::new_recursive(
                 new_expr,
                 expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(g_scope_stack.find_or_add(var_str.str()))));
        }
    } else {
        new_expr = expression_expression_assignment_expression::new_recursive(new_expr,
                 expr_gen(assignment_expression,primary_expression,
                   new primary_expression_expression(inclusive_stmt)));
    }

    if(inclusive_stmt) {
        inc_stmt_parent->replace(inclusive_stmt,
          new expression_assignment_expression(
            expr_gen(assignment_expression,primary_expression,new primary_expression_expression(new_expr))));
    } else {
        assignment_expression *iae_ae = iae->claim_assignment_expression();

        inc_stmt_parent->replace(iae,
            new initializer_assignment_expression(
                expr_gen(assignment_expression,primary_expression,
                new primary_expression_expression(
                    new expression_expression_assignment_expression(
                    new expression_assignment_expression(
                        expr_gen(assignment_expression,primary_expression,
                        new primary_expression_expression(new_expr))),
                    iae_ae)))));

        delete iae;
    }
}

void ref_call::mark_callsite_refs(ref_map &rm, ref_map &vars, bool bb_rare) {
    mark_callsite_refs_internal(m_ref_indices,rm,m_var_indices,vars,bb_rare);
}

void ref_call::mark_callsite_refs_internal(ref_map &map_for_this_call, ref_map &rm, ref_map &vars_for_this_call, ref_map &vars, bool bb_rare) {
    rm.merge_rvalue_rare(map_for_this_call,g_spill_rare && bb_rare);
    vars.merge_rvalue_rare(vars_for_this_call,g_spill_rare && bb_rare);
}

void ref_call::update_state(ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
    update_state_internal(m_ref_indices, m_var_indices, rm, vars, disable_opts);
}

void ref_call::update_state_internal(ref_map &map_for_this_call, ref_map &map_for_var_call, ref_map &rm, ref_map &vars, const std::set<ii_ptr> &disable_opts) {
    map_for_this_call.merge_rvalues(rm);
    map_for_var_call.merge_rvalues(vars);
}

TranslateResult primary_expression_identifier::translate_pillar(function_definition *fd) {
    if(fd && m_ii->has_var_index()) {
        basic_block *cur_bb = fd->get_cur_basic_block();
        if(!cur_bb) {
            // must be in dead code
            return TranslateResult();
        }

#ifndef USE_IS_LVALUE
        LRB_VALUE lrb_res = get_lrb_value(NULL,m_ii);
        if(m_ii->has_ref_index()) {
            call_expression *wrapping_ce = NULL;
            switch(lrb_res) {
            case LRB_LVALUE:
                if(is_call_context()) {
                    aeprintf("lvalue currently incompatible with a call context.\n");
                }
                cur_bb->m_live_refs_here.push_back(new ref_lvalue(m_ii));
                break;
            case LRB_RVALUE:
                cur_bb->m_live_refs_here.push_back(new ref_rvalue(m_ii));
                break;
            case LRB_LRVALUE:
                wrapping_ce = is_call_context();
                if(!wrapping_ce) {
                    aeprintf("Don't expect to get an LRB_LRVALUE ref unless we are in a call context.\n");
                }
                cur_bb->m_live_refs_here.push_back(new ref_rvalue(m_ii));
                wrapping_ce->add_read_write_address_ref(m_ii);
                break;
            default:
                aeprintf("Unknown lrb_value.\n");
            }
        }

        switch(lrb_res) {
        case LRB_LVALUE:
            if(is_call_context()) {
                aeprintf("lvalue currently incompatible with a call context.\n");
            }
            cur_bb->m_live_refs_here.push_back(new var_lvalue(m_ii));
            break;
        case LRB_RVALUE:
            cur_bb->m_live_refs_here.push_back(new var_rvalue(m_ii));
            break;
        case LRB_LRVALUE:
            cur_bb->m_live_refs_here.push_back(new var_rvalue(m_ii));
            cur_bb->m_live_refs_here.push_back(new var_lvalue(m_ii));
            break;
        default:
            aeprintf("Unknown lrb_value.\n");
        }
#else
        bool res_lvalue = is_lvalue(NULL,m_ii);
        if(m_ii->has_ref_index()) {
            if(res_lvalue) {
                if(is_call_context()!=NULL) {
                    aeprintf("lvalue currently incompatible with a call context.\n");
                }
                cur_bb->m_live_refs_here.push_back(new ref_lvalue(m_ii));
            } else {
                cur_bb->m_live_refs_here.push_back(new ref_rvalue(m_ii));
            }
        }

        if(res_lvalue) {
            if(is_call_context()!=NULL) {
                aeprintf("lvalue currently incompatible with a call context.\n");
            }
            cur_bb->m_live_refs_here.push_back(new var_lvalue(m_ii));
        } else {
            cur_bb->m_live_refs_here.push_back(new var_rvalue(m_ii));
        }
#endif

#if 0
        if(!res_lvalue && m_ii->is_ultimate_prt_ref() && g_collect_read_stats) {
            postfix_expression_primary_expression *pepe = dynamic_cast<postfix_expression_primary_expression *>(get_parent());
            if(pepe) {
                AST_node * ref_used_node = NULL;
                if(ref_used_node = pepe->get_parent()->ref_used()) {
                    if(!ref_used_node->get_parent()->is_lvalue(ref_used_node,NULL)) {
                        AST_node *pepe_parent = pepe->get_parent();

                        postfix_expression_primary_expression *new_pepe =
                            new postfix_expression_primary_expression(
                              new primary_expression_expression(
                                new expression_expression_assignment_expression(
                                  new expression_assignment_expression(
                                    expr_gen(assignment_expression,postfix_expression,
                                      new postfix_expression_read_stats(
                                        new call_expression_postfix_expression_paren_argument_expression_list(
                                          new postfix_expression_primary_expression(
                                            new primary_expression_identifier(g_scope_stack.find_or_add("gc_heap_object_read_stats"))
                                          ),
                                          new argument_expression_list_assignment_expression(
                                            expr_gen(assignment_expression,postfix_expression,pepe->clone())
                                          )
                                        )
                                      )
                                    )
                                  ),
                                  expr_gen(assignment_expression,postfix_expression,pepe)
                                )
                              )
                            );

                        pepe_parent->replace(pepe,new_pepe);
                    }
                }
            } else {
                aeprintf("g_collect_read_stats found ref for lvalue whose parent was not a postfix_expression.\n");
            }
        }
#endif
    }

    if(g_expression_type) {
        auto_ptr<expression_type> apet(get_type());
        TranslateResult gttr(apet);
        return gttr;
    } else {
        return TranslateResult();
    }
}

void primary_expression_identifier::create_call_graph(function_definition *fd) {
    if(m_ii->is_function()) {
        postfix_expression *pe = dynamic_cast<postfix_expression *>(get_parent());
        if(!pe) {
            aeprintf("This dynamic cast should always succeed.\n");
        }

        call_expression *ce = dynamic_cast<call_expression*>(pe->get_parent());
        if(!ce) {
            PILLAR2C_CALLCONV func_cc = m_ii->get_function_cc();
            if(func_cc == ST_PDECL) {
                // function name not used in a call context so assume the address is taken and so make it unsafe.
                std::map<std::string,function_definition*>::iterator fmiter = g_func_map.find(m_ii->get_string());
                if(fmiter != g_func_map.end()) {
                    fmiter->second->set_gc_unsafe();

                    if(fd) {
                        std::map<std::string,function_definition*>::iterator fd_fmiter = g_func_map.find("<UNKNOWN_FUNCS");
                        if(fd_fmiter == g_func_map.end()) {
                            aeprintf("Could not find <UNKNOWN_FUNCS in g_func_map.\n");
                        } else {
                            (fmiter->second)->add_call_by(fd_fmiter->second);
                        }
                    }
                }
            }
        }
    }
}

#ifndef USE_IS_LVALUE
LRB_VALUE assignment_expression_unary_expression_assignment_operator_assignment_expression::get_lrb_value(AST_node *child,ii_ptr ii) {
    if(m_ue == child) {
        assignment_operator_equal *aoe = dynamic_cast<assignment_operator_equal*>(m_ao);
        if(aoe) {
            return LRB_LVALUE;
        } else {
            // FIX FIX FIX, need to make "x += 7" both an lvalue and an rvalue
            if(m_ao->read_write()) {
                return LRB_LRVALUE;
            } else {
                aeprintf("Should never get here.\n");
            }
        }
    } else {
        return LRB_RVALUE;
    }
}

LRB_VALUE unary_expression_unary_operator_cast_expression::get_lrb_value(AST_node *child,ii_ptr ii) {
//    print();
//    printf("\n");
    if(dynamic_cast<unary_operator_and*>(m_uo)) {
        if(is_call_context()) {
            return LRB_LRVALUE;
        } else {
            if(ii) {
                ii->set_address_taken();
            }
            return LRB_RVALUE;
        }
    } else {
        return LRB_RVALUE;
    }
}
#else
bool assignment_expression_unary_expression_assignment_operator_assignment_expression::is_lvalue(AST_node *child,ii_ptr ii) {
    if(m_ue == child) {
        assignment_operator_equal *aoe = dynamic_cast<assignment_operator_equal*>(m_ao);
        if(aoe) {
            return true;
        } else {
            return true; // FIX FIX FIX, need to make "x += 7" both an lvalue and an rvalue
        }
    } else {
        return false;
    }
}

bool unary_expression_unary_operator_cast_expression::is_lvalue(AST_node *child,ii_ptr ii) {
//    print();
//    printf("\n");
    if(dynamic_cast<unary_operator_and*>(m_uo)) {
        if(ii) {
            ii->set_address_taken();
        }
        return false;
    } else {
        return false;
    }
}
#endif

std::list<external_declaration *> tu_to_list(translation_unit *tu) {
    std::list<external_declaration *> result;
    tu->to_list(result);
    return result;
}

external_declaration * remove_decl_by_name(const char *name) {
    ED_ITER ed_iter;
    for(ed_iter  = g_ed_list.begin();
        ed_iter != g_ed_list.end();
      ++ed_iter) {
        if((*ed_iter)->declares_name(name)) {
            external_declaration * ret = (*ed_iter);
            g_ed_list.erase(ed_iter);
            return ret;
        }
    }
    return NULL;
}

external_declaration * find_decl_by_name(const char *name) {
    ED_ITER ed_iter;
    for(ed_iter  = g_ed_list.begin();
        ed_iter != g_ed_list.end();
      ++ed_iter) {
        if((*ed_iter)->declares_name(name)) {
            external_declaration * ret = (*ed_iter);
            return ret;
        }
    }
    return NULL;
}

extern "C" void print_ast_tree(void) {
    if(g_ed_list.empty()) {
        printf("// ast_tree was empty.\n");
    } else {
        g_output_mode = true;
        ED_ITER ed_iter;
        ed_iter = g_ed_list.begin();
        while(ed_iter != g_ed_list.end()) {
            (*(ed_iter++))->print();

            if(g_output_cur_line_number > 50000) {
                if(g_output_file_base != "") {
                    std::stringstream complete_name;
                    complete_name << g_output_file_base << ++g_output_file_postfix << ".c";

                    oprintf("#include \"%s\"\n",complete_name.str().c_str());
                    fclose(g_output_file);
                    g_output_file = fopen(complete_name.str().c_str(),"w");
                    assert(g_output_file);
                }

                g_output_cur_line_number = 0;
            }
        }
    }
}

translation_unit * gen_prepend_pillar(void);
std::list<external_declaration *> tu_to_list(translation_unit *tu);

extern "C" void free_ast(void) {
    std::list<external_declaration *>::iterator ed_iter;

    ed_iter = g_ed_list.begin();
    while(ed_iter != g_ed_list.end()) {
        delete *(ed_iter++);
    }

    ii_ptr pillar2c_write_barrier = g_scope_stack.find_or_add("pillar2c_write_barrier");
    delete pillar2c_write_barrier->get_func_definition();
    ii_ptr pillar2c_write_barrier_interior = g_scope_stack.find_or_add("pillar2c_write_barrier_interior");
    delete pillar2c_write_barrier_interior->get_func_definition();
    ii_ptr pillar2c_yield = g_scope_stack.find_or_add("pillar2cYield");
    delete pillar2c_yield->get_func_definition();

    std::list<Scope *>::iterator scope_iter;
    for(scope_iter  = g_all_scopes.begin();
        scope_iter != g_all_scopes.end();
      ++scope_iter) {
        delete *scope_iter;
    }

    delete unknown_funcs;
#ifndef II_PTR
    delete fake_ii;
#endif

#if 0
    unsigned i;
    for(i=0;i<g_m2u_structs.size();++i) {
        delete g_m2u_structs[i];
    }
#endif

#ifdef COUNT_ALLOCATIONS
    printf("Allocation sites: \n");
    std::map<unsigned,unsigned>::iterator iter;
    for(iter  = g_alloc_sites.begin();
        iter != g_alloc_sites.end();
        ++iter) {
        printf("Line: %d, Bytes: %d\n", iter->first, iter->second);
    }
    fflush(stdout);
#endif
}

unsigned get_num_procs(void);

#ifdef MULTITHREAD
void * translate_thread(void *arg) {
    std::list<external_declaration *>::iterator *ed_iter = (std::list<external_declaration *>::iterator *)arg;
    pthread_mutex_lock(&g_generic_mutex);
    while(*ed_iter != g_ed_list.end()) {
        external_declaration *work = **ed_iter;
        (*ed_iter)++;
        pthread_mutex_unlock(&g_generic_mutex);
        work->translate_pillar(NULL);
        pthread_mutex_lock(&g_generic_mutex);
    }
    pthread_mutex_unlock(&g_generic_mutex);
    return NULL;
}

extern "C" int ptw32_processInitialize();
#endif

extern "C" int g_pillar2c_debug_level;

extern int yyparse(void);
#if 0
extern FILE *yyin;
extern "C" int yy_flex_debug;
extern int yylineno;
extern char yytext[];
extern void yyrestart(FILE *);
extern void yy_flush_buffer (void *);
#else
#include "pillar2c_lex.cc"
#endif

void print_one_ed(external_declaration *ed) {
    bool save = g_output_mode;
    g_output_mode = true;

    ed->print();

    if(g_output_cur_line_number > 50000) {
        if(g_output_file_base != "") {
            std::stringstream complete_name;
            complete_name << g_output_file_base << ++g_output_file_postfix << ".c";

            oprintf("#include \"%s\"\n",complete_name.str().c_str());
            fclose(g_output_file);
            g_output_file = fopen(complete_name.str().c_str(),"w");
            assert(g_output_file);
        }

        g_output_cur_line_number = 0;
    }

    g_output_mode = save;
}

void print_and_delete(std::list<external_declaration *> &list) {
    std::list<external_declaration *>::iterator iter;
    for(iter  = list.begin();
        iter != list.end();
      ++iter) {
        print_one_ed(*iter);
        delete *iter;
    }
    list.clear();
}

void delete_list(std::list<external_declaration *> &list) {
    std::list<external_declaration *>::iterator iter;
    for(iter  = list.begin();
        iter != list.end();
      ++iter) {
        delete *iter;
    }
    list.clear();
}

void delete_first_parse(void) {
    std::list<external_declaration *>::iterator iter, cur;
    iter = g_ed_list.begin();
    while(iter != g_ed_list.end()) {
        cur = iter++;
        external_declaration_function_definition *edfd = dynamic_cast<external_declaration_function_definition*>(*cur);
        if(!edfd) {
            delete *cur;
        } else {
            edfd->get_function_definition()->forget_first_parse();
        }
        g_ed_list.erase(cur);
    }
}

void delete_second_parse(void) {
    std::list<external_declaration *>::iterator iter, cur;
    iter = g_ed_list.begin();
    while(iter != g_ed_list.end()) {
        cur = iter++;
        delete *cur;
        g_ed_list.erase(cur);
    }
}

void ed_two_phase_callgraph(external_declaration *ed) {
    ed->set_iter(g_ed_list.insert(g_ed_list.end(),ed));

    ed->create_call_graph(NULL);

    external_declaration_function_definition *edfd = dynamic_cast<external_declaration_function_definition*>(ed);
    if(edfd) {
        function_definition *fd = edfd->get_function_definition();
        printf("ii: %d/%d, AST: %d, Scope: %d, %s\n",num_ii,size_ii,g_num_ast_node_created,scope_data,fd->get_symbol()->get_name());
        fd->forget_body();
//      function_definition *fd = edfd->claim();
//      fd->forget_body();
    }

#if 0
    if(yylineno > 1500000) {
#ifdef P2C_MEMORY_DEBUG
#ifdef _MSC_VER
#ifdef _DEBUG
        _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );

//        _CrtMemState cms;
//        _CrtMemCheckpoint(&cms);
//        _CrtMemDumpStatistics(&cms);
        _CrtMemDumpAllObjectsSince(NULL);
#endif
#endif
#endif
        exit(0);
    }
#endif
}

void ed_two_phase_final(external_declaration *ed) {
    bool empty_list = g_ed_list.empty();

    std::list<external_declaration *>::iterator save, iter;

    save = g_ed_list.insert(g_ed_list.end(),ed);
    ed->set_iter(save);

    if(empty_list) {
        iter = g_ed_list.begin();
    } else {
        iter = save;
        --save;
    }

    while(iter != g_ed_list.end()) {
        (*(iter++))->denest(NULL);
    }

    if(empty_list) {
        iter = g_ed_list.begin();
    } else {
        iter = save;
        ++iter;
    }

    while(iter != g_ed_list.end()) {
        (*(iter++))->translate_pillar(NULL);
    }

    if(empty_list) {
        iter = g_ed_list.begin();
    } else {
        iter = save;
        ++iter;
    }

    for(;
        iter != g_ed_list.end();
      ++iter) {
        print_one_ed(*iter);

        external_declaration_function_definition *edfd = dynamic_cast<external_declaration_function_definition*>(*iter);
        if(edfd) {
            function_definition *fd = edfd->get_function_definition();
            printf("ii2: %d/%d, AST: %d, Scope: %d, %s\n",num_ii,size_ii,g_num_ast_node_created,scope_data,fd->get_symbol()->get_name());
            edfd->get_function_definition()->forget_body();
        }
    }
}

extern "C" void start_two_phase(char *filename) {
    pre_parse();

    unknown_funcs = new function_definition_fake();
    fake_ii = new id_info(std::string("<UNKNOWN_FUNCS"),IIT_FUNCTION,NULL);
    unknown_funcs->set_symbol(fake_ii);
    g_func_map.insert(std::pair<std::string,function_definition *>("<UNKNOWN_FUNCS",unknown_funcs));

    std::list<external_declaration *> pre_trans = tu_to_list(gen_pre_trans());
    std::list<external_declaration *> prepend_pillar = tu_to_list(gen_prepend_pillar());

    phase_selector = CALLGRAPH;
    yyin = fopen(filename,"r");
    int parse_result = yyparse();
    fclose(yyin);
    if(parse_result) {
        printf("Program failed to parse at line %d.\nUnparseable symbol at that point => %s.\n",yylineno, yytext);
        assert(0);
        exit(-3);
    }

    // Tell each function to propagate it's unsafeness upstream.
    // When done, all unsafe functions will be marked as such.
    std::map<std::string,function_definition*>::iterator fmiter;
    for(fmiter  = g_func_map.begin();
        fmiter != g_func_map.end();
      ++fmiter) {
        fmiter->second->propagate_unsafe();
    }

    unsigned tarjan_index = 1, scc_number = 1;
    TarjanStack tarjan_stack;

    for(fmiter  = g_func_map.begin();
        fmiter != g_func_map.end();
      ++fmiter) {
        fmiter->second->tarjan(tarjan_index,tarjan_stack,scc_number);
    }

    print_and_delete(pre_trans);
    print_and_delete(prepend_pillar);

#if 0
#ifdef P2C_MEMORY_DEBUG
#ifdef _MSC_VER
#ifdef _DEBUG
        _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );

//        _CrtMemState cms;
//        _CrtMemCheckpoint(&cms);
//        _CrtMemDumpStatistics(&cms);
        _CrtMemDumpAllObjectsSince(NULL);
#endif
#endif
#endif
#endif

    delete_first_parse();

    g_scope_stack.stats();
    g_scope_stack.clear();

    fake_ii = NULL;

    printf("Num id_info = %d\n",num_ii);
    while(g_iis.size()) {
        id_info *del_ii = *(g_iis.begin());
        printf("II: %s\n",del_ii->get_name());
        del_ii->delete_it();
        //delete del_ii;
        //g_iis.erase(g_iis.begin());
    }

#if 1
    pre_parse();

    pre_trans = tu_to_list(gen_pre_trans());
    prepend_pillar = tu_to_list(gen_prepend_pillar());

    phase_selector = ONEEDATATIME;
    yyin = fopen(filename,"r");
    yylineno = 1;
    yyrestart(yyin);
    YY_FLUSH_BUFFER;
    parse_result = yyparse();
    if(parse_result) {
        printf("Program failed to parse at line %d.\nUnparseable symbol at that point => %s.\n",yylineno, yytext);
        assert(0);
        exit(-3);
    }
    fclose(yyin);

    delete_list(pre_trans);
    delete_list(prepend_pillar);
    g_scope_stack.clear();
    delete_second_parse();

    printf("Num id_info = %d\n",num_ii);
    while(g_iis.size()) {
        id_info *del_ii = *(g_iis.begin());
        printf("II2: %s\n",del_ii->get_name());
        del_ii->delete_it();
        //delete del_ii;
        //g_iis.erase(g_iis.begin());
    }
#endif
}

extern "C" void start_translate_pillar(void) {
    g_translation_started = true;

    if(g_use_th_param) {
        g_first_added_param_name = "_pillar2c_task_handle";
    } else {
        g_first_added_param_name = "_pillar2c_prev_pseudo_stack";
    }

#ifdef MULTITHREAD
    ptw32_processInitialize();
    pthread_mutex_init(&g_ed_mutex,NULL);
    pthread_mutex_init(&g_generic_mutex,NULL);
#endif

//    printf("Sizeof AST_node = %d\n",sizeof(AST_node));
    if(g_verbose) {
        printf("Potentially unneeded nodes after parsing = %d\n",g_unneeded_nodes);
        printf("%d symbols created after parsing\n",g_num_id_info_created);
        printf("%d nodes created after parsing\n",g_num_ast_node_created);
    }

    std::list<external_declaration *>::iterator ed_iter;

#ifdef WIN32
    StartTimer();
#endif

    unknown_funcs = new function_definition_fake();
    fake_ii = new id_info(std::string("<UNKNOWN_FUNCS"),IIT_FUNCTION,NULL);
    unknown_funcs->set_symbol(fake_ii);
    g_func_map.insert(std::pair<std::string,function_definition *>("<UNKNOWN_FUNCS",unknown_funcs));

    ed_iter = g_ed_list.begin();
    while(ed_iter != g_ed_list.end()) {
        (*(ed_iter++))->create_call_graph(NULL);
    }

#ifdef WIN32
    if(g_verbose) {
        printf("Create call graph = %fs\n",StopTimer());
    }
    StartTimer();
#endif

    // Tell each function to propagate it's unsafeness upstream.
    // When done, all unsafe functions will be marked as such.
    std::map<std::string,function_definition*>::iterator fmiter;
    for(fmiter  = g_func_map.begin();
        fmiter != g_func_map.end();
      ++fmiter) {
        fmiter->second->propagate_unsafe();
    }

#ifdef WIN32
    if(g_verbose) {
        printf("Determine function GC safety = %fs\n",StopTimer());
    }
    StartTimer();
#endif

    unsigned tarjan_index = 1, scc_number = 1;
    TarjanStack tarjan_stack;

    for(fmiter  = g_func_map.begin();
        fmiter != g_func_map.end();
      ++fmiter) {
        fmiter->second->tarjan(tarjan_index,tarjan_stack,scc_number);
    }

#ifdef WIN32
    if(g_verbose) {
        printf("Determine strongly connected components = %fs\n",StopTimer());
    }
    StartTimer();
#endif

    std::list<external_declaration *> pre_trans = tu_to_list(gen_pre_trans());
    g_ed_list.insert(g_ed_list.begin(),pre_trans.begin(),pre_trans.end());

    ed_iter = g_ed_list.begin();
#ifdef MULTITHREAD
    pthread_t tid;
    int procs = get_num_procs(), i;
    check_vector<pthread_t> tids;
    for(int i=0; i<procs; ++i) {
        pthread_create(&tid,NULL,translate_thread,&ed_iter);
        tids.push_back(tid);
    }
    for(int i=0; i<procs; ++i) {
        pthread_join(tids[i],NULL);
    }
#else
    while(ed_iter != g_ed_list.end()) {
        if(g_check_consistency) {
            (*(ed_iter))->check_consistency();
        }
//        (*(ed_iter))->print();
        (*(ed_iter++))->translate_pillar(NULL);
    }
#endif

#ifdef WIN32
    if(g_verbose) {
        float translate_time = StopTimer();
        printf("Translate = %fs\n",translate_time);
        printf("\tComputing liveness = %fs, %f%%\n",g_compute_liveness,100*g_compute_liveness/translate_time);
        printf("\tComputing ref conflicts = %fs, %f%%\n",g_compute_conflict_time,100*g_compute_conflict_time/translate_time);
        printf("\tOverall function translation = %fs, %f%%\n",g_function_translate,100*g_function_translate/translate_time);
    }
#endif

    std::list<external_declaration *> prepend_pillar = tu_to_list(gen_prepend_pillar());
    g_ed_list.insert(g_ed_list.begin(),prepend_pillar.begin(),prepend_pillar.end());

    if(g_verbose) {
        printf("Num total refs = %d\n",g_static_num_refs);
        printf("Num inactive refs = %d, %.2f\n",g_num_inactive_refs,(double)g_num_inactive_refs / (g_static_num_refs ? g_static_num_refs : 1));
    }
    unsigned num_actives = g_static_num_refs - g_num_inactive_refs;
    if(g_condensed_num_refs && g_verbose) {
        printf("Num condensed refs = %d, Ref compaction = %.2f\n",g_condensed_num_refs,(num_actives - g_condensed_num_refs) / (double)num_actives);
    }

    unsigned total_pdecl = g_safe_pdecl + g_unsafe_pdecl;

    if(g_verbose) {
        printf("GC Safe Functions   = %d, %.2f\n",g_safe_pdecl, (double)g_safe_pdecl / (total_pdecl ? total_pdecl : 1.0));
        printf("GC Unsafe Functions = %d, %.2f\n",g_unsafe_pdecl, (double)g_unsafe_pdecl / (total_pdecl ? total_pdecl : 1.0));

        unsigned total_calls = g_safe_calls + g_unsafe_calls;

        printf("GC Safe Calls       = %d, %.2f\n",g_safe_calls, (double)g_safe_calls / (total_calls ? total_calls : 1.0));
        printf("GC Unsafe Calls     = %d, %.2f\n",g_unsafe_calls, (double)g_unsafe_calls / (total_calls ? total_calls : 1.0));

        printf("Potentially unneeded nodes = %d\n",g_unneeded_nodes);
        printf("%d symbols created * %d = %d\n",g_num_id_info_created,sizeof(id_info),g_num_id_info_created*sizeof(id_info));
        printf("%d nodes created * %d = minimum %d\n",g_num_ast_node_created,sizeof(AST_node),g_num_ast_node_created*sizeof(AST_node));

        printf("scope data = %d\n",scope_data);

        printf("Tailcalls\n --------------\n");
        printf("Total = %d\n",g_tailcalls_translated);
        if(g_tailcalls_translated) {
            printf("Converted to normal calls = %d, %f%%\n",g_tailcalls_as_normal_calls,g_tailcalls_as_normal_calls*100.0/g_tailcalls_translated);
            printf("Kept as tail calls = %d, %f%%\n",g_tailcalls_as_tailcalls,g_tailcalls_as_tailcalls*100.0/g_tailcalls_translated);
            if(g_tailcalls_as_tailcalls) {
                printf("Tail calls using generic = %d, %f%%\n",g_tailcalls_non_topo,g_tailcalls_non_topo*100.0/g_tailcalls_as_tailcalls);
                printf("Tail calls using topographical sort = %d, %f%%\n",g_tailcalls_topo,g_tailcalls_topo*100.0/g_tailcalls_as_tailcalls);
                printf("Tail calls where parameters sizes are known = %d, %f%%\n",g_tailcalls_topo_known_params,g_tailcalls_topo_known_params*100.0/g_tailcalls_as_tailcalls);
                if(g_tailcalls_topo_known_params) {
                    printf("Tail calls where caller params >= callee params = %d, %f%%\n",g_tailcalls_topo_caller_large_enough,g_tailcalls_topo_caller_large_enough*100.0/g_tailcalls_topo_known_params);
                    if(g_tailcalls_topo_caller_large_enough) {
                        printf("Tail calls with topographical cycles broken = %d, %f%%\n",g_tailcalls_topo_cycles_broken,g_tailcalls_topo_cycles_broken*100.0/g_tailcalls_topo_caller_large_enough);
                    }
                }
            }
        }

#ifdef P2C_MEMORY_DEBUG
#ifdef _MSC_VER
#ifdef _DEBUG
        _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
        _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
        _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );

//        _CrtMemState cms;
//        _CrtMemCheckpoint(&cms);
//        _CrtMemDumpStatistics(&cms);
        _CrtMemDumpAllObjectsSince(NULL);
#endif
#endif
#endif
    }
}

AST_node * type_specifier_CHAR::vararg_clone(void) const {
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
}

AST_node * type_specifier_SHORT::vararg_clone(void) const {
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
}

AST_node * type_specifier_FLOAT::vararg_clone(void) const {
    type_specifier_DOUBLE *copy = new type_specifier_DOUBLE();
    copy->clone_copy(this);
    return copy;
}

AST_node * type_specifier_CHAR::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
#endif // __x86_64__
}

AST_node * type_specifier_SHORT::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
#endif // __x86_64__
}

AST_node * type_specifier_INT::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    return clone();
#endif // __x86_64__
}

AST_node * type_specifier_SIGNED::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    return clone();
#endif // __x86_64__
}

AST_node * type_specifier_UNSIGNED::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    return clone();
#endif // __x86_64__
}

AST_node * type_specifier_FLOAT::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_DOUBLE *copy = new type_specifier_DOUBLE();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    return clone();
#endif // __x86_64__
}

AST_node * type_specifier_INT32::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    return clone();
#endif // __x86_64__
}

AST_node * type_specifier_INT16::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
#endif // __x86_64__
}

AST_node * type_specifier_INT8::param_clone(void) const {
#ifdef __x86_64__
    type_specifier_LONG *copy = new type_specifier_LONG();
    copy->clone_copy(this);
    return copy;
#else  // __x86_64__
    type_specifier_INT *copy = new type_specifier_INT();
    copy->clone_copy(this);
    return copy;
#endif // __x86_64__
}

void statement_UUASM::create_call_graph(function_definition *fd) {
    assert(fd);
    fd->set_gc_unsafe();
}

void statement_UUASMUU::create_call_graph(function_definition *fd) {
    assert(fd);
    fd->set_gc_unsafe();
}

TranslateResult statement_UUASM::translate_pillar(function_definition *fd) {
    base_translate(fd);
    return TranslateResult();
}

TranslateResult statement_UUASMUU::translate_pillar(function_definition *fd) {
    base_translate(fd);
    return TranslateResult();
}

void statement_UASM::create_call_graph(function_definition *fd) {
    assert(fd);
    fd->set_gc_unsafe();
}

TranslateResult statement_UASM::translate_pillar(function_definition *fd) {
    base_translate(fd);
    return TranslateResult();
}

TranslateResult direct_declarator_direct_declarator_empty_paren::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    TRANSLATE(m_dd,tr);

    if(g_gcc_compatible) {
        AST_node *this_parent = get_parent();
        declarator *decl = dynamic_cast<declarator*>(this_parent);
        if(decl) {
            decl->proxy_explicit_call_conv();
        } else {
            get_parent()->get_parent()->print();
            printf("\n");
            aeprintf("Don't know how to handle non-declarator parent in direct_declarator_direct_declarator_empty_paren\n");
        }
    }

    if(get_call_conv() == ST_PDECL) {
//        if(cc_to_man_unman(get_call_conv()) == MU_MANAGED) {
        std::map<std::string,PILLAR_RUNTIME_FUNC_TYPE>::iterator iter;
        iter = g_pillar_runtime_funcs.find(m_dd->get_name());
        if(iter == g_pillar_runtime_funcs.end()) {
            std::map<std::string,function_definition *>::iterator fmiter;
            fmiter = g_func_map.find(m_dd->get_name());
            if(fmiter == g_func_map.end()) {
                parameter_list *extra_params = gen_extra_params();
                prepend_params(extra_params);
            } else {
                if(!fmiter->second->is_gc_safe()) {
                    parameter_list *extra_params = gen_extra_params();
                    prepend_params(extra_params);
                }
            }
        }
    }

    return tr;
}

TranslateResult parameter_type_list_parameter_list::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_pl,tr);

    return tr;
}

void ref_map::add_edge_if_conflict_range(unsigned start, unsigned end, check_vector<ref_info *> &vec_ri) {
    unsigned ref_index;

    // Create interference graph edges.
    for(ref_index = start; ref_index < end; ++ref_index) {
        unsigned conflict_index;

        if(!(m_refs[ref_index] && vec_ri[ref_index])) {
            continue;
        }

        for(conflict_index = ref_index+1; conflict_index < m_len; ++conflict_index) {
            if(m_refs[conflict_index] && vec_ri[conflict_index]) {
                vec_ri[ref_index]->add_edge(vec_ri[conflict_index]);
                vec_ri[conflict_index]->add_edge(vec_ri[ref_index]);
            }
        }
    }
}

void ref_map::add_edge_if_conflict(check_vector<ref_info *> &vec_ri) {
    unsigned ref_index;

    // Create interference graph edges.
    for(ref_index = 0; ref_index < m_len; ++ref_index) {
        unsigned conflict_index;

        if(!m_refs[ref_index] || !vec_ri[ref_index]) {
            continue;
        }

        for(conflict_index = ref_index+1; conflict_index < m_len; ++conflict_index) {
#if 0
            if(m_refs[ref_index] && m_refs[conflict_index] && (!vec_ri[ref_index] || !vec_ri[conflict_index])) {
                printf("some vec_ri was NULL\n");
            }
#endif
            if(m_refs[conflict_index] && vec_ri[conflict_index]) {
                vec_ri[ref_index]->add_edge(vec_ri[conflict_index]);
                vec_ri[conflict_index]->add_edge(vec_ri[ref_index]);
            }
        }
    }
}

declaration_specifiers * declaration_specifiers::add_noinline(void) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = NULL;

    if(g_gcc_compatible) {
        new_node =
            new declaration_specifiers_function_specifier_declaration_specifiers(
              new function_specifier_text("__attribute__((noinline))"),
              this);
    } else {
        new_node =
            new declaration_specifiers_function_specifier_declaration_specifiers(
              new function_specifier_uudeclspec_specifier(
                new declspec_specifier_NOINLINE()),
              this);
    }
    orig_parent->replace(this,new_node);
    return new_node;
}

#ifndef __x86_64__
declaration_specifiers * declaration_specifiers::add_no_regparm(void) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = NULL;

    if(g_gcc_compatible) {
        new_node =
            new declaration_specifiers_function_specifier_declaration_specifiers(
              new function_specifier_text("__attribute__((regparm(0)))"),
              this);
    } else {
        aeprintf("add_no_regparm not available when not in gcc mode.\n");
    }
    orig_parent->replace(this,new_node);
    return new_node;
}
#endif

declaration_specifiers * declaration_specifiers::add_volatile(void) {
    if(!is_volatile()) {
        declaration_specifiers *new_type_qual = new declaration_specifiers_type_qualifier(new type_qualifier_volatile());
        return append(new_type_qual);
    } else {
        return this;
    }
}

TranslateResult expression_statement_empty::translate_pillar(function_definition *fd) {
    statement_expression_statement *ses = dynamic_cast<statement_expression_statement *>(get_parent());
    if(!ses) return TranslateResult();

    block_item_statement *bis = dynamic_cast<block_item_statement *>(ses->get_parent());
    if(!bis) return TranslateResult();

    m_parent->sub_destroyed(this);
    return TranslateResult();
}

void statement_expression_statement::sub_destroyed(AST_node *node) {
    if(node == (AST_node*)m_s) {
        delete m_s;
        m_s = NULL;
        m_parent->sub_destroyed(this);
    } else {
        aeprintf("sub_destroyed\n");
    }
}

bool statement_labeled_statement::is_label(const char *label_name) {
    return m_s->is_label(label_name);
}

TranslateResult expression_statement_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_e,tr);

    return tr;
}

TranslateResult expression_assignment_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_ae,tr);

    if(g_prettify_code) {
        primary_expression_expression *exp = (primary_expression_expression*)m_ae->is_mainline(typeid(primary_expression_expression));
        if(exp) {
            expression *expr = exp->claim_expression();
            m_parent->replace(this,expr);
            delete this;
        }
    }

    return tr;
}

TranslateResult expression_postfix_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_pe,tr);

    if(g_prettify_code) {
        primary_expression_expression *exp = (primary_expression_expression*)m_pe->is_mainline(typeid(primary_expression_expression));
        if(exp) {
            expression *expr = exp->claim_expression();
            m_parent->replace(this,expr);
            delete this;
        }
    }

    return tr;
}

TranslateResult expression_mainline::translate_pillar(function_definition *fd) {
    TranslateResult tr;
    TRANSLATE(m_pe,tr);

    if(g_prettify_code) {
        primary_expression_expression *exp = (primary_expression_expression*)m_pe->is_mainline(typeid(primary_expression_expression));
        if(exp) {
            expression *expr = exp->claim_expression();
            m_parent->replace(this,expr);
            delete this;
        }
    }

    return tr;
}

bool expression_type::operator==(const expression_type &other) {
    if(*m_sql == other.m_sql) {
        if(m_ad && other.m_ad && *m_ad == other.m_ad) {
            return true;
        } else {
            if(m_ad == other.m_ad) {
                return true;
            } else {
                return false;
            }
        }
    } else {
        return false;
    }
}

expression_type::expression_type(const expression_type &other) {
    m_sql = (specifier_qualifier_list*)other.m_sql->clone();
    if(other.m_ad) {
        m_ad  = (abstract_declarator*)other.m_ad->clone();
    } else {
        m_ad = NULL;
    }
}

bool expression_type::is_void(void) {
    auto_ptr<expression_type> apet(get_base_type());
    if(apet->m_ad) return false;
    type_specifier *ts = apet->m_sql->get_type_specifier();
    if(!ts)  return false;
    if(dynamic_cast<type_specifier_VOID*>(ts) == NULL) {
        return false;
    } else {
        return true;
    }
}

bool expression_type::is_void_pointer(void) {
    auto_ptr<expression_type> apet(get_base_type());
    if(!apet->m_ad) return false;
    if(!apet->m_ad->is_pointer()) return false;
    type_specifier *ts = apet->m_sql->get_type_specifier();
    if(!ts)  return false;
    if(dynamic_cast<type_specifier_VOID*>(ts) == NULL) {
        return false;
    } else {
        return true;
    }
}

bool expression_type::is_pointer(void) {
    if(!m_ad) {
        type_specifier *ts = m_sql->get_type_specifier();
        if(ts->is_ultimate_prt_ref()) {
            return true;
        } else {
            return false;
        }
    }
    if(m_ad->is_pointer()) return true;
    else                   return false;
}

declaration * declaration_declaration_specifiers::clone(void) {
    declaration_declaration_specifiers *copy = new declaration_declaration_specifiers(m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

declaration * declaration_declaration_specifiers_init_declarator_list::clone(void) {
#ifndef BLAH
    declaration_declaration_specifiers_init_declarator_list *copy = new declaration_declaration_specifiers_init_declarator_list(m_ds->clone(),m_idl->clone(),m_before_s,m_au);
#else
    declaration_declaration_specifiers_init_declarator_list *copy = new declaration_declaration_specifiers_init_declarator_list(m_ds->clone(),m_idl->clone(),m_before_s,m_after_s);
#endif
    copy->clone_copy(this);
    return copy;
}

statement * statement_labeled_statement::clone(void) {
    statement_labeled_statement *copy = new statement_labeled_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_compound_statement::clone(void) {
    statement_compound_statement *copy = new statement_compound_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_PRT_NOYIELD_compound_statement::clone(void) {
    statement_PRT_NOYIELD_compound_statement *copy = new statement_PRT_NOYIELD_compound_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_PRT_VSE_compound_statement::clone(void) {
    statement_PRT_VSE_compound_statement *copy = new statement_PRT_VSE_compound_statement(m_ii, m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_expression_statement::clone(void) {
    statement_expression_statement *copy = new statement_expression_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_selection_statement::clone(void) {
    statement_selection_statement *copy = new statement_selection_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_pcall_call_expression::clone(void) {
    statement_pcall_call_expression *copy = new statement_pcall_call_expression(m_ce->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_iteration_statement::clone(void) {
    statement_iteration_statement *copy = new statement_iteration_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_jump_statement::clone(void) {
    statement_jump_statement *copy = new statement_jump_statement(m_s->clone());
    copy->clone_copy(this);
    return copy;
}

statement * statement_UUASM::clone(void) {
    statement_UUASM *copy = new statement_UUASM(m_asm);
    copy->clone_copy(this);
    return copy;
}

statement * statement_UUASMUU::clone(void) {
    statement_UUASMUU *copy = new statement_UUASMUU(m_asm);
    copy->clone_copy(this);
    return copy;
}

statement * statement_UASM::clone(void) {
    statement_UASM *copy = new statement_UASM(m_asm);
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_type_specifier::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_type_specifier(m_ts->clone());
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_type_specifier_declaration_specifiers::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_type_specifier_declaration_specifiers(m_ts->clone(),m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_type_qualifier::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_type_qualifier(m_tq->clone());
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_type_qualifier_declaration_specifiers::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_type_qualifier_declaration_specifiers(m_tq->clone(),m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_function_specifier::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_function_specifier(m_fs->clone());
    copy->clone_copy(this);
    return copy;
}

declaration_specifiers * declaration_specifiers_function_specifier_declaration_specifiers::clone(void) {
    declaration_specifiers *copy = new declaration_specifiers_function_specifier_declaration_specifiers(m_fs->clone(),m_ds->clone());
    copy->clone_copy(this);
    return copy;
}

init_declarator * init_declarator_declarator_initializer::clone(void) {
    init_declarator *copy = new init_declarator_declarator_initializer(m_d->clone(),m_i->clone());
    copy->clone_copy(this);
    return copy;
}

declarator * declarator_pointer_direct_declarator::clone(void) {
    declarator *copy = new declarator_pointer_direct_declarator(m_p->clone(),m_dd->clone(),m_s);
    copy->clone_copy(this);
    return copy;
}

declarator * declarator_pointer_call_conv_specifier_direct_declarator::clone(void) {
    declarator *copy = new declarator_pointer_call_conv_specifier_direct_declarator(m_p->clone(),m_ccs->clone(),m_dd->clone());
    copy->clone_copy(this);
    return copy;
}

declarator * declarator_call_conv_specifier_pointer_direct_declarator::clone(void) {
    declarator *copy = new declarator_call_conv_specifier_pointer_direct_declarator(m_ccs->clone(),m_p->clone(),m_dd->clone(),m_s);
    copy->clone_copy(this);
    return copy;
}

declarator * declarator_call_conv_specifier_direct_declarator::clone(void) {
    declarator *copy = new declarator_call_conv_specifier_direct_declarator(m_ccs->clone(),m_dd->clone(),m_s);
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_paren_declarator::clone(void) {
    direct_declarator *copy = new direct_declarator_paren_declarator(m_d->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_type_qualifier_list_assignment_expression(m_dd->clone(),m_tql->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_type_qualifier_list::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_type_qualifier_list(m_dd->clone(),m_tql->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_assignment_expression::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_assignment_expression(m_dd->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression(m_dd->clone(),m_tql->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression(m_dd->clone(),m_tql->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_type_qualifier_list_star::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_type_qualifier_list_star(m_dd->clone(),m_tql->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_parameter_type_list::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_parameter_type_list(m_dd->clone(),m_ptl->clone());
    copy->clone_copy(this);
    return copy;
}

direct_declarator * direct_declarator_direct_declarator_identifier_list::clone(void) {
    direct_declarator *copy = new direct_declarator_direct_declarator_identifier_list(m_dd->clone(),m_il->clone());
    copy->clone_copy(this);
    return copy;
}

assignment_expression * assignment_expression_unary_expression_assignment_operator_assignment_expression::clone(void) {
    assignment_expression *copy = new assignment_expression_unary_expression_assignment_operator_assignment_expression(m_ue->clone(),m_ao->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

parameter_list * parameter_list_parameter_declaration::clone(void) {
    parameter_list *copy = new parameter_list_parameter_declaration(m_pd->clone());
    copy->clone_copy(this);
    return copy;
}

parameter_list * parameter_list_parameter_list_parameter_declaration::clone(void) {
    parameter_list *copy = new parameter_list_parameter_list_parameter_declaration(m_pl->clone(),m_pd->clone());
    copy->clone_copy(this);
    return copy;
}

parameter_list * parameter_list_parameter_declaration::clone_abstract(void) {
    parameter_list *copy = new parameter_list_parameter_declaration(m_pd->clone_abstract());
    copy->clone_copy(this);
    return copy;
}

parameter_list * parameter_list_parameter_list_parameter_declaration::clone_abstract(void) {
    parameter_list *copy = new parameter_list_parameter_list_parameter_declaration(m_pl->clone_abstract(),m_pd->clone_abstract());
    copy->clone_copy(this);
    return copy;
}

initializer * initializer_initializer_list::clone(void) {
    initializer *copy = new initializer_initializer_list(m_il->clone());
    copy->clone_copy(this);
    return copy;
}

initializer * initializer_initializer_list_comma::clone(void) {
    initializer *copy = new initializer_initializer_list_comma(m_il->clone());
    copy->clone_copy(this);
    return copy;
}

initializer_list * initializer_list_designation_initializer::clone(void) {
    initializer_list *copy = new initializer_list_designation_initializer(m_d->clone(),m_i->clone());
    copy->clone_copy(this);
    return copy;
}

initializer_list * initializer_list_initializer_list_designation_initializer::clone(void) {
    initializer_list *copy = new initializer_list_initializer_list_designation_initializer(m_il->clone(),m_d->clone(),m_i->clone());
    copy->clone_copy(this);
    return copy;
}

parameter_declaration * parameter_declaration_declaration_specifiers_abstract_declarator::clone(void) {
    parameter_declaration *copy = new parameter_declaration_declaration_specifiers_abstract_declarator(m_ds->clone(),m_ad->clone());
    copy->clone_copy(this);
    return copy;
}

abstract_declarator * abstract_declarator_call_conv_specifier_direct_abstract_declarator::clone(void) {
    abstract_declarator *copy = new abstract_declarator_call_conv_specifier_direct_abstract_declarator(m_ccs->clone(),m_dad->clone());
    copy->clone_copy(this);
    return copy;
}

conditional_expression * conditional_expression_logical_or_expression_expression_conditional_expression::clone(void) {
    conditional_expression *copy = new conditional_expression_logical_or_expression_expression_conditional_expression(m_loe->clone(),m_e->clone(),m_ce->clone());
    copy->clone_copy(this);
    return copy;
}

cast_expression * cast_expression_type_name_cast_expression::clone(void) {
    cast_expression *copy = new cast_expression_type_name_cast_expression(m_tn->clone(),m_ce->clone());
    copy->clone_copy(this);
    return copy;
}

unary_expression * unary_expression_unary_operator_cast_expression::clone(void) {
    unary_expression *copy = new unary_expression_unary_operator_cast_expression(m_uo->clone(),m_ce->clone());
    copy->clone_copy(this);
    return copy;
}

unary_expression * unary_expression_sizeof_type_name::clone(void) {
    unary_expression *copy = new unary_expression_sizeof_type_name(m_tn->clone());
    copy->clone_copy(this);
    return copy;
}

type_name * type_name_specifier_qualifier_list_abstract_declarator::clone(void) {
    type_name *copy = new type_name_specifier_qualifier_list_abstract_declarator(m_sql->clone(),m_ad->clone());
    copy->clone_copy(this);
    return copy;
}

postfix_expression * postfix_expression_postfix_expression_brace_expression::clone(void) {
    postfix_expression *copy = new postfix_expression_postfix_expression_brace_expression(m_pe->clone(),m_e->clone());
    copy->clone_copy(this);
    return copy;
}

postfix_expression * postfix_expression_call_expression::clone(void) {
    postfix_expression *copy = new postfix_expression_call_expression(m_ce->clone());
    copy->clone_copy(this);
    return copy;
}

postfix_expression * postfix_expression_postfix_expression_paren_argument_expression_list::clone(void) {
    postfix_expression *copy = new postfix_expression_postfix_expression_paren_argument_expression_list(m_pe->clone(),m_ael->clone());
    copy->clone_copy(this);
    return copy;
}

postfix_expression * postfix_expression_type_name_initializer_list::clone(void) {
    postfix_expression *copy = new postfix_expression_type_name_initializer_list(m_tn->clone(),m_il->clone());
    copy->clone_copy(this);
    return copy;
}

postfix_expression * postfix_expression_type_name_initializer_list_comma::clone(void) {
    postfix_expression *copy = new postfix_expression_type_name_initializer_list_comma(m_tn->clone(),m_il->clone());
    copy->clone_copy(this);
    return copy;
}

call_expression * call_expression_postfix_expression_paren_argument_expression_list::clone(void) {
    call_expression *copy = new call_expression_postfix_expression_paren_argument_expression_list(m_pe->clone(),m_ael->clone());
    copy->clone_copy(this);
    return copy;
}

argument_expression_list * argument_expression_list_assignment_expression::clone(void) {
    argument_expression_list *copy = new argument_expression_list_assignment_expression(m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

argument_expression_list * argument_expression_list_argument_expression_list_assignment_expression::clone(void) {
    argument_expression_list *copy = new argument_expression_list_argument_expression_list_assignment_expression(m_ael->clone(),m_ae->clone());
    copy->clone_copy(this);
    return copy;
}

primary_expression * primary_expression_expression::clone(void) {
    primary_expression *copy = new primary_expression_expression(m_e->clone());
    copy->clone_copy(this);
    return copy;
}

statement_compound_statement * statement_compound_statement::prepend_bil(block_item_list *bil) {
    m_s = m_s->prepend_bil(bil);
    return this;
}

statement * statement::prepend_bil(block_item_list *bil) {
    AST_node * parent = m_parent;

    statement_compound_statement *new_node =
        new statement_compound_statement(
          new compound_statement_block_item_list(
            new block_item_list_block_item_list_block_item(
              bil,
              new block_item_statement(this,0))));

    parent->replace(this,new_node);
    return new_node;
}

AST_node * AST_node::prepend_bil(block_item_list *bil) {
    if(m_parent) {
        return m_parent->prepend_bil(bil);
    } else {
        print();
        bil->print();
        aeprintf("AST_node::prepend_bil block item list not found to insert before %s.\n",typeid(*this).name());
    }
}

void basic_block::final_backtrace(unsigned num_total_refs, unsigned *old_new_ref_map, unsigned &condensed_refs, ii_ptr *orig_id_index, const std::string &func_params, const ref_map &active_rare, bool ref_params_in_pseudo) {
    if(m_backtrace_complete) {
        return;
    }

    m_backtrace_complete = true;

    std::map<unsigned,std::string> hoist_union;
    if(g_loop_hoists) {
    std::set<loop *>::iterator liter;
    for(liter  = m_in_loops.begin();
        liter != m_in_loops.end();
      ++liter) {
        std::set<unsigned>::iterator hoist_select_iter;

        for(hoist_select_iter  = (*liter)->m_hoisting_selections.begin();
            hoist_select_iter != (*liter)->m_hoisting_selections.end();
          ++hoist_select_iter) {
            std::stringstream hoist_buf;
            hoist_buf << "_pillar2c_hoist_" << (*liter)->m_header->get_unique() << "_" << orig_id_index[*hoist_select_iter]->get_ref_field_name();
            std::pair<std::map<unsigned,std::string>::iterator,bool> res =
                hoist_union.insert(std::pair<unsigned,std::string>(*hoist_select_iter,hoist_buf.str()));
            assert(res.second);
        }
    }
    }

    // Walk backwards through the refs and function calls in this basic block and update
    // the state map appropriately and create the call site masks of lives refs.
    size_t this_block_refs;
    for(this_block_refs = m_live_refs_here.size();
        this_block_refs > 0;
      --this_block_refs) {
        m_live_refs_here[this_block_refs - 1]->final_backtrace(num_total_refs, old_new_ref_map, condensed_refs, orig_id_index, func_params, active_rare, hoist_union, ref_params_in_pseudo);
    }

    unsigned follow_index;
    for(follow_index = 0; follow_index < m_can_follow.size(); ++follow_index) {
        m_can_follow[follow_index]->final_backtrace(num_total_refs, old_new_ref_map, condensed_refs, orig_id_index, func_params, active_rare, ref_params_in_pseudo);
    }
}

type_specifier_continuation::type_specifier_continuation(continuation_var_type *cvt) : m_post_translate(g_translation_started), m_cvt(cvt) {
    if(m_cvt) {
        m_cvt->set_parent(this);
    }
    m_unique = g_unique_id++;
}

type_specifier * type_specifier_continuation::clone(void) const {
    type_specifier_continuation *copy = new type_specifier_continuation(m_cvt ? m_cvt->clone() : NULL);
    copy->clone_copy(this);
    return copy;
}

void id_info::delete_it(void) {
    if(m_type_owned) {
        AST_node *temp = type_or_lsi.m_type;
        type_or_lsi.m_type = NULL;
        m_type_owned = false;
        delete temp;
    } else {
        delete this;
    }
}

id_info::~id_info(void) {
    if(two_phase) {
        --num_ii;
        size_ii -= sizeof(*this);
        g_iis.erase(this);
    }

    if(get_string() == DEBUG_FUNC) {
        printf("Destroying symbol %s\n",DEBUG_FUNC);
    }
//  printf("Destroying %s for %p\n",get_name(),this);
    if(m_type_owned) {
        if(type_or_lsi.m_type->get_ii() != this) {
            aeprintf("Circular non-matching.\n");
        }
        type_or_lsi.m_type->set_ii(NULL);
        delete type_or_lsi.m_type;
    }
    if(m_scope) {
        m_scope->erase(get_string());
    }
}

type_specifier_continuation::~type_specifier_continuation(void) {
    delete m_cvt;
}

call_expression::call_expression(identifier_list *il) {
    if(il) {
        il->flatten(m_id_vec);
        delete il;
    }
    m_unique = g_unique_id++;
}

call_expression::~call_expression(void) {
}

void call_expression::add_vse_continuations_to_cuts(function_definition *fd) {
    AST_node *cur_node = this;
    while(cur_node && cur_node != (AST_node *)fd) {
        statement_PRT_VSE_compound_statement *vse_stmt = dynamic_cast<statement_PRT_VSE_compound_statement *>(cur_node);
        if(vse_stmt) {
            m_id_vec.push_back(vse_stmt->get_continuation_id());
        }
        cur_node = cur_node->get_parent();
    }
}

std::set<unsigned> g_cut_filters;

void statement::generate_filters(function_definition *fd) {
    if(!m_cuts_to.size()) return;

    if(!g_use_try_except) return;

    if(g_cut_filters.find(m_cuts_to.size()) == g_cut_filters.end()) {
        g_cut_filters.insert(m_cuts_to.size());

        std::stringstream filter;

        filter << "int _pillar2c_filter_" << m_cuts_to.size() << "(unsigned int code, struct _EXCEPTION_POINTERS *ep, void **except_var";
        size_t cut_index;
        for(cut_index = 0; cut_index < m_cuts_to.size(); ++cut_index) {
            filter << ", void * cont" << cut_index;
        }
        filter << ") {\n";
        filter << "if (code == 1) {\n";
        filter << "*except_var = (void*)ep->ExceptionRecord->ExceptionInformation[0];\n";

        filter << "if(*except_var == cont0";
        for(cut_index = 1; cut_index < m_cuts_to.size(); ++cut_index) {
            filter << " || *except_var == cont" << cut_index;
        }
        filter << ") {\n";
        filter << "return 1;\n";
        filter << "} else {\n";
        filter << "return 0;\n";
        filter << "}\n";

        filter << "} else {\n";
        filter << "return 0;\n";
        filter << "}\n";
        filter << "}\n";

        external_declaration *ed =
            new external_declaration_emit_text(filter.str());

        fd->insert_before_top_level(ed);
    }
}

void block_item_list_block_item::remove_and_delete(void) {
    block_item_list_block_item_list_block_item *bilbilbi = dynamic_cast<block_item_list_block_item_list_block_item *>(get_parent());
    if(bilbilbi) {
        AST_node * bilbilbi_parent = bilbilbi->get_parent();
        block_item *bi_to_delete = m_bi;
        replace(m_bi, bilbilbi->m_bi);
        delete bi_to_delete;
        bilbilbi->m_bi = NULL;
        bilbilbi->m_bil = NULL;
        bilbilbi_parent->replace(bilbilbi,this);
        delete bilbilbi;
    } else {
        aeprintf("block_item_list_block_item::remove_and_delete not implemented.\n");
    }
}

void id_info::move_label_to_function_scope(void) {
    ii_ptr temp(this);
    if(m_scope->is_function()) {
        return; // already in function scope
    }
    m_scope->remove_symbol(this);
    Scope * up_scope = m_scope->get_parent_scope();
    while(up_scope && !up_scope->is_function()) {
        up_scope = up_scope->get_parent_scope();
    }
    if(up_scope) {
        up_scope->add_symbol(this);
    } else {
        aeprintf("move_label_to_function_scope didn't find a function scope.\n");
    }
}

void block_item_declaration::split_initializer(void) {
    declaration_declaration_specifiers_init_declarator_list *ddsidl = dynamic_cast<declaration_declaration_specifiers_init_declarator_list *>(m_d);
    if(ddsidl) {
        init_declarator_list_init_declarator *idlid = dynamic_cast<init_declarator_list_init_declarator *>(ddsidl->get_init_declarator_list());
        if(idlid) {
            init_declarator_declarator_initializer *iddi = dynamic_cast<init_declarator_declarator_initializer *>(idlid->get_init_declarator());
            if(iddi) {
                initializer_assignment_expression *iae = dynamic_cast<initializer_assignment_expression *>(iddi->get_initializer());
                if(iae) {
                    assignment_expression *owned_ae = iae->claim_assignment_expression();

                    declarator *new_decl = iddi->get_declarator();
                    std::list<ii_ptr > decl_ii = new_decl->get_enclosing_symbols();
                    assert(decl_ii.size() == 1);

                    block_item_statement *bis =
                        new block_item_statement(
                          new statement_expression_statement(
                            new expression_statement_expression(
                              new expression_assignment_expression(
                                new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                                  expr_gen(unary_expression,primary_expression,
                                    new primary_expression_identifier(decl_ii.front())),
                                  new assignment_operator_equal(),
                                  owned_ae)))),0);

                    owned_ae->add_to_statement_cut(m_cuts_to);

                    block_item_list_block_item *new_bilbi = new block_item_list_block_item(bis);
                    block_item_list *bil_parent = dynamic_cast<block_item_list *>(get_parent());
                    if(bil_parent) {
                        bil_parent->append(new_bilbi);
                    } else {
                        aeprintf("block_item_declaration NULL\n");
                    }

                    iddi->sub_destroyed(iae);
                } else {
                    aeprintf("block_item_declaration iae NULL\n");
                }
            } else {
                aeprintf("block_item_declaration idlid NULL\n");
            }
        } else {
            aeprintf("block_item_declaration idlid NULL\n");
        }
    } else {
        aeprintf("block_item_declaration ddsidl NULL\n");
    }
}

TranslateResult block_item_declaration::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    TRANSLATE(m_d,tr);

    if(m_should_split) {
        split_initializer();
    }

    return tr;
}

switch_scope_on_return::~switch_scope_on_return(void) {
    m_fd->set_cur_basic_block(m_bb);
}

ts_comma_list_ts::ts_comma_list_ts(type_name *tn) : m_tn(tn) {
    m_tn->set_parent(this);
}

ts_comma_list_ts_ts_comma_list::ts_comma_list_ts_ts_comma_list(type_name *tn, ts_comma_list *tscl) : m_tn(tn), m_tscl(tscl) {
    m_tn->set_parent(this);
    m_tscl->set_parent(this);
}

multiple_ret_value_ts::multiple_ret_value_ts(type_name *tn, ts_comma_list *tscl) : m_tn(tn), m_tscl(tscl) {
    m_tn->set_parent(this);
    m_tscl->set_parent(this);
}

std::ostream & type_name_specifier_qualifier_list_abstract_declarator::strprint(std::ostream &os) const {
    m_sql->strprint(os);
    os << " ";
    return m_ad->strprint(os);
}

std::ostream & abstract_declarator_direct_abstract_declarator::strprint(std::ostream &os) const {
    return m_dad->strprint(os);
}

std::ostream & abstract_declarator_pointer_direct_abstract_declarator::strprint(std::ostream &os) const {
    m_p->strprint(os);
    return m_dad->strprint(os);
}

std::ostream & abstract_declarator_call_conv_specifier_direct_abstract_declarator::strprint(std::ostream &os) const {
    m_ccs->strprint(os);
    os << " ";
    return m_dad->strprint(os);
}

std::ostream & abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::strprint(std::ostream &os) const {
    m_ccs->strprint(os);
    os << " ";
    m_p->strprint(os);
    os << " ";
    return m_dad->strprint(os);
}

std::ostream & pointer_star_type_qualifier_list::strprint(std::ostream &os) const {
    return m_tql->strprint(os);
}

std::ostream & pointer_star_type_qualifier_list_pointer::strprint(std::ostream &os) const {
    m_tql->strprint(os);
    return m_p->strprint(os);
}

TranslateResult multiple_ret_expr_assignment_expression_assignment_expression_list::translate_pillar(function_definition *fd) {
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(!cur_bb) return TranslateResult();

    basic_block *ret_bb = get_return_target();
    assert(ret_bb);

    add_flow_graph_edge(cur_bb, ret_bb, EDGE_RETURN);

    // ----------------------------------------------------------------------------------------

    jump_statement *js_parent = dynamic_cast<jump_statement*>(get_parent());
    if(!js_parent) {
        aeprintf("jump_statement expected as parent but not found.\n");
    }
    statement *s_grandparent  = dynamic_cast<statement*>(js_parent->get_parent());
    if(!s_grandparent) {
        aeprintf("statement expected as grandparent but not found.\n");
    }

    std::stringstream temp_name;
    temp_name << "return_temp_" << this->get_unique();
    ii_ptr temp_ii = g_scope_stack.find_or_add(temp_name.str());

    std::string ret_type_name;
    ret_type_name = "ret_type_" + fd->get_symbol()->get_string();

    block_item_list *mre_translation = NULL;

    mre_translation =
        new block_item_list_block_item(
          new block_item_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(ret_type_name))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(temp_ii))))),0));

    check_vector<assignment_expression *> flat_ae;
    flatten(flat_ae);

    if(flat_ae.size() != fd->m_mrv_vec.size()) {
        aeprintf("Mismatch between multiple return value and multiple return statement.\n");
    }

    unsigned ts_num;
    for(ts_num = 0; ts_num < fd->m_mrv_vec.size(); ++ts_num) {
        std::stringstream field_name;
        field_name << "part" << ts_num;

        flat_ae[ts_num]->get_parent()->replace(flat_ae[ts_num],NULL);

        mre_translation =
          new block_item_list_block_item_list_block_item(
            mre_translation,
            new block_item_statement(
              new statement_expression_statement(
                new expression_statement_expression(
                  new expression_assignment_expression(
                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                      new unary_expression_postfix_expression(
                        new postfix_expression_postfix_expression_dot_identifier(
                          new postfix_expression_primary_expression(
                            new primary_expression_identifier(temp_ii)),
                          field_name.str())),
                      new assignment_operator_equal(),
                      flat_ae[ts_num])))),0));
        TranslateResult tr;
        TRANSLATE(flat_ae[ts_num],tr);
    }

    mre_translation =
        new block_item_list_block_item_list_block_item(
          mre_translation,
          new block_item_statement(
            cur_bb->add_item(new statement_jump_statement(
              new jump_statement_return_expression(
                new expression_assignment_expression(
                  expr_gen(assignment_expression,primary_expression,new primary_expression_identifier(temp_ii)))))),0));

    statement_compound_statement *new_node =
        new statement_compound_statement(new compound_statement_block_item_list(mre_translation));

    s_grandparent->replace(js_parent,new_node);

    fd->set_cur_basic_block(NULL);

    delete js_parent;

    return TranslateResult();
}

assignment_expression_multiple_ret_expr_equal_postfix_expression::assignment_expression_multiple_ret_expr_equal_postfix_expression(multiple_ret_expr *mre, postfix_expression *pe) : m_mre(mre), m_pe(pe) {
    m_mre->set_parent(this);
    m_pe->set_parent(this);
    m_unique = g_unique_id++;
}

TranslateResult assignment_expression_multiple_ret_expr_equal_postfix_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    postfix_expression_call_expression *pece = dynamic_cast<postfix_expression_call_expression *>(m_pe);
    if(!pece) {
        aeprintf("Postfix expression should contain a call expression in assignment expression mutlilpe ret expr.\n");
    }
    auto_ptr<expression_type> et(m_pe->get_type());

    TRANSLATE(m_pe,tr);

    bool is_bi_stmt_grandparent = false;

    AST_node *parent = dynamic_cast<AST_node*>(get_parent());
    if(!parent) {
        aeprintf("AST_node expected as parent but not found.\n");
    }

    expression *expr_parent = dynamic_cast<expression*>(get_parent());
    expression_statement *es = NULL;
    statement *old_stmt = NULL;
    block_item *bi = NULL;
    if(expr_parent) {
        es = dynamic_cast<expression_statement*>(expr_parent->get_parent());
        if(es) {
            old_stmt = dynamic_cast<statement*>(es->get_parent());
            if(old_stmt) {
                bi = dynamic_cast<block_item*>(old_stmt->get_parent());
                if(bi) {
                    is_bi_stmt_grandparent = true;
                }
            }
        }
    }

    type_specifier  *ts = et->m_sql->get_type_specifier();
    type_specifier_TYPE_NAME *tstn = dynamic_cast<type_specifier_TYPE_NAME*>(ts);
    if(!tstn) {
        aeprintf("Multiple return expression for call which does not return a type.\n");
    }
    ii_ptr tn_ii = tstn->get_id_info();
    if(!tn_ii->is_struct_enum()) {
        aeprintf("Multiple return expression for call which does not return a struct.\n");
    }
    Scope *struct_scope = tn_ii->get_struct_scope();
    if(!struct_scope) {
        aeprintf("struct_scope is NULL in assignment_expression_multiple_ret_expr_equal_postfix_expression\n");
    }

/*
    std::map<std::string,id_info*>::iterator miter;
    for(miter  = field_scope->begin();
        miter != field_scope->end();
        miter++) {

        ii_ptr ii = miter->second;
        if(!ii->is_var()) continue;

        declarator *iid = ii->get_declarator();
        assert(iid);

        if(iid->declares_name(m_id.c_str())) {
            type_specifier *ts = ii->get_type();
            assert(ts);
            specifier_qualifier_list *sql = dynamic_cast<specifier_qualifier_list*>(ts->get_parent());
            assert(sql);

            expression_type *ret = new expression_type;

            ret->m_sql = (specifier_qualifier_list*)sql->clone();
            ret->m_ad  = iid->gen_abstract_declarator();

            return ret;
        }
    }
*/

    std::stringstream temp_name;
    temp_name << "return_temp_" << this->get_unique();
    ii_ptr temp_ii = g_scope_stack.find_or_add(temp_name.str());

    std::string ret_type_name;
    ret_type_name = tn_ii->get_string();

    block_item_list *mre_translation = NULL;

    mre_translation =
        new block_item_list_block_item(
          new block_item_declaration(
            new declaration_declaration_specifiers_init_declarator_list(
              new declaration_specifiers_type_specifier(
                new type_specifier_TYPE_NAME(g_scope_stack.find_or_add(ret_type_name))),
              new init_declarator_list_init_declarator(
                new init_declarator_declarator(
                  new declarator_direct_declarator(
                    new direct_declarator_IDENTIFIER(temp_ii))))),0));

    check_vector<assignment_expression *> flat_ae;
    m_mre->flatten(flat_ae);

    if(flat_ae.size() != struct_scope->size()) {
        aeprintf("Mismatch between size of multiple return expression and return value of call expression.\n");
    }

    mre_translation =
        new block_item_list_block_item_list_block_item(
          mre_translation,
          new block_item_statement(
            new statement_expression_statement(
              new expression_statement_expression(
                new expression_assignment_expression(
                  new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                    expr_gen(unary_expression,primary_expression,new primary_expression_identifier(temp_ii)),
                    new assignment_operator_equal(),
                    expr_gen(assignment_expression,postfix_expression,m_pe))))),0));

    unsigned ts_num;
    for(ts_num = 0; ts_num < flat_ae.size(); ++ts_num) {
        std::stringstream field_name;
        field_name << "part" << ts_num;

        cast_expression_unary_expression *ceue = (cast_expression_unary_expression*)flat_ae[ts_num]->is_mainline(typeid(cast_expression_unary_expression));
        if(!ceue) {
            aeprintf("Left-hand side of multiple ret assignments must be unary expression.\n");
        }
        unary_expression *ue = ceue->get_ue();
        ue->get_parent()->replace(ue,NULL);

        mre_translation =
          new block_item_list_block_item_list_block_item(
            mre_translation,
            new block_item_statement(
              new statement_expression_statement(
                new expression_statement_expression(
                  new expression_assignment_expression(
                    new assignment_expression_unary_expression_assignment_operator_assignment_expression(
                      ue,
                      new assignment_operator_equal(),
                      expr_gen(assignment_expression,postfix_expression,
                        new postfix_expression_postfix_expression_dot_identifier(
                          new postfix_expression_primary_expression(
                            new primary_expression_identifier(temp_ii)),
                          field_name.str())))))),0));
        TranslateResult ue_tr;
        TRANSLATE(ue,ue_tr);
    }

    statement_compound_statement *new_node =
        new statement_compound_statement(new compound_statement_block_item_list(mre_translation));

    m_pe = NULL;

    if(is_bi_stmt_grandparent) {
        bi->replace(old_stmt,new_node);
        delete old_stmt;
        throw done(bi);
    } else {
        aeprintf("Need to fix this.\n");
        parent->replace(this, new_node);
        delete this;
    }

    // FIX FIX FIX
    aeprintf("type problem\n");
    return TranslateResult();
}

AST_node * struct_or_union_specifier_struct_or_union_struct_declaration_list::clone(void) const {
    struct_or_union_specifier_struct_or_union_struct_declaration_list *copy = new struct_or_union_specifier_struct_or_union_struct_declaration_list(m_sou->clone(),m_sdl->clone());
    copy->clone_copy(this);
    return copy;
}

AST_node * struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list::clone(void) const {
    struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list *copy =
        new struct_or_union_specifier_struct_or_union_identifier_struct_declaration_list(m_sou->clone(),m_id,m_sdl->clone(),false);
    copy->clone_copy(this);
    return copy;
}

struct_declaration_list_struct_declaration * struct_declaration_list_struct_declaration::clone(void) const {
    struct_declaration_list_struct_declaration *copy = new struct_declaration_list_struct_declaration(m_sd->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declaration_list_struct_declaration_list_struct_declaration * struct_declaration_list_struct_declaration_list_struct_declaration::clone(void) const {
    struct_declaration_list_struct_declaration_list_struct_declaration *copy = new struct_declaration_list_struct_declaration_list_struct_declaration(m_sdl->clone(), m_sd->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declaration_list_anonymous_struct_declaration * struct_declaration_list_anonymous_struct_declaration::clone(void) const {
    struct_declaration_list_anonymous_struct_declaration *copy = new struct_declaration_list_anonymous_struct_declaration(m_sd->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declaration_list_struct_declaration_list_anonymous_struct_declaration * struct_declaration_list_struct_declaration_list_anonymous_struct_declaration::clone(void) const {
    struct_declaration_list_struct_declaration_list_anonymous_struct_declaration *copy = new struct_declaration_list_struct_declaration_list_anonymous_struct_declaration(m_sdl->clone(), m_sd->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declaration_specifier_qualifier_list_struct_declarator_list * struct_declaration_specifier_qualifier_list_struct_declarator_list::clone(void) const {
    struct_declaration_specifier_qualifier_list_struct_declarator_list * copy = new struct_declaration_specifier_qualifier_list_struct_declarator_list(m_sql->clone(),m_sdl->clone());
    copy->clone_copy(this);
    return copy;
}

anonymous_struct_declaration_specifier_qualifier_list * anonymous_struct_declaration_specifier_qualifier_list::clone(void) const {
    anonymous_struct_declaration_specifier_qualifier_list * copy = new anonymous_struct_declaration_specifier_qualifier_list(m_sql->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declarator_list_struct_declarator * struct_declarator_list_struct_declarator::clone(void) const {
    struct_declarator_list_struct_declarator * copy = new struct_declarator_list_struct_declarator(m_sd->clone());
    copy->clone_copy(this);
    return copy;
}

struct_declarator_list_struct_declarator_list_struct_declarator * struct_declarator_list_struct_declarator_list_struct_declarator::clone(void) const {
    struct_declarator_list_struct_declarator_list_struct_declarator * copy = new struct_declarator_list_struct_declarator_list_struct_declarator(m_sdl->clone(),m_sd->clone());
    copy->clone_copy(this);
    return copy;
}


void insert_read_barrier(postfix_expression *pe) {
    AST_node *up_one = pe->get_parent();
    assert(up_one);

    postfix_expression_call_expression *pece =
      new postfix_expression_read_stats(
        new call_expression_postfix_expression_paren_argument_expression_list(
          new postfix_expression_primary_expression(
            new primary_expression_identifier(g_scope_stack.find_or_add("gc_heap_object_read_stats"))
            ),
            new argument_expression_list_assignment_expression(
            expr_gen(assignment_expression,postfix_expression,pe)
          )
        )
      );
    up_one->replace(pe,pece);
}

TranslateResult postfix_expression_postfix_expression_dot_identifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    TRANSLATE(m_pe,tr);

    if(g_expression_type) {
#ifndef USE_IS_LVALUE
        LRB_VALUE lrb_res = get_parent()->get_lrb_value(this,NULL);
        bool res_lvalue;
        if(lrb_res == LRB_LVALUE || lrb_res == LRB_LRVALUE) {
            res_lvalue = true;
        } else {
            res_lvalue = false;
        }
#else
        bool res_lvalue = get_parent()->is_lvalue(this,NULL);
#endif

        auto_ptr<expression_type> et(m_pe->get_type());

        if(!res_lvalue &&
            et->m_sql->get_type_specifier()->is_ultimate_prt_ref() &&
            g_collect_read_stats) {
            insert_read_barrier(m_pe);
        }

        auto_ptr<expression_type> apet(get_type()); TranslateResult gttr(apet); return gttr;
    } else {
        return TranslateResult();
    }
}

TranslateResult postfix_expression_postfix_expression_ptr_op_identifier::translate_pillar(function_definition *fd) {
    TranslateResult tr;

    TRANSLATE(m_pe,tr);

    if(g_expression_type) {
#ifndef USE_IS_LVALUE
        LRB_VALUE lrb_res = get_parent()->get_lrb_value(this,NULL);
        bool res_lvalue;
        if(lrb_res == LRB_LVALUE || lrb_res == LRB_LRVALUE) {
            res_lvalue = true;
        } else {
            res_lvalue = false;
        }
#else
        bool res_lvalue = get_parent()->is_lvalue(this,NULL);
#endif

        auto_ptr<expression_type> et(m_pe->get_type());

        if(!res_lvalue &&
            et->m_sql->get_type_specifier()->is_ultimate_prt_ref() &&
            g_collect_read_stats) {
            insert_read_barrier(m_pe);
        }

        auto_ptr<expression_type> apet(get_type()); TranslateResult gttr(apet); return gttr;
    } else {
        return TranslateResult();
    }
}

expression_type * postfix_expression_read_stats::get_type(void) {
    call_expression_postfix_expression_paren_argument_expression_list *ttt = dynamic_cast<call_expression_postfix_expression_paren_argument_expression_list *>(m_ce);
    argument_expression_list_assignment_expression *ael = dynamic_cast<argument_expression_list_assignment_expression *>(ttt->get_ael());
    assert(ael);
    assignment_expression *ae = ael->get_ae();
    return ae->get_type();
}

AST_node * unary_expression_unary_operator_cast_expression::ref_used(void) {
    if(dynamic_cast<unary_operator_and*>(m_uo)) {
        return NULL;
    } else if(dynamic_cast<unary_operator_star*>(m_uo)) {
//        print();
        return this;
    } else {
        return NULL;
    }
}

void id_info::set_func_definition(function_definition *fd) {
    if(!m_function) {
        ii_ptr ii;
        aeprintf("Internal pillar2c error: tried to set the function definition for a non-function symbol = %s.\n",(ii = fd->get_symbol()) ? ii->get_name() : "<invalid symbol>");
    }
    if(m_fd) {
        ii_ptr ii;
        aeprintf("Possible re-implementation of function %s.\n",(ii = m_fd->get_symbol()) ? ii->get_name() : "<invalid symbol>");
    }
    m_fd = fd;
    fd->set_ii(this);
}

void id_info::set_func_decl(direct_declarator *decl) {
    if(!(m_function || m_function_var)) {
        aeprintf("Internal pillar2c error: tried to set the function declaration for a non-function symbol = %s.\n",get_name());
    }
    m_func_decl = decl;
    decl->set_ii(this);
}

void id_info::set_type(type_specifier *ts, bool type_owned) {
    if(!(m_var || m_param || m_continuation || m_function_var)) {
        aeprintf("Attempt to set the type of a symbol that isn't a var or param.\n");
    }
    type_or_lsi.m_type = ts;
    m_type_owned = type_owned;
    ts->set_ii(this);
}

void id_info::set_labeled_statement(labeled_statement_identifier *lsi) {
    assert(m_label);
    type_or_lsi.m_lsi = lsi;
}

void id_info::set_declarator(declarator *d) {
#ifdef SINGLE_DECLARATOR
    m_d = d;
#else
    m_d.push_back(d);
#endif
    d->set_ii(this);
}

void id_info::set_parameter_declaration(parameter_declaration *pd) {
    assert(m_param);
    assert(!m_param_decl);
    m_param_decl = pd;
    pd->set_ii(this);
}

void id_info::replace(AST_node *old_node,AST_node *new_node) {
    assert(old_node);
    assert(new_node);

    if(old_node == m_fd) {
        m_fd = dynamic_cast<function_definition*>(new_node);
        assert(m_fd);
    } else if(old_node == m_func_decl) {
        m_func_decl = dynamic_cast<direct_declarator*>(new_node);
        assert(m_func_decl);
    } else if(old_node == type_or_lsi.m_type) {
        type_or_lsi.m_type = dynamic_cast<type_specifier*>(new_node);
        assert(type_or_lsi.m_type);
    } else if(old_node == m_param_decl) {
        m_param_decl = dynamic_cast<parameter_declaration*>(new_node);
        assert(m_param_decl);
    } else {
#ifdef SINGLE_DECLARATOR
        if(old_node == m_d) {
            m_d = dynamic_cast<declarator*>(new_node);
            assert(m_d);
            return;
        }
#else
        std::list<declarator*>::iterator decl_iter;
        for(decl_iter  = m_d.begin();
            decl_iter != m_d.end();
            decl_iter++) {
            if(*decl_iter == old_node) {
                m_d.erase(decl_iter);
                declarator *m_new_d = dynamic_cast<declarator*>(new_node);
                assert(m_new_d);
                m_d.push_back(m_new_d);
                return;
            }
        }
#endif

        aeprintf("id_info::replace old_node not found.\n");
    }
}
expression_type * determine_type_numeric_binary_operation(auto_ptr<expression_type> a,auto_ptr<expression_type> b) {
    if(a.get() && b.get()) {
        assert(a->m_ad == NULL || b->m_ad == NULL);
        if(a->m_ad) {
            return a->clone();
        } else if (b->m_ad) {
            return b->clone();
        }

        type_specifier *ts1 = a->m_sql->get_type_specifier()->get_base_type();
        type_specifier *ts2 = b->m_sql->get_type_specifier()->get_base_type();
        assert(ts1->is_int_type() || ts1->is_float_type());
        assert(ts2->is_int_type() || ts2->is_float_type());

        expression_type *ret = new expression_type;
        ret->m_ad = NULL;

        if(ts1->is_float_type()) {
            if(ts2->is_float_type()) {
                if(ts1->get_minimum_size() > ts2->get_minimum_size()) {
                    ret->m_sql = a->m_sql->clone();
                } else {
                    ret->m_sql = b->m_sql->clone();
                }
            } else {
                ret->m_sql = a->m_sql->clone();
            }
        } else if(ts2->is_float_type()) {
            ret->m_sql = b->m_sql->clone();
        } else {  // both must be int types
            if(ts1->get_minimum_size() > ts2->get_minimum_size()) {
                ret->m_sql = a->m_sql->clone();
            } else {
                ret->m_sql = b->m_sql->clone();
            }
        }
        return ret;
    } else {
        aeprintf("type problem\n");
    }
}

TranslateResult multiplicative_expression_multiplicative_expression_times_cast_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_me,tr1);
    TRANSLATE(m_ce,tr2);

    if(g_expression_type) {
        return TranslateResult(auto_ptr<expression_type>(determine_type_numeric_binary_operation(tr1.m_et,tr2.m_et)));
    } else {
        return tr1;
    }
}

TranslateResult additive_expression_additive_expression_plus_multiplicative_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ae,tr1);
    TRANSLATE(m_me,tr2);

    if(g_expression_type) {
        if(tr1.m_et.get() && tr2.m_et.get()) {
            if(tr1.m_et->m_ad && tr2.m_et->m_ad) {
                print();
                printf("\n");
            }
            assert(!(tr1.m_et->m_ad && tr2.m_et->m_ad));

            type_specifier *ts1 = tr1.m_et->m_sql->get_type_specifier()->get_base_type();
            type_specifier *ts2 = tr2.m_et->m_sql->get_type_specifier()->get_base_type();
            if(!(ts1->is_int_type() || ts1->is_float_type()) || !(ts2->is_int_type() || ts2->is_float_type())) {
                print();
                printf("\n");
            }
            assert(ts1->is_int_type() || ts1->is_float_type());
            assert(ts2->is_int_type() || ts2->is_float_type());

            if(tr1.m_et->m_ad) return tr1;
            if(tr2.m_et->m_ad) return tr2;

            if(ts1->is_float_type()) {
                return tr1;
            } else {
                return tr2;
            }
        } else {
            print();
            printf("\n");
            aeprintf("type problem\n");
        }
    } else {
        return tr1;
    }
}

TranslateResult additive_expression_additive_expression_minus_multiplicative_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ae,tr1);
    TRANSLATE(m_me,tr2);

    if(g_expression_type) {
        if(tr1.m_et.get() && tr2.m_et.get()) {
            if(tr1.m_et->m_ad && tr2.m_et->m_ad) {
                print();
                printf("\n");
            }
            assert(!(tr1.m_et->m_ad && tr2.m_et->m_ad));

            type_specifier *ts1 = tr1.m_et->m_sql->get_type_specifier()->get_base_type();
            type_specifier *ts2 = tr2.m_et->m_sql->get_type_specifier()->get_base_type();
            if(!(ts1->is_int_type() || ts1->is_float_type()) || !(ts2->is_int_type() || ts2->is_float_type())) {
                print();
                printf("\n");
            }
            assert(ts1->is_int_type() || ts1->is_float_type());
            assert(ts2->is_int_type() || ts2->is_float_type());

            if(tr1.m_et->m_ad) return tr1;
            if(tr2.m_et->m_ad) return tr2;

            if(ts1->is_float_type()) {
                return tr1;
            } else {
                return tr2;
            }
        } else {
            print();
            printf("\n");
            aeprintf("type problem\n");
        }
    } else {
        return tr1;
    }
}

TranslateResult and_expression_and_expression_equality_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_ae,tr1);
    TRANSLATE(m_ee,tr2);

    if(g_expression_type) {
        if(tr1.m_et.get() && tr2.m_et.get()) {
            if(tr1.m_et->m_ad || tr2.m_et->m_ad) {
                print();
                printf("\n");
                aeprintf("type problem\n");
            }

            type_specifier *ts1 = tr1.m_et->m_sql->get_type_specifier()->get_base_type();
            type_specifier *ts2 = tr2.m_et->m_sql->get_type_specifier()->get_base_type();
            assert(ts1->is_int_type());
            assert(ts2->is_int_type());
            return tr1;
        } else {
            print();
            printf("\n");
            aeprintf("type problem\n");
        }
    } else {
        return tr1;
    }
}

TranslateResult type_specifier_TYPE_NAME::translate_pillar(function_definition *fd) {
    if(g_expression_type) {
        expression_type *ret = new expression_type;

        ret->m_sql = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
                        new type_qualifier_const(),
                        new specifier_qualifier_list_type_specifier(
                        clone()));
        ret->m_ad  = NULL;

        return TranslateResult(auto_ptr<expression_type>(ret));
    } else {
        return TranslateResult();
    }
}

TranslateResult type_specifier::translate_pillar(function_definition *fd) {
    if(g_expression_type) {
        expression_type *ret = new expression_type;

        ret->m_sql = new specifier_qualifier_list_type_qualifier_specifier_qualifier_list(
                        new type_qualifier_const(),
                        new specifier_qualifier_list_type_specifier(
                        clone()));
        ret->m_ad  = NULL;

        return TranslateResult(auto_ptr<expression_type>(ret));
    } else {
        return TranslateResult();
    }
}

abstract_declarator * abstract_declarator_direct_abstract_declarator::clone(void) {
    abstract_declarator_direct_abstract_declarator *copy = new abstract_declarator_direct_abstract_declarator(m_dad->clone());
    copy->clone_copy(this);
    return copy;
}

abstract_declarator * abstract_declarator_pointer_direct_abstract_declarator::clone(void) {
    abstract_declarator_pointer_direct_abstract_declarator *copy = new abstract_declarator_pointer_direct_abstract_declarator(m_p->clone(),m_dad->clone());
    copy->clone_copy(this);
    return copy;
}

abstract_declarator * abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::clone(void) {
    abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator *copy = new abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(m_ccs->clone(),m_p->clone(),m_dad->clone());
    copy->clone_copy(this);
    return copy;
}

bool abstract_declarator_direct_abstract_declarator::is_pointer(void) const {
    return m_dad->is_pointer();
}

bool abstract_declarator_call_conv_specifier_direct_abstract_declarator::is_pointer(void) const {
    return m_dad->is_pointer();
}

TranslateResult multiplicative_expression_multiplicative_expression_div_cast_expression::translate_pillar(function_definition *fd) {
    TranslateResult tr1, tr2;
    TRANSLATE(m_me,tr1);
    TRANSLATE(m_ce,tr2);

    if(g_expression_type) {
        if(tr1.m_et.get() && tr2.m_et.get()) {
            if(tr1.m_et->m_ad || tr2.m_et->m_ad) {
                print();
                printf("\n");
                aeprintf("type problem\n");
            }

            type_specifier *ts1 = tr1.m_et->m_sql->get_type_specifier()->get_base_type();
            type_specifier *ts2 = tr2.m_et->m_sql->get_type_specifier()->get_base_type();
            if(!(ts1->is_int_type() || ts1->is_float_type()) || !(ts2->is_int_type() || ts2->is_float_type())) {
                print();
                printf("\n");
                aeprintf("type problem\n");
            }
            assert(ts1->is_int_type() || ts1->is_float_type());
            assert(ts2->is_int_type() || ts2->is_float_type());

            if(ts1->is_float_type()) {
                return tr1;
            } else {
                return tr2;
            }
        } else {
            print();
            printf("\n");
            aeprintf("type problem\n");
        }
    } else {
        return tr1;
    }
}

TranslateResult primary_expression_constant::translate_pillar(function_definition *fd) {
    if(g_expression_type) {
        if(m_id.length() > 2) {
            if(m_id[0] == '\'' && m_id[m_id.length()-1] == '\'') {
                primary_expression_constant_int peci("");
                return TranslateResult(auto_ptr<expression_type>(peci.get_type()));
            }
        }
    }
    TranslateResult tr;
    return tr;
}

abstract_declarator * abstract_declarator_direct_abstract_declarator::remove_pointer_star(void) {
    direct_abstract_declarator *dad = m_dad->remove_pointer_star();
    if(dad) {
        return new abstract_declarator_direct_abstract_declarator(dad);
    } else {
        return NULL;
    }
}

abstract_declarator * abstract_declarator_pointer_direct_abstract_declarator::remove_pointer_star(void) {
    pointer_star *ps = dynamic_cast<pointer_star*>(m_p);
    pointer_star_type_qualifier_list *pstql = dynamic_cast<pointer_star_type_qualifier_list*>(m_p);
    pointer_star_pointer *psp = dynamic_cast<pointer_star_pointer*>(m_p);
    pointer_star_type_qualifier_list_pointer *pstqlp = dynamic_cast<pointer_star_type_qualifier_list_pointer*>(m_p);
    if(ps || pstql) {
        return new abstract_declarator_direct_abstract_declarator(m_dad->clone());
    } else {
        if(psp) {
            return new abstract_declarator_pointer_direct_abstract_declarator(
                psp->get_pointer()->clone(),
                m_dad->clone()
                );
        } else {
            return new abstract_declarator_pointer_direct_abstract_declarator(
                pstqlp->get_pointer()->clone(),
                m_dad->clone()
                );
        }
    }
}

abstract_declarator * abstract_declarator_call_conv_specifier_pointer::remove_pointer_star(void) {
    pointer_star *ps = dynamic_cast<pointer_star*>(m_p);
    pointer_star_type_qualifier_list *pstql = dynamic_cast<pointer_star_type_qualifier_list*>(m_p);
    pointer_star_pointer *psp = dynamic_cast<pointer_star_pointer*>(m_p);
    pointer_star_type_qualifier_list_pointer *pstqlp = dynamic_cast<pointer_star_type_qualifier_list_pointer*>(m_p);
    if(ps || pstql) {
        aeprintf("What to do here?!?!?\n");
//        return new abstract_declarator_call_conv_specifier(m_ccs->clone());
    } else {
        if(psp) {
            return new abstract_declarator_call_conv_specifier_pointer(
                m_ccs->clone(),
                psp->get_pointer()->clone()
                );
        } else {
            return new abstract_declarator_call_conv_specifier_pointer(
                m_ccs->clone(),
                pstqlp->get_pointer()->clone()
                );
        }
    }
}

abstract_declarator * abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::remove_pointer_star(void) {
    pointer_star *ps = dynamic_cast<pointer_star*>(m_p);
    pointer_star_type_qualifier_list *pstql = dynamic_cast<pointer_star_type_qualifier_list*>(m_p);
    pointer_star_pointer *psp = dynamic_cast<pointer_star_pointer*>(m_p);
    pointer_star_type_qualifier_list_pointer *pstqlp = dynamic_cast<pointer_star_type_qualifier_list_pointer*>(m_p);
    if(ps || pstql) {
        return new abstract_declarator_call_conv_specifier_direct_abstract_declarator(m_ccs->clone(),m_dad->clone());
    } else {
        if(psp) {
            return new abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(
                m_ccs->clone(),
                psp->get_pointer()->clone(),
                m_dad->clone()
                );
        } else {
            return new abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator(
                m_ccs->clone(),
                pstqlp->get_pointer()->clone(),
                m_dad->clone()
                );
        }
    }
}

abstract_declarator * abstract_declarator_direct_abstract_declarator::add_pointer_star(void) {
    return new abstract_declarator_pointer_direct_abstract_declarator(new pointer_star(),m_dad->clone());
}

TranslateResult::TranslateResult(auto_ptr<expression_type> et) : m_et(et) {
    if(m_et.get() && m_et->m_ad == NULL && m_et->m_sql->get_type_specifier()->is_ultimate_prt_ref()) {
        m_once_ref = true;
    } else {
        m_once_ref = false;
    }
}

bool type_specifier_struct_or_union_specifier::operator==(const type_specifier *other) {
    const type_specifier_struct_or_union_specifier *other_cast = dynamic_cast<const type_specifier_struct_or_union_specifier *>(other);
    if(other_cast) {
        return *m_sous == other_cast->m_sous;
    } else {
        return false;
    }
}

call_expression_builtin_offsetof_type_name_identifier::call_expression_builtin_offsetof_type_name_identifier(type_name *tn, ii_ptr ii) : call_expression(NULL), m_tn(tn), m_ii(ii) {
    m_tn->set_parent(this);
}

void call_expression_builtin_offsetof_type_name_identifier::print(void) const {
    oprintf("__builtin_offsetof ( ");
    m_tn->print();
    oprintf(" , %s ) ",m_ii->get_name());
}

call_expression * call_expression_builtin_offsetof_type_name_identifier::clone(void) {
    call_expression *copy = new call_expression_builtin_offsetof_type_name_identifier(m_tn->clone(),m_ii);
    copy->clone_copy(this);
    return copy;
}

call_expression_builtin_offsetof_type_name_identifier::~call_expression_builtin_offsetof_type_name_identifier(void) {
    delete m_tn;
}

//PILLAR2C_CALLCONV AST_node::fix_cc_default(PILLAR2C_CALLCONV cc,function_definition *fd) const {
PILLAR2C_CALLCONV AST_node::fix_cc_default(PILLAR2C_CALLCONV cc) const {
    if(cc == ST_NOT_DEFINED) {
        function_definition *fd = find_enclosing_function();
        if(fd) {
            PILLAR2C_CALLCONV fcc = fd->get_function_cc();
            if(fcc != ST_NOT_DEFINED) {
                return fcc;
            }
        }
        if(g_mode < 2) {
            return g_cc_stack.top();
        } else {
            external_declaration *ed = search_up_for_type<external_declaration>(this);
            if(!ed) {
                // FIX FIX FIX....is this right?  We in translating mode and creating something new if we get here.
                return ST_PDECL;
            }
            return ed->get_default_cc();
        }
    } else {
        return cc;
    }
}

void call_expression_metadata::print(void) {
    printf("Function: ");
    if(m_pe_function) {
        m_pe_function->print();
    } else {
        printf("Not specified.");
    }
    printf("\nReturn type: ");
    m_ret->print();
    printf("\nEllipsis: %d\n",m_func_metadata.m_ellipsis);
    unsigned i;

    printf("Args passed to function\n--------------------\n");
    for(i=0;i<m_args.size();++i) {
        printf("\t");
        m_args[i]->print();
        printf("\n");
    }
    printf("Parameters of the function\n--------------------\n");
    for(i=0;i<m_func_metadata.m_params.size();++i) {
        printf("\t");
        m_func_metadata.m_params[i]->print();
        printf("\n");
    }
}

void expression_type::print(void) {
    if(m_sql) {
        m_sql->print();
        printf(" ");
    } else {
        printf("NULL_sql ");
    }
    if(m_ad) {
        m_ad->print();
        printf(" ");
    } else {
        printf("NULL_ad ");
    }
}

#include <fstream>

void process_pcdecl_file(const std::string &file) {
    std::ifstream infile;
    infile.open(file.c_str());
    if(!infile) {
        printf("Could not open pcdecl file %s\n",file.c_str());
        return;
    }
    std::string one_function;
    while(1) {
        infile >> one_function;

        if(!infile.fail()) {
            g_force_pcdecl.insert(one_function);
        }

        if(infile.eof()) break;
    }
}

std::string AST_node::get_unique(const std::string &prepend) {
    aeprintf("Some class didn't override get_unique.\n");
}

AST_node * direct_declarator_paren_declarator::clone_for_struct_decl(std::string &new_name,bool remove_braces) {
    return new direct_declarator_paren_declarator((declarator*)m_d->clone_for_struct_decl(new_name,remove_braces));
}

AST_node * direct_declarator_direct_declarator_parameter_type_list::clone_for_struct_decl(std::string &new_name,bool remove_braces) {
    return new direct_declarator_direct_declarator_parameter_type_list((direct_declarator*)m_dd->clone_for_struct_decl(new_name,remove_braces),m_ptl->clone());
}

AST_node * declarator_pointer_direct_declarator::clone_for_struct_decl(std::string &new_name,bool remove_braces) {
    return new declarator_pointer_direct_declarator(m_p->clone(),(direct_declarator*)m_dd->clone_for_struct_decl(new_name,remove_braces));
}

AST_node * declarator_call_conv_specifier_pointer_direct_declarator::clone_for_struct_decl(std::string &new_name,bool remove_braces) {
    return new declarator_call_conv_specifier_pointer_direct_declarator(m_ccs->clone(),m_p->clone(),(direct_declarator*)m_dd->clone_for_struct_decl(new_name,remove_braces));
}

AST_node * declarator_pointer_call_conv_specifier_direct_declarator::clone_for_struct_decl(std::string &new_name,bool remove_braces) {
    return new declarator_pointer_call_conv_specifier_direct_declarator(m_p->clone(),m_ccs->clone(),(direct_declarator*)m_dd->clone_for_struct_decl(new_name,remove_braces));
}

declarator * abstract_declarator_direct_abstract_declarator::gen_declarator(const std::string &arg_name) {
    return new declarator_direct_declarator(m_dad->gen_direct_declarator(arg_name));
}

declarator * abstract_declarator_pointer_direct_abstract_declarator::gen_declarator(const std::string &name) {
    return new declarator_pointer_direct_declarator(
            m_p->clone(),
            m_dad->gen_direct_declarator(name));
}

bool function_metadata::has_nonregister_param(void) const {
    unsigned i;
    for(i=0; i < m_params.size(); ++i) {
        type_specifier *ts = m_params[i]->get_type_specifier();
        if(!ts) continue;
        ts = ts->get_base_type();
        Scope *s;
        if(ts->is_struct(s)) {
            return true;
        }
        if(ts->param_larger_than_register()) {
            return true;
        }
    }
    return false;
}

bool function_metadata::has_param_of_unknown_size(void) const {
    unsigned i;
    try {
        for(i=0; i < m_params.size(); ++i) {
            type_specifier *ts = m_params[i]->get_type_specifier();
            if(!ts) continue;
            ts = ts->get_base_type();
            ts->get_param_size();
        }
    }
    catch(unknown_size) {
        return true;
    }
    catch(...) {
        aeprintf("Unexpected exception caught in function_metadata::has_param_of_unknown_size\n");
    }
    return false;
}

void declaration_declaration_specifiers::add_volatile(void) {
    m_ds = m_ds->add_volatile();
}

void declaration_declaration_specifiers_init_declarator_list::add_volatile(void) {
    m_ds = m_ds->add_volatile();
}

unsigned statement_labeled_statement::count_cases(void) {
//    return m_s->is_case_or_default() ? 1 : 0;
    return m_s->count_cases();
}

unsigned statement_compound_statement::count_cases(void) {
    return m_s->count_cases();
}

void argument_expression_list_assignment_expression::vectorize(check_vector<assignment_expression *> &args) {
    args.push_back(m_ae->clone());
}

void argument_expression_list_argument_expression_list_assignment_expression::vectorize(check_vector<assignment_expression *> &args) {
    m_ael->vectorize(args);
    args.push_back(m_ae->clone());
}

void argument_expression_list_assignment_expression::claim_vectorize(check_vector<assignment_expression *> &args) {
    args.push_back(m_ae);
    m_ae->set_parent(NULL);
    m_ae = NULL;
}

void argument_expression_list_argument_expression_list_assignment_expression::claim_vectorize(check_vector<assignment_expression *> &args) {
    m_ael->claim_vectorize(args);
    args.push_back(m_ae);
    m_ae->set_parent(NULL);
    m_ae = NULL;
}

declaration_specifiers * declaration_specifiers_storage_class_specifier::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_storage_class_specifier_declaration_specifiers(m_scs,to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

// FIX FIX FIX....we are leaking memory in these append functions.
declaration_specifiers * declaration_specifiers_type_specifier::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_type_specifier_declaration_specifiers(m_ts,to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

declaration_specifiers * declaration_specifiers_mrv::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_mrv_declaration_specifiers(m_ts,to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

declaration_specifiers * declaration_specifiers_type_qualifier::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_type_qualifier_declaration_specifiers(m_tq,to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

declaration_specifiers * declaration_specifiers_function_specifier::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_function_specifier_declaration_specifiers(m_fs,to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

declaration_specifiers * declaration_specifiers_gcc_attribute::append(declaration_specifiers *to_append) {
    AST_node *orig_parent = m_parent;

    declaration_specifiers *new_node = new declaration_specifiers_gcc_attribute_declaration_specifiers(m_s.c_str(),to_append);
    orig_parent->replace(this,new_node);
    return new_node;
}

abstract_declarator * direct_declarator_paren_declarator::gen_abstract_declarator(void) {
    return m_d->gen_abstract_declarator();
}

direct_abstract_declarator * direct_declarator_paren_declarator::gen_direct_abstract_declarator(void) {
    return new direct_abstract_declarator_abstract_declarator(
             m_d->gen_abstract_declarator()
           );
}

abstract_declarator * direct_declarator_direct_declarator_type_qualifier_list_assignment_expression::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_type_qualifier_list::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_STATIC_type_qualifier_list_assignment_expression::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_type_qualifier_list_STATIC_assignment_expression::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_assignment_expression::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_type_qualifier_list_star::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_star::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_empty_brace::gen_abstract_declarator(void) {
    return new abstract_declarator_pointer(new pointer_star());
}

abstract_declarator * direct_declarator_direct_declarator_parameter_type_list::gen_func_type(void) {
    direct_declarator_IDENTIFIER *dd = dynamic_cast<direct_declarator_IDENTIFIER*>(m_dd);
    if(dd) {
        ii_ptr ii = dd->get_ii();
        PILLAR2C_CALLCONV cc = ii->get_function_cc();
        return new abstract_declarator_direct_abstract_declarator(
                 new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                   new direct_abstract_declarator_abstract_declarator(
                     new abstract_declarator_call_conv_specifier_pointer(
                       gen_call_conv_specifier(cc),
                       new pointer_star())),
                   m_ptl->clone_abstract()
                 )
               );
    } else {
        aeprintf("Unhandled m_dd type in direct_declarator_direct_declarator_parameter_type_list.\n");
    }
}

abstract_declarator * direct_declarator_direct_declarator_parameter_type_list::gen_abstract_declarator(void) {
    direct_abstract_declarator *dad = m_dd->gen_direct_abstract_declarator();
    if(dad) {
#if 1
        return new abstract_declarator_direct_abstract_declarator(
                 new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(
                   dad,
                   m_ptl->clone()
                 )
               );
#endif
    } else {
        return NULL;
    }
}

direct_abstract_declarator * direct_declarator_direct_declarator_parameter_type_list::gen_direct_abstract_declarator(void) {
    if(dynamic_cast<direct_declarator_paren_declarator*>(m_dd)) {
        return new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(m_dd->gen_direct_abstract_declarator(),m_ptl->clone());
//  } else if(dynamic_cast<direct_declarator_IDENTIFIER*>(m_dd)) {
//      print();
//      printf("\n");
//      return new direct_abstract_declarator_direct_abstract_declarator_paren_parameter_type_list(new direct_abstract_declarator_abstract_declarator(new abstract_declarator_pointer(new pointer_star())),m_ptl->clone());
    } else {
        return m_dd->gen_direct_abstract_declarator();
    }
}

direct_abstract_declarator * direct_declarator_direct_declarator_empty_paren::gen_direct_abstract_declarator(void) {
    if(dynamic_cast<direct_declarator_paren_declarator*>(m_dd)) {
        return new direct_abstract_declarator_direct_abstract_declarator_empty_parens(m_dd->gen_direct_abstract_declarator());
    } else {
        return m_dd->gen_direct_abstract_declarator();
    }
}

bool direct_declarator_paren_declarator::is_pointer(void) {
    return m_d->is_pointer();
}

bool declaration_specifiers_function_specifier::has_noreturn(void) {
    return m_fs->has_noreturn();
}

bool declaration_specifiers_function_specifier_declaration_specifiers::has_noreturn(void) {
    return m_fs->has_noreturn() || m_ds->has_noreturn();
}

void get_func_metadata_from_type(type_specifier *ts,call_expression_metadata &cem) {
#if 0
    type_specifier_TYPE_NAME *this_tstn = dynamic_cast<type_specifier_TYPE_NAME *>(ts);
    if(this_tstn) {
        while(this_tstn) {
            //aaaaaaaaaaaa
        }
    }
#endif

    type_specifier *base = ts->get_base_type();
    type_specifier_TYPE_NAME *tstn = dynamic_cast<type_specifier_TYPE_NAME *>(base);
    if(!tstn) {
        base->print();
        printf("\n");
        aeprintf("Can't get function data of a non-function 1.\n");
    }
    ii_ptr ii = tstn->get_id_info();
    if(!ii->is_function_var()) {
        base->print();
        printf("\n");
        aeprintf("Can't get function data of a non-function 2.\n");
    }

    declarator *decl = ii->get_first_declarator();
    declaration *d = get_declaration_from_prototype(decl);

    decl->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
    cem.m_ret = d->get_return_type();
    cem.m_func_metadata.m_noreturn = false;
}

void postfix_expression_postfix_expression_dot_identifier::get_func_metadata(call_expression_metadata &cem) {
    auto_ptr<expression_type> apet(get_type());
    get_func_metadata_from_type(apet->m_sql->get_type_specifier(),cem);
}

void postfix_expression_postfix_expression_ptr_op_identifier::get_func_metadata(call_expression_metadata &cem) {
    auto_ptr<expression_type> apet(get_type());
    get_func_metadata_from_type(apet->m_sql->get_type_specifier(),cem);
}

void declaration_declaration_specifiers_init_declarator_list::get_func_metadata(call_expression_metadata &cem) {
//    declaration_specifiers *m_ds;
//    init_declarator_list   *m_idl;
    print();
    printf("\n");
    aeprintf("Get get func metadata on this kind of declaration.\n");
}

void labeled_statement_identifier::print(void) const {
    if(m_reference_count) {
        oprintf("%s : ",m_id.c_str());
    }

    m_s->print();
}

void statement::base_translate(function_definition *fd) {
    basic_block *cur_bb = fd->get_cur_basic_block();
    if(cur_bb) {
        cur_bb->add_item(this);
    }
}

statement::~statement (void) {
    if(m_bb) {
        m_bb->remove_item(this);
    }
#ifdef VERIFY_STMT_LIVE
    g_stmts.erase(this);
#endif // VERIFY_STMT_LIVE
}

void argument_expression_list_argument_expression_list_assignment_expression::create_call_graph(function_definition *fd) {
    // FIX FIX FIX - need to fix if args are ever pushed left-to-right.
    // Process in reverse of normal order since args are pushed right-to-left.
    CREATE_CALL_GRAPH(m_ae,fd);
    CREATE_CALL_GRAPH(m_ael,fd);
}

bool direct_declarator_paren_declarator::is_regular_function(void) const {
    return m_d->is_regular_function();
}

Scope * direct_declarator_paren_declarator::get_param_scope(void) {
    return m_d->get_param_scope();
}

void direct_declarator_paren_declarator::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    m_d->vectorize_params(params, ellipsis);
}

void direct_declarator_paren_declarator::add_explicit_call_conv(PILLAR2C_CALLCONV cc) {
    m_d = m_d->add_explicit_call_conv(cc);
}

void AST_node::create_call_graph(function_definition *fd) {
    AST_node **child = begin_child_iter();
    while(child) {
        CREATE_CALL_GRAPH((*child),fd);
        child = next_child_iter(child);
    }
}

void AST_node::denest(function_definition *fd) {
    AST_node **child = begin_child_iter();
    while(child) {
        CREATE_CALL_GRAPH((*child),fd);
        child = next_child_iter(child);
    }
}

void AST_node::replace_refs_with_pseudo_expression(void) {
    AST_node **child = begin_child_iter();
    while(child) {
        try {
            (*child)->replace_refs_with_pseudo_expression();
        } catch(done &d) {
            if(d.m_node != this) {
                throw;
            }
            // else fallthrough
        } catch (...) {
            aeprintf("Got unknown exception during replace_refs_with_pseudo_expression.\n");
        }
        child = next_child_iter(child);
    }
}

void AST_node::cast_off_volatile(void) {
    AST_node **child = begin_child_iter();
    while(child) {
        try {
            (*child)->cast_off_volatile();
        } catch(done &d) {
            if(d.m_node != this) {
                throw;
            }
            // else fallthrough
        } catch (...) {
            aeprintf("Got unknown exception during replace_refs_with_pseudo_expression.\n");
        }
        child = next_child_iter(child);
    }
}

expression_type * conditional_expression_logical_or_expression_expression_conditional_expression::get_type(void) {
    return m_e->get_type();
}

void primary_expression_expression::get_func_metadata(call_expression_metadata &cem) {
    auto_ptr<expression_type> apet(m_e->get_type());
    auto_ptr<expression_type> base_type(apet->get_base_type());
    if(!base_type->m_ad) {
        print();
        printf("\n");
        aeprintf("get_func_metadata should never find NULL abstract declarator for base type.\n");
    } else {
        if(base_type->m_ad->is_function()) {
            cem.m_ret = new expression_type;
            cem.m_ret->m_sql = base_type->m_sql->clone();
            cem.m_ret->m_ad  = base_type->m_ad->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
            cem.m_func_metadata.claim_params();
    //        print();
        }
    }
//    apet->m_ad->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
//    cem.m_ret = m_e->get_type();
//    cem.m_func_metadata.m_noreturn = WHATTODOHERE?
//        m_d->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
//    print();
//    assert(0);
//    return m_e->get_func_metadata(cem);
}

bool abstract_declarator_direct_abstract_declarator::is_function(void) const {
    return m_dad->is_function();
}

bool abstract_declarator_pointer_direct_abstract_declarator::is_function(void) const {
    return m_dad->is_function();
}

bool abstract_declarator_call_conv_specifier_direct_abstract_declarator::is_function(void) const {
    return m_dad->is_function();
}

bool abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::is_function(void) const {
    return m_dad->is_function();
}

abstract_declarator * abstract_declarator_direct_abstract_declarator::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    return new abstract_declarator_direct_abstract_declarator(m_dad->vectorize_params(params,ellipsis));
}

abstract_declarator * abstract_declarator_pointer_direct_abstract_declarator::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    m_dad->vectorize_params(params,ellipsis);
    aeprintf("Not implemented yet.\n");
    return NULL;
}

abstract_declarator * abstract_declarator_call_conv_specifier_direct_abstract_declarator::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    m_dad->vectorize_params(params,ellipsis);
    aeprintf("Not implemented yet.\n");
    return NULL;
}

abstract_declarator * abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    m_dad->vectorize_params(params,ellipsis);
    aeprintf("Not implemented yet.\n");
    return NULL;
}

expression_type * cast_expression_type_name_cast_expression::get_return_type(void) {
    auto_ptr<expression_type> apet(get_type());
    auto_ptr<expression_type> base_type(apet->get_base_type());
    call_expression_metadata cem;
    if(base_type->m_ad->is_function()) {
        expression_type *et = new expression_type;
        et->m_sql = base_type->m_sql->clone();
        et->m_ad  = base_type->m_ad->vectorize_params(cem.m_func_metadata.m_params,cem.m_func_metadata.m_ellipsis);
//        print();
        return et;
    } else {
        aeprintf("get_return_type called for cast_expression_type_name_cast_expression that is not a function pointer.\n");
    }
}

bool expression_type::is_float(void) {
    if(is_pointer()) return false;
    type_specifier *ts = m_sql->get_type_specifier();
    if(!ts) {
        aeprintf("Type specifier should not be NULL in expression_type::is_float\n");
    }
    if(dynamic_cast<type_specifier_FLOAT*>(ts)) return true;
    else                                        return false;
}

bool expression_type::is_float_type(void) {
#ifdef USE_ET_BASE
    auto_ptr<expression_type> apet(get_base_type());
    assert(apet.get());
    if(apet->is_pointer()) return false;
    type_specifier *ts = apet->m_sql->get_type_specifier();
    if(!ts) {
        aeprintf("Type specifier should not be NULL in expression_type::is_float\n");
    }
    return ts->is_float_type();
#else
    if(is_pointer()) return false;
    type_specifier *ts = m_sql->get_type_specifier()->get_base_type();
    if(!ts) {
        aeprintf("Type specifier should not be NULL in expression_type::is_float\n");
    }
    return ts->is_float_type();
#endif
}

bool expression_type::is_int_type(void) {
#ifdef USE_ET_BASE
    auto_ptr<expression_type> apet(get_base_type());
    assert(apet.get());
    if(apet->is_pointer()) return false;
    type_specifier *ts = apet->m_sql->get_type_specifier();
    if(!ts) {
        aeprintf("Type specifier should not be NULL in expression_type::is_float\n");
    }
    return ts->is_int_type();
#else
    if(is_pointer()) return false;
    type_specifier *ts = m_sql->get_type_specifier()->get_base_type();
    if(!ts) {
        aeprintf("Type specifier should not be NULL in expression_type::is_float\n");
    }
    return ts->is_int_type();
#endif
}

bool type_specifier_TYPE_NAME::is_struct(Scope *&struct_scope) {
    assert(m_ii->is_typedef());
    type_specifier *ts = m_ii->get_type();
    if(ts) {
        return ts->is_struct(struct_scope);
    } else {
        return false;
    }
}

bool type_specifier_TYPE_NAME::param_larger_than_register(void) const {
    assert(m_ii->is_typedef());
    type_specifier *ts = m_ii->get_type();
    if(ts) {
        return ts->param_larger_than_register();
    } else {
        return false;
    }
}

expression_type * expression_type::get_base_type(void) {
#if 0
    if(m_sql->get_type_specifier()->is_base_type()) {
        expression_type *et = new expression_type;
        et->m_sql = m_sql->clone();
        if(m_ad) {
            et->m_ad = m_ad->clone();
        } else {
            et->m_ad = NULL;
        }
        return et;
    } else {
        type_specifier *ts = m_sql->get_type_specifier();
        if(!ts) {
            aeprintf("expression_type::get_base_type problem.\n");
        }

        type_specifier_TYPE_NAME *tstn = dynamic_cast<type_specifier_TYPE_NAME *>(ts);
        if(tstn) {
            ii_ptr ii = tstn->get_id_info();
            if(!ii->is_typedef() || !ii->is_var()) {
                aeprintf("ii is not typedef\n");
            }

            aeprintf("not implemented\n");
//            expression_type *et = ii->get_type();
            if(m_ad) {
                aeprintf("Need to handle ad merging in expression_type::get_base_type.\n");
#if 0
                expression_type *et = new expression_type;
                et->m_sql = new specifier_qualifier_list_type_specifier(ts->clone());
                if(m_ad) {
                    et->m_ad = m_ad->clone();
                } else {
                    et->m_ad = NULL;
                }
                return et;
#endif
            } else {
//                return et;
            }
        } else {
            aeprintf("Need to handle non TYPENAMES in expression_type::get_base_type.\n");
        }
    }
#else
    if(m_sql->get_type_specifier()->is_base_type()) {
        return clone();
    } else {
        type_specifier *ts = m_sql->get_type_specifier();
        if(!ts) {
            aeprintf("expression_type::get_base_type problem.\n");
        }

        type_specifier_TYPE_NAME *tstn = dynamic_cast<type_specifier_TYPE_NAME *>(ts);
        if(tstn) {
            ii_ptr ii = tstn->get_id_info();

            if(ii->is_typedef() || ii->is_var()) {
#ifdef SINGLE_DECLARATOR
                declarator * tstn_decl = ii->get_declarator();
#else  // SINGLE_DECLARATOR
                declarator * tstn_decl = ii->get_first_declarator();
#endif // SINGLE_DECLARATOR
                expression_type * tstn_et = tstn_decl->get_type();
                if(m_ad) {
                    if(tstn_et->m_ad) {
                        tstn_et->m_ad = m_ad->add_another(tstn_et->m_ad);
                        return tstn_et;
                    } else {
                        tstn_et->m_ad = m_ad->clone();
                        return tstn_et;
                    }
                } else {
                    return tstn_et;
                }
            } else if(ii->is_struct_enum()) {
                return clone();
            } else {
                aeprintf("In expression_type::get_base_type don't know how to handle types that aren't typedefs or structs.\n");
            }
        } else {
            return clone();
            // FIX FIX FIX...maybe this isn't quite right or perhaps everything but typename should be considered a base type.
            aeprintf("Need to handle non-TYPENAMES in expression_type::get_base_type.\n");
        }
    }
#endif
}

#if 0
expression_type * type_specifier::get_base_type(void) {
    expression_type *et = new expression_type;
    et->m_sql = new specifier_qualifier_list_type_specifier(clone());
    et->m_ad  = NULL;
    return et;
}
#endif

unsigned expression_type::get_minimum_size(void) {
    if(is_pointer()) {
        return REGISTER_PARAM_SIZE;
    }
    if(m_ad) {
        aeprintf("How did this happen in get_minimum_size?\n");
    }
    return m_sql->get_type_specifier()->get_minimum_size();
}

unsigned expression_type::get_param_size(void) {
    if(is_pointer()) {
        return REGISTER_PARAM_SIZE;
    }
    if(m_ad) {
        aeprintf("How did this happen in get_param_size?\n");
    }
    return m_sql->get_type_specifier()->get_param_size();
}

expression_type * expression_type::clone(void) {
    expression_type *et = new expression_type;
    if(m_sql) {
        et->m_sql = m_sql->clone();
    } else {
        et->m_sql = NULL;
    }
    if(m_ad) {
        et->m_ad  = m_ad->clone();
    } else {
        et->m_ad  = NULL;
    }
    return et;
}

void direct_declarator_IDENTIFIER::vectorize_params(check_vector<parameter_declaration *> &params, bool &ellipsis) {
    if(m_ii->is_typedef() && m_ii->is_function()) {
        direct_declarator *func_decl = m_ii->get_func_decl();
        if(func_decl) {
            return func_decl->vectorize_params(params,ellipsis);
        }
    }
    if(m_ii->is_function_var()) {
        direct_declarator *func_decl = m_ii->get_func_decl();
        if(func_decl) {
            return func_decl->vectorize_params(params,ellipsis);
        }
    }

    print();
    printf("\n");
    aeprintf("Don't know how to vectorize_params for this kind of direct_declarator_IDENTIFIER.\n");
}

type_specifier * id_info::get_type(void) const {
    if(type_or_lsi.m_type) {
        return type_or_lsi.m_type;
    } else {
        return NULL;
// This code has the problem in that it create an expression_type and return a part of it which then gets deallocated by
// the auto_ptr.
        if(is_typedef() && is_function()) {
            direct_declarator *func_decl = ((id_info*)this)->get_func_decl();
            if(func_decl) {
                class declarator *decl_func = dynamic_cast<declarator*>(func_decl->get_parent());
                if(decl_func) {
                    auto_ptr<expression_type> apet(decl_func->get_type());
                    if(!apet.get()) {
                        aeprintf("Could not get type for func_decl expression in type_specifier_TYPE_NAME::is_struct.\n");
                    }
                    if(apet->is_pointer()) {
                        return NULL;
                    } else if(apet->m_ad) {
                        aeprintf("abstract declarator is not a pointer but is non-NULL in type_specifier_TYPE_NAME::is_struct.\n");
                    } else {
                        return apet->m_sql->get_type_specifier();
                    }
                } else {
                    aeprintf("func_decl's parent is not a declarator in type_specifier_TYPE_NAME::is_struct.\n");
                }
            } else {
                aeprintf("function typedef missing func_decl in type_specifier_TYPE_NAME::is_struct.\n");
            }
        }
    }
}

abstract_declarator * abstract_declarator::add_another(abstract_declarator *ad) {
    abstract_declarator_pointer *adp_this = dynamic_cast<abstract_declarator_pointer*>(this);
#if 0
    abstract_declarator_direct_abstract_declarator *addad_this = dynamic_cast<abstract_declarator_direct_abstract_declarator*>(this);
    abstract_declarator_pointer_direct_abstract_declarator *adpdad_this = dynamic_cast<abstract_declarator_pointer_direct_abstract_declarator*>(this);
    abstract_declarator_call_conv_specifier_pointer *adccsp_this = dynamic_cast<abstract_declarator_call_conv_specifier_pointer*>(this);
    abstract_declarator_call_conv_specifier_direct_abstract_declarator *adccsdad_this = dynamic_cast<abstract_declarator_call_conv_specifier_direct_abstract_declarator*>(this);
    abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator *adccspdad_this = dynamic_cast<abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator*>(this);
#endif

    abstract_declarator_pointer *adp_ad = dynamic_cast<abstract_declarator_pointer*>(ad);
#if 0
    abstract_declarator_direct_abstract_declarator *addad_ad = dynamic_cast<abstract_declarator_direct_abstract_declarator*>(ad);
    abstract_declarator_pointer_direct_abstract_declarator *adpdad_ad = dynamic_cast<abstract_declarator_pointer_direct_abstract_declarator*>(ad);
    abstract_declarator_call_conv_specifier_pointer *adccsp_ad = dynamic_cast<abstract_declarator_call_conv_specifier_pointer*>(ad);
    abstract_declarator_call_conv_specifier_direct_abstract_declarator *adccsdad_ad = dynamic_cast<abstract_declarator_call_conv_specifier_direct_abstract_declarator*>(ad);
    abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator *adccspdad_ad = dynamic_cast<abstract_declarator_call_conv_specifier_pointer_direct_abstract_declarator*>(ad);
#endif

    if(adp_this && adp_ad) {
        return new abstract_declarator_pointer(adp_this->get_pointer()->append(adp_ad->get_pointer()));
    } else {
        aeprintf("Unhandled combination in abstract_declarator::add_another\n");
    }
}

pointer * pointer_star::append(pointer *other) {
    return new pointer_star_pointer(other->clone());
}

pointer * pointer_star_type_qualifier_list::append(pointer *other) {
    return new pointer_star_type_qualifier_list_pointer(m_tql->clone(),other->clone());
}

pointer * pointer_star_pointer::append(pointer *other) {
    return new pointer_star_pointer(m_p->append(other));
}

pointer * pointer_star_type_qualifier_list_pointer::append(pointer *other) {
    return new pointer_star_type_qualifier_list_pointer(m_tql->clone(),m_p->append(other));
}

pointer * pointer_star_type_qualifier_list_pointer::clone(void) const {
    pointer_star_type_qualifier_list_pointer *copy = new pointer_star_type_qualifier_list_pointer(m_tql->clone(),m_p->clone());
    copy->clone_copy(this);
    return copy;
}

call_expression_metadata::~call_expression_metadata(void) {
    unsigned i;
    for(i=0;i<m_args.size();++i) {
        delete m_args[i];
    }
    delete m_pe_function;
    delete m_ret;
}

postfix_expression * gen_pseudo_pe(const std::string &pseudo_field, AST_node *node) {
    if(g_use_restrict_pointer) {
        return new postfix_expression_postfix_expression_ptr_op_identifier(
                 new postfix_expression_primary_expression(
                    new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME_PTR))),
                 pseudo_field);
    } else {
        return new postfix_expression_postfix_expression_dot_identifier(
                 new postfix_expression_primary_expression(
                    new primary_expression_identifier(g_scope_stack.find_or_add(PSEUDO_NAME))),
                 pseudo_field);
    }
}

enum_specifier_enumerator_list * enum_specifier_enumerator_list::clone(void) const {
    enum_specifier_enumerator_list *copy = new enum_specifier_enumerator_list(m_el->clone());
    copy->clone_copy(this);
    return copy;
}

enum_specifier_identifier_enumerator_list * enum_specifier_identifier_enumerator_list::clone(void) const {
    enum_specifier_identifier_enumerator_list *copy = new enum_specifier_identifier_enumerator_list(m_id,m_el->clone());
    copy->clone_copy(this);
    return copy;
}

enum_specifier_enumerator_list_comma * enum_specifier_enumerator_list_comma::clone(void) const {
    enum_specifier_enumerator_list_comma *copy = new enum_specifier_enumerator_list_comma(m_el->clone());
    copy->clone_copy(this);
    return copy;
}

enum_specifier_identifier_enumerator_list_comma * enum_specifier_identifier_enumerator_list_comma::clone(void) const {
    enum_specifier_identifier_enumerator_list_comma *copy = new enum_specifier_identifier_enumerator_list_comma(m_id,m_el->clone());
    copy->clone_copy(this);
    return copy;
}

enumerator_list_enumerator * enumerator_list_enumerator::clone(void) const {
    enumerator_list_enumerator *copy = new enumerator_list_enumerator(m_e->clone());
    copy->clone_copy(this);
    return copy;
}

enumerator_list_enumerator_list_enumerator * enumerator_list_enumerator_list_enumerator::clone(void) const {
    enumerator_list_enumerator_list_enumerator *copy = new enumerator_list_enumerator_list_enumerator(m_el->clone(),m_e->clone());
    copy->clone_copy(this);
    return copy;
}

bool expression_type::is_ultimate_prt_ref(void) {
    if(m_ad) return false;
    return m_sql->get_type_specifier()->is_ultimate_prt_ref();
}

std::vector<std::vector<std::string> > call_expression_metadata::get_arg_identifiers(void) {
    unsigned arg_size = m_args.size();

    std::vector<std::vector<std::string> > res;

    unsigned i;
    for(i = 0; i < arg_size; ++i) {
        std::vector<std::string> arg_ids;
        m_args[i]->param_usage(arg_ids);
        res.push_back(arg_ids);
    }

    return res;
}

bool function_metadata::get_param_size_and_offsets(unsigned &size, std::vector<name_offset> &offsets) {
    unsigned i,cur_offset=0;
    if(m_ellipsis) return false;
    size = 0;
    for(i=0; i < m_params.size(); ++i) {
        unsigned cur_param_size = m_params[i]->get_param_size();

        std::list<ii_ptr> param_names = m_params[i]->get_enclosing_symbols();
        if(param_names.size() == 0) {
            offsets.push_back(name_offset("",cur_offset,cur_param_size,i));
        } else {
            offsets.push_back(name_offset((*param_names.begin())->get_string(),cur_offset,cur_param_size,i));
        }
        size += cur_param_size;
        cur_offset += cur_param_size;
    }
    return true;
}

struct_declaration_list * struct_declaration_list::new_recursive(struct_declaration_list *sdl,struct_declaration *sd) {
    if(sdl) {
        return new struct_declaration_list_struct_declaration_list_struct_declaration(sdl,sd);
    } else {
        return new struct_declaration_list_struct_declaration(sd);
    }
}

unsigned parameter_declaration_declaration_specifiers_abstract_declarator::get_param_size(void) {
    if(m_ad->is_pointer()) {
        return REGISTER_PARAM_SIZE;
    } else {
        return m_ds->get_type_specifier()->get_param_size();
    }
}

type_name * expression_type::gen_type_name(type_qualifier *tq) {
    specifier_qualifier_list *sql_clone = m_sql->clone();
    if(tq) {
        specifier_qualifier_list *new_sql = new specifier_qualifier_list_type_qualifier(tq);
        new_sql = new specifier_qualifier_list_type_specifier_specifier_qualifier_list(sql_clone->get_type_specifier()->clone(),new_sql);
        delete sql_clone;
        sql_clone = new_sql;
    }

    if(m_ad) {
        return new type_name_specifier_qualifier_list_abstract_declarator(sql_clone,m_ad->clone());
    } else {
        return new type_name_specifier_qualifier_list(sql_clone);
    }
}

std::string id_info::get_continuation_var_string(void) const {
    std::stringstream temp;
    type_specifier_continuation *tsc = dynamic_cast<type_specifier_continuation*>(type_or_lsi.m_type);
    if(tsc) {
        temp << "_pillar2c_continuation_var_" << tsc->get_unique() << "_" << m_id;
    } else {
        temp << "_pillar2c_continuation_var_" << this << "_" << m_id;
    }
    return temp.str();
}

std::string id_info::get_continuation_type_string(void) const {
    std::stringstream temp;
    type_specifier_continuation *tsc = dynamic_cast<type_specifier_continuation*>(type_or_lsi.m_type);
    if(tsc) {
        temp << "_pillar2c_continuation_type_" << tsc->get_unique() << "_" << m_id;
    } else {
        temp << "_pillar2c_continuation_type_" << this << "_" << m_id;
    }
    return temp.str();
}

declaration * expression_type::gen_declaration_init(const std::string &name,assignment_expression *owned_ae) {
    declarator *new_d_ii = NULL;
    if(m_ad) {
        new_d_ii = m_ad->gen_declarator(name);
    } else {
        new_d_ii = new declarator_direct_declarator(new direct_declarator_IDENTIFIER(g_scope_stack.find_or_add(name)));
    }

    if(owned_ae) {
        return new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_type_specifier(m_sql->get_type_specifier()->clone()),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator_initializer(
                new_d_ii,
                new initializer_assignment_expression(owned_ae)
              )
            )
          );
    } else {
        return new declaration_declaration_specifiers_init_declarator_list(
            new declaration_specifiers_type_specifier(m_sql->get_type_specifier()),
            new init_declarator_list_init_declarator(
              new init_declarator_declarator(
                new_d_ii
              )
            )
          );
    }
}

bool declaration_specifiers_type_specifier::is_this_int(void) {
    if(dynamic_cast<type_specifier_INT*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

bool declaration_specifiers_type_specifier::is_this_long(void) {
    if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

bool declaration_specifiers_type_specifier::is_this_double(void) {
    if(dynamic_cast<type_specifier_DOUBLE*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

bool declaration_specifiers_type_specifier_declaration_specifiers::is_this_int(void) {
    if(dynamic_cast<type_specifier_INT*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

bool declaration_specifiers_type_specifier_declaration_specifiers::is_this_long(void) {
    if(dynamic_cast<type_specifier_LONG*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

bool declaration_specifiers_type_specifier_declaration_specifiers::is_this_double(void) {
    if(dynamic_cast<type_specifier_DOUBLE*>(m_ts)) {
        return true;
    } else {
        return false;
    }
}

parameter_list * parameter_list::new_recursive(parameter_list *pl,parameter_declaration *pd) {
    if(pl) {
        if(pd) {
            return new parameter_list_parameter_list_parameter_declaration(pl,pd);
        } else {
            return pl;
        }
    } else {
        return new parameter_list_parameter_declaration(pd);
    }
}

argument_expression_list * argument_expression_list::new_recursive(argument_expression_list *ael,assignment_expression *ae) {
    if(ael) {
        return new argument_expression_list_argument_expression_list_assignment_expression(ael,ae);
    } else {
        return new argument_expression_list_assignment_expression(ae);
    }
}

void function_metadata::claim_params(void) {
    unsigned i;
    for(i = 0; i < m_params.size(); ++i) {
        m_params[i]->claim();
        m_params[i]->set_parent(NULL);
    }
}

void call_expression::push_read_write(std::vector<basic_block_ref_events*> &vec) {
    std::list<ii_ptr>::iterator iter;
    for(iter  = m_read_write_address_refs.begin();
        iter != m_read_write_address_refs.end();
        ++iter) {
        // the lvalue needs to be push after the ref_call.
        vec.push_back(new ref_lvalue(*iter));
    }
}

bool declaration_specifiers_type_qualifier::is_volatile(void) {
    return m_tq->is_volatile();
}

bool declaration_specifiers_type_qualifier_declaration_specifiers::is_volatile(void) {
    if(m_tq->is_volatile()) return true;
    else                    return m_ds->is_volatile();
}

declarator * declaration_declaration_specifiers_init_declarator_list::get_declarator_with_name(const char *name) {
    return m_idl->get_declarator_with_name(name);
}

specifier_qualifier_list * specifier_qualifier_list_type_qualifier_specifier_qualifier_list::remove_volatile(void) {
    m_ql = m_ql->remove_volatile();
    if(m_tq->is_volatile()) {
        specifier_qualifier_list *ret = m_ql;
        m_ql = NULL;
        delete this;
        return ret;
    } else {
        if(m_ql) {
            return this;
        } else {
            type_qualifier *ret = m_tq;
            m_tq = NULL;
            delete this;
            return new specifier_qualifier_list_type_qualifier(ret);
        }
    }
}

specifier_qualifier_list * specifier_qualifier_list_type_specifier_specifier_qualifier_list::remove_volatile(void) {
    m_ql = m_ql->remove_volatile();
    if(m_ql) {
        return this;
    } else {
        type_specifier *ret = m_ts;
        m_ts = NULL;
        delete this;
        return new specifier_qualifier_list_type_specifier(ret);
    }
}

specifier_qualifier_list * specifier_qualifier_list_type_qualifier::remove_volatile(void) {
    if(m_tq->is_volatile()) {
        delete this;
        return NULL;
    } else {
        return this;
    }
}

bool specifier_qualifier_list_type_qualifier_specifier_qualifier_list::is_volatile(void) {
    if(m_tq->is_volatile()) {
        return true;
    } else {
        return m_ql->is_volatile();
    }
}

bool specifier_qualifier_list_type_qualifier::is_volatile(void) {
    return m_tq->is_volatile();
}

void expression_type::add_pointer_star(void) {
    if(m_ad) {
        m_ad = m_ad->add_pointer_star();
    } else {
        m_ad = new abstract_declarator_pointer(new pointer_star());
    }
}

parameter_declaration * parameter_declaration_declaration_specifiers_declarator::clone_abstract(void) {
    abstract_declarator *ad = m_d->gen_abstract_declarator();
    parameter_declaration *copy;
    if(ad) {
        copy = new parameter_declaration_declaration_specifiers_abstract_declarator(m_ds->clone(),ad);
    } else {
        copy = new parameter_declaration_declaration_specifiers(m_ds->clone());
    }
//        copy->clone_copy(this);
    return copy;
}

void expression_type::remove_volatile(void) {
    m_sql = m_sql->remove_volatile();
    if(m_ad) {
        m_ad = (abstract_declarator*)m_ad->remove_volatile();
    }
}

AST_node * declaration_specifiers_type_qualifier::remove_volatile(void) {
    if(m_tq->is_volatile()) {
        delete m_tq;
        m_tq = NULL;
        return NULL;
    } else {
        return this;
    }
}

bool assignment_expression_unary_expression_assignment_operator_assignment_expression::is_part_of_lhs(AST_node *node) {
	return search_up_for_node(node, m_ue);
}

#endif // __cplusplus
